#SPectral ANalysis software (SPAN).
#Written by Daniele Gasparri#


"""
    Copyright (C) 2018-2024, Daniele Gasparri

    E-mail: daniele.gasparri@gmail.com

    SPAN is a GUI interface that allows to modify and analyze 1D long-slit reduced spectra.
    It is provided "as is" without any warranty whatsoever.
    Permission to use for non-commercial purposes is granted.
    Permission to modify for personal or internal use is granted,
    provided that this copyright and disclaimer are included unchanged
    at the beginning of the file. All other rights are reserved.
    In particular, redistribution of the code is not allowed.

    How to run: just compile the code with Python 3.X and use the pre-loaded example files
    to play with the GUI.
    Check the Python packages needed in the "readme_span.txt" to run this source code.

"""



######################################################################################
#Version histories

#Version 5.0 (20240221):
#Rearranged the spectra pre-processing framework by incorporating crop and wavelet cleaning tasks.
#Added parameters buttons to sigma clip cleaning (now dynamic cleaning), dopcor, and heliocor.
#Fixed a bug in the "Compare with" task.
#Introduced the continuum modeling task, allowing for a more refined way to model and subtract (or divide) the continuum of the spectra.

#Version 4.7 (20240201):
#Adapted the code to the new release of ppxf. Ppxf is no longer included in the code package and must be installed via pip.
#Provided the option to choose between three stellar libraries for the ppxf tasks (kinematics and stellar populations).
#Added the capability to save all parameters and load them.
#Implemented some minor changes to the layout.

#Version 4.6 (20240114):
#Included the emission correction and interpolation of the Lick/IDS indices in the EW measurement task. This provides information about the age, metallicity, and alpha-enhancement of the stellar populations of galaxies using the models of Thomas 2010.
#Implemented Monte Carlo simulations to estimate uncertainties on stellar parameters via Lick/IDS index interpolation.

#Version 4.5 (20231221):
#Added the Lick/IDS index measurements and sigma correction in the EW task.

#Version 4.4 (20230215):
#Introduced the 2D spectra extraction standalone panel (still experimental), enabling the correction and extraction of long-slit 1D spectra from a 2D fits wavelength-calibrated images.

#Version 4.3 (20230207):
#Added the plot window to display the results generated by SPAN.
#Implemented the "match rows" feature in the text editor to match and merge rows of two ASCII files, space-separated, with one column in common.

#Version 4.2 (20231203):
#Introduced the fits header editor button with three possible operations on the fits files:
#Modify the keyword of a single file.
#Modify the keywords of a list of files.
#Extract a keyword from a list of fits files.

#Version 4.1 (20231202):
#Added the blackbody fitting task.

#Version 4.0 (20231123):
#Adjusted the layout of the spectral analysis.
#Added the terminal output.
#Fixed various bugs.
#Rectified the progress bar.
#Introduced the text editor and the menu bar.

#Version 3.5 (20221120):
#Added the ppxf algorithm for kinematics and stellar populations.

#Version 3.4 (20221114):
#Included the Line(s) fitting task.
#Corrected minor bugs.

#Version 3.3 (20221109):
#Modified the Cross-correlation calculation.
#Fixed a bug that caused the program to crash if two spectral analysis tasks were selected.
#Implemented checks and existing conditions on the spectral analysis files and values.

#Version 3.2 (20221106):
#Added tooltips to the tasks/buttons for better clarification of their functions.

#Version 3.1 (20221105):
#Rearranged the GUI.
#Fixed a bug in the sigma coefficient calculation task.

#Version 3.0 (20221104):
#Implemented key values instead of increasing numbers in the GUI. This allows adding and modifying entries without changing all the value numbers.

#Version 2.95 (20220128):
#Added the calculation of the equivalent width (EW) and uncertainties also in magnitude.

#Version 2.9 (20220119):
#Incorporated SNR determination in the EW task. Now, when measuring the EW, the program also provides the SNR calculated in the pseudo-continuum bands.

#Version 2.7 (20211124):
#Adjusted the Sigma coeff and EW correct tasks to be truly standalone, with a proper cycle and progress bar.

#Version 2.6 (20211123):
#Adjusted the position of the preview result button to fit the low resolution of my screen after the upgrade of PySimpleGUI, which enlarged my window automatically and without reason.

#Version 2.5 (20211123):
#Added a progress meter for the "Process All" event.

#Version 2.4 (20211122):
#Now you can finally process just one spectrum!

#Version 2.3 (20211122):
#Added the degrade function in lambda (FWHM) to degrade the spectrum to a certain FWHM in Angstrom.

#Version 2.2 (20210927):
#Adjusted the utility menu and added the possibility to save the SNR of the spectra to a file.

#Version 2.1 (20210916):
#Rearranged the utility menu and introduced the conversion of flux from Jansky to MKS and MKS f_lambda.

#Version 2.0 (20210630):
#Added the 'compare spectra' utility.
#Improved the sigma clipping, now called the clean task.
#Rearranged the tasks in the pre-processing and processing frames.
#Enhanced the plot for velocity dispersion measurements.
#Implemented a check on the existence of the loaded spectra.

#Version 1.9 (20210626):
#Some cosmetic changes to the graphical layout.

#Version 1.8 (20210626):
#Added the save plot option in the spectral analysis frame.
#Improved plots of the sigma coeff determination task.

#Version 1.7 (20210615):
#Changed the file names of the result files to include a timestamp, preventing overwriting of older files. Changed the name of the probram.

#Version 1.6 (20200711):
#Added the task to measure the resolution of the selected spectra in the Utility tab. Some major changes to layout.

#Version 1.0 (202006015):
#Changing to the read_spec function for the 1dFit spec, excluding PyAstronomy.pyasl since it is not working with the standalone version of the program. Now the program is called SPAN and not SPEIM anymore. Welcome SPAN!

####################################################################################
####################################################################################
################ LET'S START #######################################################

import PySimpleGUI as sg   
import span_functions as span
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os
from astropy.coordinates import SkyCoord, EarthLocation
import time
import datetime
from scipy.signal import argrelextrema
from scipy import interpolate
import matplotlib.backends.backend_tkagg
from astropy.io import fits
from matplotlib.colors import LogNorm
import os
import math as mt
import io
from scipy.interpolate import griddata
from matplotlib.ticker import MultipleLocator
import json


# all events, keys and values of the program in order to store them in a .json configuration file
def save_settings(filename, keys, events, values):
    data = {
        'keys': keys,
        'events': events,
        'values': {
            'spec_list': values.get('spec_list', ''),
            'wave_units_nm': values.get('wave_units_nm', True),
            'wave_units_a': values.get('wave_units_a', False),
            'wave_units_mu': values.get('wave_units_mu', False),
            #'listfile': values.get('listfile', False),
            'show_hdr': values.get('show_hdr', False),
            'show_step': values.get('show_step', False),
            'show_res': values.get('show_res', False),
            'lambda_res_left': values.get('lambda_res_left', ''),
            'lambda_res_right': values.get('lambda_res_right', ''),
            'convert_spec': values.get('convert_spec', False),
            'convert_to_txt': values.get('convert_to_txt', False),
            'convert_to_fits': values.get('convert_to_fits', False),
            'compare_spec': values.get('compare_spec', False),
            'spec_to_compare': values.get('spec_to_compare', ''),
            'convert_flux': values.get('convert_flux', False),
            'convert_to_fnu': values.get('convert_to_fnu', False),
            'convert_to_fl': values.get('convert_to_fl', False),
            'show_snr': values.get('show_snr', False),
            'wave_snr': values.get('wave_snr', ''),
            'delta_wave_snr': values.get('delta_wave_snr', ''),
            'cropping': values.get('cropping',False),
            'cropping_low_wave':values.get('cropping_low_wave',''),
            'cropping_high_wave':values.get('cropping_high_wave',''),
            'sigma_clip': values.get('sigma_clip', False),
            'clip_factor': clip_factor,
            'res_spec_for_sigma_clip': sigma_clip_resolution,
            'single_vel_clip' : sigma_clip_single_vel,
            'clip_to_vel': sigma_clip_single_value,
            'file_for_clip': sigma_clip_have_file,
            'sigma_clip_file': sigma_clip_sigma_file,
            'wavelet_cleaning': values.get('wavelet_cleaning', False),
            'sigma_wavelets': values.get('sigma_wavelets',''),
            'wavelets_layers': values.get('wavelets_layers',''),
            'dopcor': values.get('dopcor', False),
            'dopcor_value': dop_cor_single_shot_vel,
            'file_for_dopcor': dop_cor_have_file,
            'dopcor_file': dop_cor_file,
            'dopcor_single_value': dop_cor_single_shot,
            'helio_corr': values.get('helio_corr', False),
            'file_for_helio': helio_have_file,
            'helio_file': helio_file,
            'helio_single_value': helio_single_shot,
            'helio_location': helio_single_shot_location,
            'helio_date': helio_single_shot_date,
            'helio_ra': ra_obj,
            'helio_dec': dec_obj,
            'rebin': values['rebin'],
            'rebin_pix_lin': values['rebin_pix_lin'],
            'rebin_step_pix': values['rebin_step_pix'],
            'rebin_sigma_lin': values['rebin_sigma_lin'],
            'rebin_step_sigma': values['rebin_step_sigma'],

            'degrade_resolution': values['degrade_resolution'],
            'is_initial_res_r': is_initial_res_r,
            'degrade_from_r': initial_res_r,
            'res_degrade_to_r': res_degrade_to_r,
            'degrade_to_r': final_res_r,
            'res_degrade_to_fwhm': res_degrade_to_fwhm,
            'final_res_r_to_fwhm': final_res_r_to_fwhm,
            'is_initial_res_fwhm': is_initial_res_fwhm,
            'degrade_from_l': initial_res_fwhm,
            'degrade_to_l': final_res_fwhm,

            'norm_spec': values['norm_spec'],
            'norm_wave': values['norm_wave'],

            'cont_sub': values['cont_sub'],
            'cont_model_filtering' : cont_model_filtering,
            'cont_model_poly' : cont_model_poly,
            'markers_cont_operations' : cont_math_operation,
            'cont_want_to_maks' : cont_want_to_maks,
            'cont_mask_ranges' : cont_mask_ranges_str,
            'cont_poly_degree' : cont_poly_degree,

            'broadening_spec': values['broadening_spec'],
            'sigma_to_add': values['sigma_to_add'],
            'add_noise': values['add_noise'],
            'noise_to_add': values['noise_to_add'],

            'filter_denoise' : values['filter_denoise'],
            'moving_average' : moving_average,
            'box_moving_avg' : box_moving_avg,
            'box_moving_avg_size' : box_moving_avg_size,
            'gauss_moving_avg' : gauss_moving_avg,
            'gauss_moving_avg_kernel' : gauss_moving_avg_kernel,
            'low_pass_filter' : low_pass_filter,
            'lowpass_cut_off' : lowpass_cut_off,
            'lowpass_order' : lowpass_order,
            'bandpass_filter' : bandpass_filter,
            'bandpass_lower_cut_off' : bandpass_lower_cut_off,
            'bandpass_upper_cut_off' : bandpass_upper_cut_off,
            'bandpass_order' : bandpass_order,

            'avg_all': values['avg_all'],
            'norm_avg_all': values['norm_avg_all'],
            'none': values['none'],
            'sum_all': values['sum_all'],
            'norm_sum_all': values['norm_sum_all'],
            'use_for_spec_an': values['use_for_spec_an'],
            'subtract_norm_avg': values['subtract_norm_avg'],
            'subtract_norm_spec': values['subtract_norm_spec'],
            'spec_to_sobtract': values['spec_to_sobtract'],
            'add_pedestal': values['add_pedestal'],
            'pedestal_to_add': values['pedestal_to_add'],
            'multiply': values['multiply'],
            'multiply_factor': values['multiply_factor'],
            'bb_fitting': values['bb_fitting'],
            'xcorr': values['xcorr'],
            'sigma_measurement': values['sigma_measurement'],
            'ew_measurement': values['ew_measurement'],
            'line_fitting': values['line_fitting'],
            'ppxf_kin': values['ppxf_kin'],
            'ppxf_pop': values['ppxf_pop'],
            'sigma_coeff': values['sigma_coeff'],
            'sigma_corr': values['sigma_corr'],
            'save_intermediate_files': values['save_intermediate_files'],
            'save_plots': values['save_plots'],
            #subwindows parameters
            'left_wave_bb': wave1_bb,
            'right_wave_bb': wave2_bb,
            't_guess_bb': t_guess,
            'xcorr_template': template_crosscorr,
            'xcorr_template_wave_nm': lambda_units_template_crosscorr_nm,
            'xcorr_template_wave_a': lambda_units_template_crosscorr_a,
            'xcorr_template_wave_mu': lambda_units_template_crosscorr_mu,
            'xcorr_smooth_template': smooth_template_crosscorr,
            'xcorr_smooth_template_value': smooth_value_crosscorr,
            'xcorr_wave_range': limit_range_corr,
            'xcorr_left_lambda': low_wave_corr,
            'xcorr_right_lambda': high_wave_corr,
            'xcorr_vel_range': vel_range_corr,
            'xcorr_low_vel': low_vel_corr,
            'xcorr_high_vel': high_vel_corr,
            'sigma_template': template_sigma,
            'lambda_units_template_sigma_nm': lambda_units_template_sigma_nm,
            'lambda_units_template_sigma_a': lambda_units_template_sigma_a,
            'lambda_units_template_sigma_mu': lambda_units_template_sigma_mu,
            'band_cat': band_cat,
            'band_halpha': band_halpha,
            'band_nad': band_nad,
            'band_h': band_h,
            'band_k': band_k,
            'resolution_spec': resolution_spec,
            'resolution_template': resolution_template,
            'band_custom': band_custom,
            'low_wave_sigma': low_wave_sigma,
            'high_wave_sigma': high_wave_sigma,
            'low_wave_cont': low_wave_cont,
            'high_wave_cont': high_wave_cont,
            'ew_idx_file': have_index_file,
            'idx_file': index_file,
            'single_index': single_index,
            'left_wave_blue_cont': idx_left_blue,
            'right_wave_blue_cont': idx_right_blue,
            'left_wave_red_cont': idx_left_red,
            'right_wave_red_cont': idx_right_red,
            'left_line': idx_left_line,
            'right_line': idx_right_line,
            'ew_lick': lick_ew,
            'lick_constant_fwhm': lick_constant_fwhm,
            'spec_lick_res_fwhm': spec_lick_res_fwhm,
            'lick_constant_r': lick_constant_r,
            'spec_lick_res_r': spec_lick_res_r,
            'lick_correct_emission': lick_correct_emission,
            'z_guess_lick_emission': z_guess_lick_emission,
            'dop_correction_lick': dop_correction_lick,
            'correct_ew_sigma': correct_ew_sigma,
            'radio_lick_sigma_auto': radio_lick_sigma_auto,
            'radio_lick_sigma_single': radio_lick_sigma_single,
            'sigma_single_lick': sigma_single_lick,
            'radio_lick_sigma_list': radio_lick_sigma_list,
            'sigma_lick_file': sigma_lick_file,
            'stellar_parameters_lick': stellar_parameters_lick,
            'cat_fit': cat_band_fit,
            'line_fit_single': usr_fit_line,
            'emission_line': emission_line,
            'left_wave_fitting': low_wave_fit,
            'right_wave_fitting': high_wave_fit,
            'y0': y0,
            'x0': x0,
            'a': a,
            'sigma': sigma,
            'm': m,
            'c': c,
            'left_wave_ppxf_kin': wave1_kin,
            'right_wave_ppxf_kin': wave2_kin,
            'stellar_library_kin': stellar_library_kin,
            'constant_resolution_lambda': constant_resolution_lambda,
            'ppxf_resolution': resolution_kin,
            'constant_resolution_r': constant_resolution_r,
            'ppxf_resolution_r': resolution_kin_r,
            'sigma_guess_kin': sigma_guess_kin,
            'redshift_guess_kin': redshift_guess_kin,
            'additive_degree_kin': additive_degree_kin,
            'left_wave_ppxf_pop': wave1_pop,
            'right_wave_ppxf_pop': wave2_pop,
            'resolution_ppxf_pop': res_pop,
            'sigma_guess_pop': sigma_guess_pop,
            'ppxf_z_pop': z_pop,
            'gas_pop': pop_with_gas,
            'ppxf_pop_tie_balmer': ppxf_pop_tie_balmer,
            'ppxf_pop_reddening': ppxf_pop_reddening,
            'no_gas_pop': pop_without_gas,
            'regul_err': regul_err,
            'additive_degree': additive_degree,
            'multiplicative_degree': multiplicative_degree,
            'stellar_library': stellar_library,
            'ppxf_err_pop': with_errors,
            'ew_corr_idx_file': have_index_file_corr,
            'idx_corr_file': index_file_corr,
            'ew_corr_single_idx': single_index_corr,
            'stellar_spectra_coeff_file': stellar_spectra_coeff_file,
            'sigma_coeff_sample_list': stellar_spectra_coeff_file,
            'sigma_coeff_sample_list_wave_nm': lambda_units_coeff_nm,
            'sigma_coeff_sample_list_wave_a': lambda_units_coeff_a,
            'sigma_coeff_sample_list_wave_mu': lambda_units_coeff_mu,
            'sigma_coeff_sample_smooth': smooth_stellar_sample,
            'sigma_coeff_sample_smooth_sigma': smooth_value_sample,
            'sigma_file': sigma_vel_file,
            'ew_file_to_correct': ew_list_file,
            'coeff_sigma_file': sigma_coeff_file,


        }
    }
    with open(filename, 'w') as file:
        json.dump(data, file)

#function to load the .json configuration file
def load_settings(filename):
    try:
        with open(filename, 'r') as file:
            data = json.load(file)
            return data['keys'], data['events'], data['values']
    except FileNotFoundError:
        return [], [], {}



#***************************************************************************************************************#


################ Pysimplegui User Interface construction ####################
listbox1 = ['Browse a spectra file list and click Load spectra ']

#In you want to change the colors of the panel
#sg.ChangeLookAndFeel('GreenTan')   
sg.SetOptions(tooltip_time=1000) #tooltip time after mouse over
scale_win = 0.5
#Building the main panel#
#def make_win1():
layout = [
            [sg.Menu([['&File', ['&Load spectra', '&Save parameters...', 'Load parameters...', 'Restore default parameters', 'E&xit']], ['&Edit', ['&Copy', '&Paste', 'Clear all tas&ks', 'Clean output']], ['&Help', ['&Quick start', '&Read me']], ['P&rocess',['Pl&ot', 'Pre&view spec.']], ['&Analysis', ['Preview res&ult', 'Proc&ess selected', 'Process a&ll']], ['&Window', ['Text editor', 'FITS header editor', 'Plot data', '2D spec extraction']], ['EW sigma correction', ['Compu&te!', 'Corre&ct!']], ['&About', ['About SPAN', 'Version', 'Read me']]  ])],
            [sg.Frame('Open spectra', [
            [sg.Text('Spectra file list:', size=(15, 1), auto_size_text=False), sg.InputText('example_files/xshooter_vis_sample_list_spectra.dat', size=(25, 1), key='spec_list' ), sg.FileBrowse(tooltip='Load an ascii file list of spectra or a single (fits, txt) spectrum')],
            [sg.Button('Create spectra list', size = (14,1), font = ('Helvetica', 11), key = 'listfile',tooltip='If you do not have a spectra file list, you can generate here'), sg.Push(), sg.Checkbox('I have just one spectrum', font = ('Helvetica', 10, 'bold'), key='one_spec',tooltip='Check this if you want to load just one spectrum instead a text file containing the names of the spectra')],
            [sg.Text('Spectra wavelength is in:'), sg.Radio('nm', "RADIO2", size=(5,1), default=True, key = 'wave_units_nm' ), sg.Radio('A', "RADIO2", key = 'wave_units_a'), sg.Radio('mu', "RADIO2" , key = 'wave_units_mu')],
            [sg.Button('Load spectra', size=(13, 2), font = ('Helvetica', 11, 'bold'),button_color=('black','light green')), sg.Push(), sg.Button('Plot',button_color=('black','light gray'), size = (8,1)), sg.Push(), sg.Button('Quick start',button_color=('black','orange'))],

            #Load the listbox where the spectra loaded will appear
            [sg.Text(' ', font = ('Helvetica',3))]], font=("Helvetica", 14, 'bold'), title_color = 'orange'), sg.Listbox(values = listbox1, size=(46, 10), key='-LIST-', horizontal_scroll=True),

            #Utility frame
            sg.Frame('Utilities', [
            [sg.Checkbox('HDR', font = ('Helvetica', 10, 'bold'), key = 'show_hdr',tooltip='Show fits header'), sg.Checkbox('Step', font = ('Helvetica', 10, 'bold'), key = 'show_step',tooltip='Show spectrum wavelength step'), sg.Checkbox('Res.:', font = ('Helvetica', 10, 'bold'), key = 'show_res',tooltip='Show resolution, by fitting a sky emission line within the wavelength 1(W1) and wavelength 2(W2) values'),sg.Text('W1'), sg.InputText('550', size = (4,1), key = 'lambda_res_left'), sg.Text('W2'), sg.InputText('565', size = (4,1), key = 'lambda_res_right')],
            [ sg.Checkbox('Convert spectrum to:', font = ('Helvetica', 10, 'bold'), key = 'convert_spec',tooltip='Convert one or all the spectra from fits to ASCII and viceversa'), sg.Radio('Text', "RADIOCONV", default = True, key = 'convert_to_txt'), sg.Radio('FITS', "RADIOCONV", key = 'convert_to_fits')],
            [sg.Checkbox('Compare with: ', font = ('Helvetica', 10, 'bold'), key = 'compare_spec',tooltip='Compare the selected spectrum with any other loaded spectrum'), sg.InputText('Spec.', size = (13,1), key = 'spec_to_compare'), sg.FileBrowse(tooltip='Load the 1D spectrum (ASCII or fits)to use as comparison')],
            [sg.Checkbox('Convert Flux', font = ('Helvetica', 10, 'bold'), key = 'convert_flux',tooltip='Convert the flux from Jansky to F_lambda and viceversa'), sg.Radio('Jy-->F_nu', "FLUX", default = True, key = 'convert_to_fnu'), sg.Radio('Jy-->F_l', "FLUX", key = 'convert_to_fl'), sg.Push(),sg.Button('See plot',button_color=('black','light gray'))],
            [sg.Checkbox('S/N:', font = ('Helvetica', 10, 'bold'), key = 'show_snr',tooltip='Show the S/N of the selected spectrum centered on an user defined wavelength(W)'), sg.Text(' W.'), sg.InputText('609', size = (4,1), key = 'wave_snr'), sg.Text('+/-'), sg.InputText(3, size = (3,1), key = 'delta_wave_snr'), sg.Push(), sg.Button('Save one',button_color=('black','light gray')), sg.Button('Save all',button_color=('black','light gray'))]  ], font=("Helvetica", 12, 'bold')),

            #Buttons to perform the utility actions
            sg.Frame('Utility Actions',[
            [sg.Button('Show info',button_color=('black','light gray'), size = (11,1))],
            [sg.Button('One',button_color=('black','light gray'), size = (4,1)), sg.Button('All',button_color=('black','light gray'), size = (4,1))],
            [sg.Button('Compare',button_color=('black','light gray'), size = (11,1))],
            [sg.Button(' One',button_color=('black','light gray'), size = (4,1)), sg.Button(' All',button_color=('black','light gray'), size = (4,1))],
            [sg.Button('Show snr',button_color=('black','light gray'), size = (11,1))],
            ],font=("Helvetica", 10, 'bold'))],
            [sg.HorizontalSeparator()],

            #middle frame: operations on the spectra
            #Spectra pre-processing
            [sg.Frame('Spectra pre-processing', [
            [sg.Checkbox('Cropping', key ='cropping', font = ('Helvetica', 10, 'bold'), tooltip='Crop the spectrum to a user defined wavelength range'), sg.Text('Lower wave'), sg.InputText(480, key = 'cropping_low_wave', size = (5,1)), sg.Text('Upper wave'), sg.InputText(550, key = 'cropping_high_wave', size = (5,1))],

            [sg.Checkbox('Dynamic cleaning', font = ('Helvetica', 10, 'bold'), key = 'sigma_clip',tooltip='Perform sigma clipping to erase spikes'), sg.Push(), sg.Button('Clean parameters',button_color= ('black','light blue'), size = (22,1))],

            [sg.Checkbox('Wavelet cleaning', font = ('Helvetica', 10, 'bold'), key = 'wavelet_cleaning',tooltip='Perform wavelet cleaning of the spectrum'), sg.Text('Sigma:'),sg.InputText(0.02, key = 'sigma_wavelets', size = (4,1)), sg.Text('Wavelet layers:'), sg.InputText(3, key = 'wavelets_layers', size = (3,1))],

            [sg.Checkbox('Filtering and denoising', font = ('Helvetica', 10, 'bold'), key = 'filter_denoise',tooltip='Filters to smooth the spectrum'), sg.Push(), sg.Button('Denoise parameters',button_color= ('black','light blue'), size = (22,1))],

            [sg.Checkbox('Doppler correction', font = ('Helvetica', 10, 'bold'), key = 'dopcor',tooltip='Doppler correction of spectrum, from a velocity list file or from a fixed radial velocity value'), sg.Push(), sg.Button('Dopcor parameters',button_color= ('black','light blue'), size = (22,1))],

            [sg.Checkbox('Heliocentric correction', font = ('Helvetica', 10, 'bold'), key = 'helio_corr',tooltip='Heliocentric correction, from a formatted file or by inserting the location, time and object coordinates (RA and Dec) manually'), sg.Push(), sg.Button('Heliocor parameters',button_color= ('black','light blue'), size = (22,1))],

            ], font=("Helvetica", 12, 'bold'), title_color = 'lightgreen'),

            #2) spectra processing
            sg.Frame('Spectra processing', [
            [sg.Checkbox('Rebin', font = ('Helvetica', 10, 'bold'), key = 'rebin',tooltip='Rebinning the spectrum, to a linear wavelength step (nm) or to a linear sigma step (km/s)'), sg.Radio('pix lin.', "RADIO1", default=True, key = 'rebin_pix_lin'), sg.InputText(0.02, size = (4,1), key = 'rebin_step_pix'), sg.Radio('sigma lin.', "RADIO1", key = 'rebin_sigma_lin'), sg.InputText(0, size = (3,1), key = 'rebin_step_sigma')],
            [sg.Checkbox('Degrade resolution', font = ('Helvetica', 10, 'bold'), key = 'degrade_resolution',tooltip='Degrade resolution to a user defined value'), sg.Push(), sg.Button('Degrade parameters',button_color= ('black','light blue'), size = (20,1))],

            [sg.Checkbox('Normalise spectrum to:', font = ('Helvetica', 10, 'bold'), key = 'norm_spec',tooltip='Normalise the flux to a user defined wavelength'), sg.InputText(500, size = (6,1), key = 'norm_wave'), sg.Text('nm')],

            [sg.Checkbox('Sigma broadening', font = ('Helvetica', 10, 'bold'), key = 'broadening_spec',tooltip='Broad the spectrum by adding a user defined sigma (km/s). This will NOT be the total sigma broadening of your spectrum!'), sg.Text('Add sigma (km/s): ', font = ('Helvetica', 10)), sg.InputText(0, size = (4,1), key = 'sigma_to_add')],
            [sg.Checkbox('Add noise', font = ('Helvetica', 10, 'bold'), key = 'add_noise',tooltip='Adding poissonian noise to the spectrum'), sg.Text('Signal to Noise (S/N) to add:'), sg.InputText(10, size = (5,1), key = 'noise_to_add')],

            [sg.Checkbox('Continuum modelling', font = ('Helvetica', 10, 'bold'), key = 'cont_sub',tooltip='Perform the continuum estimation to subtract or divide to the spectrum'), sg.Push(), sg.Button('Continuum parameters',button_color= ('black','light blue'), size = (20,1))],
                [sg.Text('', font = ('Helvetica', 1))],

            ], font=("Helvetica", 12, 'bold'),title_color = 'lightgreen'),

            #3) spectra math
            sg.Frame('Spectra math', [
            #[sg.Text('', font = ('Helvetica',1))],
            [sg.Radio('Average all', "RADIOMATH", key = 'avg_all',tooltip='Average all the loaded spectra'), sg.Radio('Norm. and average all', "RADIOMATH", key = 'norm_avg_all',tooltip='First normalise, then average all the loaded spectra'), sg.Radio('Nothing', "RADIOMATH", default = True, key = 'none',tooltip='Select this option if you DO NOT want to combine the spectra')],
            [sg.Radio('Sum all', "RADIOMATH", key = 'sum_all',tooltip='Sum all the loaded spectra'), sg.Radio('Norm. and sum all', "RADIOMATH", key = 'norm_sum_all',tooltip='First normalise, then sum all the loaded spectra'), sg.Checkbox('Use for spec. an.', text_color = 'yellow', key = 'use_for_spec_an',tooltip='Select this to use the combined spectrum for the spectral analysis')],
            [sg.Checkbox('Subtract normalised average', font = ('Helvetica', 10, 'bold'), key = 'subtract_norm_avg',tooltip='Normalise and subtract to the selected spectrum the normalised average of all the spectra')],
            [sg.Checkbox('Subtract norm. spec.', font = ('Helvetica', 10, 'bold'), key = 'subtract_norm_spec',tooltip='Normalise and subtract to the selected spectrum a user selected spectrum'), sg.InputText('Spectrum to subtract', size = (18,1), key = 'spec_to_sobtract'), sg.FileBrowse(tooltip='Load a spectrum (ASCII or fits) to be normalised and subtracted')],
            [sg.Checkbox('Add pedestal', font = ('Helvetica', 10, 'bold'), key = 'add_pedestal',tooltip='Simply add a constant value to the spectrum'), sg.InputText(0, size = (20,1), key = 'pedestal_to_add')],
            [sg.Checkbox('Multiply by a constant', font = ('Helvetica', 10, 'bold'), key = 'multiply',tooltip='Multiply the spectrum by a constant'), sg.InputText(1 , size = (20,1), key = 'multiply_factor')],
            [sg.Text('', font = ('Helvetica',1))],
            ],font=("Helvetica", 12, 'bold')),

            #4) Buttons to perform actions on the spectra
            sg.Frame('Spec. Actions',[
            [sg.Button('I need help',button_color=('black','orange'), size = (11,1))],
            [sg.Text('')],
            [sg.Button('Original spec.',button_color=('black','light gray'), size = (11,1),tooltip='Plot the original spectrum')],
            [sg.Button('Preview spec.',button_color=('black','light gray'), size = (11,2), font=("Helvetica", 10, 'bold'),tooltip='Plot the processed spectrum')],
            [sg.Text('')],
            [sg.Text('')],
            #[sg.Text('', font = ("Helvetica",2))],
            ],font=("Helvetica", 10, 'bold'))],

            #[sg.Text('', font = ("Helvetica", 1))],
            [sg.HorizontalSeparator()],
            [sg.Text('', font = ("Helvetica", 1))],
            #Spectral analysis frame
            [sg.Frame('Spectral analysis', [

            #0) Black-body fitting
            [sg.Checkbox('Blackbody fitting', font = ('Helvetica', 11, 'bold'), key = 'bb_fitting',tooltip='Blackdoby Planck function fitting. Works fine for stellar spectra and wide wavelength range'),sg.Push(), sg.Button('Blackbody parameters',button_color= ('black','light blue'), size = (22,1))],

            #1) Cross-correlation
            [sg.Checkbox('Cross-correlation', font = ('Helvetica', 11, 'bold'), key = 'xcorr',tooltip='Cross-correlating a band with a template. Works better with continuum normalisation. Use Kinematics for more accurate results'),sg.Push(), sg.Button('Xcorr parameters',button_color= ('black','light blue'), size = (22,1))],

            #2) Velocity disperion measurement
            [sg.Checkbox('Velocity dispersion', font = ('Helvetica', 11, 'bold'), key = 'sigma_measurement',tooltip='Fitting a band with a template. Rough but fast. Use Kinematics for accurate science results'),sg.Push(), sg.Button('Sigma parameters',button_color= ('black','light blue'), size = (22,1))],


            #3) Equivalent width measurement
            [sg.Checkbox('Equivalent width (EW)', font = ('Helvetica', 11, 'bold'), key = 'ew_measurement',tooltip='Equivalent width measurement for a list of indices, a single user defined index and Lick/IDS indices'),sg.Push(), sg.Button('Equivalent width parameters',button_color= ('black','light blue'), size = (22,1))],
            #[sg.HorizontalSeparator()],


            #4) Line fitting
            [sg.Checkbox('Line(s) fitting', font = ('Helvetica', 11, 'bold'), key = 'line_fitting',tooltip='User line or automatic CaT band fitting with gaussian functions'),sg.Push(), sg.Button('Line fitting parameters',button_color= ('black','light blue'), size = (22,1))],
            #[sg.HorizontalSeparator()],

            #5) Kinematics with ppxf
            [sg.Checkbox('Kinematics with ppxf', font = ('Helvetica', 11, 'bold'), key = 'ppxf_kin',tooltip='Perform the fitting of a spectral region and gives the kinematics'),sg.Push(), sg.Button('ppxf kin parameters',button_color= ('black','light blue'), size = (22,1))  ],
            #[sg.HorizontalSeparator()],

            #6) Stellar populations with ppxf
            [sg.Checkbox('Stellar populations with ppxf', font = ('Helvetica', 11, 'bold'), key = 'ppxf_pop',tooltip='Perform the fitting of a spectral region and gives the properties of the stellar populations'),sg.Push(), sg.Button('ppxf pop parameters',button_color= ('black','light blue'), size = (22,1))  ],
            #, sg.Radio('Gas (balmer)', "RADIOPOP", key = 'gas_pop_balmer'), sg.Radio('Gas (balmer+forb.)', "RADIOPOP", key = 'gas_pop_balmer_forb')],
            [sg.HorizontalSeparator()],


            #7) Determination of the velocity disperion coefficients. Stand alone: need a separate sample of spectra
            [sg.Checkbox('Sigma coeff determination', font = ('Helvetica', 11, 'bold'), text_color = 'light grey', key = 'sigma_coeff',tooltip='Determination of the velocity dispersion coefficients to correct the EW of the indices of the spectrum'),sg.Push(), sg.Button('Sigma coeff parameters',button_color= ('black','light blue'), size = (22,1))],

            #8) Apply the velocity dispersion correction coefficientd to the loaded spectra
            [sg.Checkbox('Correct EWs for sigma', font = ('Helvetica', 11, 'bold'), text_color = 'light grey', key = 'sigma_corr',tooltip='Correct the raw measured EW of the spectra to a zero velocity dispersion frame, using the coefficients calculated in the Sigma coeff determination task'),sg.Push(),sg.Button('Sigma corr parameters',button_color= ('black','light blue'), size = (22,1)) ]
            ], font=("Helvetica", 14, 'bold'), title_color='yellow'),

            #9) Buttons to perform the spectral analysis actions
            sg.Frame('An. Actions',[
            [sg.Button('Help me',button_color=('black','orange'), size = (12,1))],
            [sg.Text('')],
            [sg.Button('Preview result',button_color=('black','light gray'),tooltip='Preview all the results of the Spectral analysis frame', size = (12,2), font=("Helvetica", 10, 'bold'))],
            [sg.Text('')],
            [sg.Text('')],
            [sg.Text('')],
            [sg.Text('')],
            #[sg.Button('Clean output',size = (12,1))],
            [sg.Text('', font = ('Helvetica',1))],
            [sg.HorizontalSeparator()],
            [sg.Button('Compute!',button_color=('black','light grey'), size = (12,1))],
            [sg.Button('Correct!',button_color=('black','light grey'), size = (12,1))],
            ],font=("Helvetica", 9, 'bold')),

            #COMMENT THE FOLLOWING THREE LINES TO HAVE THE EXTERNAL OUTPUT
            sg.Frame('Output', [
            [sg.Output(size=(81, 17), key='-OUTPUT-' , font=('Helvetica', 11))],
            ] ,font=("Helvetica", 12, 'bold')),


            ],

            #General buttons at the end of the panel
            [sg.Button('Process selected', button_color=('white','orange'), size=(15, 2),tooltip='Process the selected spectrum by performing all the enabled tasks'), sg.Button('Process all', button_color=('white','red'), size=(15, 2), tooltip='Process all the loaded spectra by performing all the enabled tasks'), sg.Checkbox('Save intermediate files, if any', default = True, text_color = 'lightgreen', key = 'save_intermediate_files', tooltip='Check this if you want to save all the spectra for any of the tasks selected', font = ('Helvetica', 10, 'bold')), sg.Checkbox('Save plots', default = False, text_color='yellow', key = 'save_plots', tooltip='To save all the plots generated by the Spectral Analysis tasks activated and the Process All method', font = ("Helvetica", 10, 'bold')), sg.Push(),sg.Button('Text editor', tooltip='Stand alone simple text editor',button_color= ('black','light blue')),sg.Button('FITS header editor', tooltip='Stand alone FITS header editor',button_color= ('black','light blue')), sg.Button('Plot data', tooltip='Stand alone data plotter. ASCII files with spaced rows',button_color= ('black','light blue')), sg.Button('2D spec extraction', tooltip='Stand alone program to extracd 1d spectra from 2d fits',button_color= ('black','light blue')), sg.Push(), sg.Exit(size=(15, 2),tooltip='See you soon!')]

                ]
    #Open the window with the title

window1 = sg.Window('SPAN - SPectral ANalysis - 5.0 --- Daniele Gasparri ---', layout,finalize=True, scaling = scale_win)       # start off with 1 window open
keys = []
events = []
values = {}
############# Initialization of the variables needed to succesfully open the panel ###########
#necessary to set the existence conditions of the spectra loaded
spec_names = np.zeros(5)

#create the result directory
result_data = 'results/'
os.makedirs(result_data, exist_ok=True)

result_spec_dir = 'results/spec'
os.makedirs(result_spec_dir, exist_ok=True)
result_spec = result_spec_dir+'/'

#creating the result subdirectories
result_snr_dir = 'results/SNR'
os.makedirs(result_snr_dir, exist_ok=True)

result_bb_dir = 'results/black_body'
os.makedirs(result_bb_dir, exist_ok=True)

result_xcorr_dir = 'results/xcorr'
os.makedirs(result_xcorr_dir, exist_ok=True)

result_vel_disp_dir = 'results/vel_disp'
os.makedirs(result_vel_disp_dir, exist_ok=True)

result_ew_data_dir = 'results/ew'
os.makedirs(result_ew_data_dir, exist_ok=True)

result_line_fitting_dir = 'results/line_fitting'
os.makedirs(result_line_fitting_dir, exist_ok=True)

result_ppxf_kin_data_dir = 'results/ppxf_kin'
os.makedirs(result_ppxf_kin_data_dir, exist_ok=True)

result_ppxf_pop_data_dir = 'results/ppxf_pop'
os.makedirs(result_ppxf_pop_data_dir, exist_ok=True)

result_sigma_coeff_dir = 'results/sigma_coeff'
os.makedirs(result_sigma_coeff_dir, exist_ok=True)

result_plot_dir = 'results/plots'
os.makedirs(result_plot_dir, exist_ok=True)



########## SETTING UN THE DEFAULT PARAMETERS FOR THE TASKS ###################
#DYNAMIC CLEANING PARAMETERS
clip_factor = 2.5
sigma_clip_resolution = 1600
sigma_clip_single_vel = True
sigma_clip_single_value = 30
sigma_clip_have_file = False
sigma_clip_sigma_file = 'txt_sample_files/sigma_clip_data.dat'

#DENOISING PARAMETERS
moving_average = True
box_moving_avg = True
box_moving_avg_size = 11
gauss_moving_avg = False
gauss_moving_avg_kernel = 5
low_pass_filter = False
lowpass_cut_off = 0.1
lowpass_order = 4
bandpass_filter = False
bandpass_lower_cut_off = 0.1
bandpass_upper_cut_off = 0.5
bandpass_order = 4

#DOPCOR DEFAULT PARAMETERS
dop_cor_single_shot_vel = 0
dop_cor_have_file = False
dop_cor_file = 'txt_sample_files/dopcor_file.dat'
dop_cor_single_shot = True

#HELIOCOR DEFAULT PARAMETERS
helio_have_file = False
helio_file = 'txt_sample_files/file_helio.dat'
helio_single_shot = True
helio_single_shot_location = 'Paranal'
helio_single_shot_date = '2016-6-4'
ra_obj = 4.88375
dec_obj = 35.0436389

#DEGRADE RESOLUTION PARAMETERS
is_initial_res_r = True
initial_res_r = 1600
res_degrade_to_r = True
final_res_r = 600
res_degrade_to_fwhm = False
final_res_r_to_fwhm = 8.4
is_initial_res_fwhm = False
initial_res_fwhm = 2.51
final_res_fwhm = 8.4

#CONTINUUM SUBTRACTION PARAMETERS
markers_cont_operations = ['subtract', 'divide']
cont_math_operation = markers_cont_operations[0]
cont_model_filtering = True
cont_model_poly = False
cont_want_to_maks = False
cont_mask_ranges_str = '[(655, 666), (485, 490),(585, 595)]'
cont_mask_ranges = eval(cont_mask_ranges_str)
cont_poly_degree = 5

#BLACKBODY DEFAULT PARAMETERS
wave1_bb = 600.
wave2_bb = 900.
t_guess = 4000.

#CROSS-CORRELATION DEFAULT PARAMETERS
lambda_units_template_crosscorr = 'a'
smooth_template_crosscorr = False
smooth_value_crosscorr = 0.
limit_range_corr = True
low_wave_corr = 840.
high_wave_corr = 880.
vel_range_corr = True
low_vel_corr = -1000
high_vel_corr = 1000
lambda_units_template_crosscorr_nm = False
lambda_units_template_crosscorr_a = True
lambda_units_template_crosscorr_mu = False
wave_interval_corr = np.array([low_wave_corr,high_wave_corr])
real_low_wave_corr = np.min(wave_interval_corr)
real_high_wave_corr = np.max(wave_interval_corr)
vel_interval_corr = np.array([low_vel_corr,high_vel_corr])

template_crosscorr = 'templates/template_emiles.dat'

#SIGMA VEL DEFAULT PARAMETERS
lambda_units_template_sigma = 'a'
lambda_units_template_sigma_nm = False
lambda_units_template_sigma_a = True
lambda_units_template_sigma_mu = False
band_cat = True
band_halpha = False
band_nad = False
band_h = False
band_k = False
band_custom = False
resolution_spec = 5000
resolution_template = 0
low_wave_sigma = 840
high_wave_sigma = 890
low_wave_cont = 856
high_wave_cont = 864
band_sigma = np.array([844., 872.])
cont_sigma = np.array([856.,864.])
template_sigma = 'templates/emiles_template_extended_younger.dat'

#EW DEFAULT VALUES
index_file = 'example_files/index_list_sample.txt'
have_index_file = False
single_index = False
idx_left_blue = 847.4
idx_right_blue = 848.4
idx_left_red = 856.3
idx_right_red = 857.7
idx_left_line = 848.4
idx_right_line = 851.3
index_usr = np.array([idx_left_blue, idx_right_blue, idx_left_red, idx_right_red, idx_left_line, idx_right_line]).T

# FOR LICK/IDS INDEX MEASUREMENTS
lick_ew = True
lick_constant_fwhm = True
spec_lick_res_fwhm = 3.5
lick_constant_r = False
spec_lick_res_r = 5000
radio_lick_sigma_single = False
radio_lick_sigma_list = False
radio_lick_sigma_auto = True
sigma_lick_file = 'example_files/results/sigma_data_ngc5806_bins_new.dat'
sigma_single_lick = 100
correct_ew_sigma = True
sigma_lick_coeff_file = '.sigma_coeff_lick.dat'
lick_index_file = '.lick_indices.dat'
lick_correct_emission = True
z_guess_lick_emission = 0.
lick_ssp_model = '.models_thomas_mod_2010.dat'
stellar_parameters_lick = True
dop_correction_lick = True
stellar_library_lick = 'emiles'

#FIT LINES DEFAULT VALUES
emission_line = False
low_wave_fit = 845
high_wave_fit = 870
y0 = 1
x0 = 850
a = -0.8
sigma = 0.5
m = 0.1
c = 1
cat_band_fit = True
usr_fit_line = False
wave_interval_fit = np.array([low_wave_fit,high_wave_fit])
guess_param = [y0,x0,a,sigma,m,c]
real_cat1 = 849.8
real_cat2 = 854.2
real_cat3 = 866.2
index_ca1 = [847.4,848.4,856.3,857.7,848.4,851.3]
index_ca2 = [847.4,848.4,856.3,857.7,852.2,856.2]
index_ca3 = [861.9,864.2,870,872.5,864.2,868.2]

#PPXF KINEMATICS DEFAULT PARAMETERS
wave1_kin = 480
wave2_kin = 550
resolution_kin = 3.5
resolution_kin_r = 1600
sigma_guess_kin = 100
redshift_guess_kin = 0
constant_resolution_lambda = True
constant_resolution_r = False
markers_ppxf_kin = ['emiles', 'galaxev', 'fsps']
stellar_library_kin = markers_ppxf_kin[0]
additive_degree_kin = 4

#PPXF STELLAR POPULATION PARAMETERS
pop_with_gas = True
pop_without_gas = False
wave1_pop = 480
wave2_pop = 550
res_pop = 3.5
z_pop = 0
sigma_guess_pop = 100
fit_components = ('with_gas')
with_errors = False
regul_err = 0.04 #better than 0.02 for BEARD
additive_degree = -1
multiplicative_degree = 7 # for the BEARD sample from 480 to 5500 7 seems the best for metellicity. 5 is good for age
ppxf_pop_tie_balmer = False
markers_ppxf = ['emiles', 'galaxev', 'fsps']
stellar_library = markers_ppxf[0]
ppxf_pop_reddening = 0

#SIGMA COEFF PARAMETERS
stellar_spectra_coeff_file = 'example_files/irtf_K-M_giants_list_spectra.dat'
lambda_units_coeff_nm = False
lambda_units_coeff_a = False
lambda_units_coeff_mu = True
lambda_units_coeff = 'mu'
smooth_stellar_sample = False
smooth_value_sample = 0
same_idx_ew_task = True
have_index_file_corr = True
index_file_corr = 'example_files/index_list_sample.txt'
single_index_corr = False

#SIGMA CORR DEFAULT PARAMETERS
sigma_vel_file = 'example_files/results/sigma_data.dat'
ew_list_file = 'example_files/results/ew_data.dat'
sigma_coeff_file = 'example_files/results/sigma_coeff.dat'

#2D SPEC EXTRACTION DEFAULT PARAMETERS
file_path_spec_extr = 'example_files/spectra/NGC5806_image.fits'
trace_y_range_str = "(300, 600)"
poly_degree_str = "1"
extract_y_range_str = "(300, 600)"
snr_threshold_str = "20"
pixel_scale_str = "0.252"


#variable to prevent the program to crash in case some of the list spectra loaded are not valid
spectra_number = 0
fatal_condition = 0

# FOR PLOT
file_to_plot = 'example_files/results/NGC5320_populations.dat'

#TIPS WINDOW
def show_tips_window(first_run):
    layout = [[sg.Text("Welcome to SPAN, a Python GUI software for 1D spectra operations and analysis", font = ('Helvetica', 14, 'bold'))],
              [sg.Text('')],
              [sg.Text("Here are some suggestions for you:", font = ('Helvetica', 12))],
              [sg.Text("1. Load the example spectra by clicking the button Load spectra", font = ('Helvetica', 12))],
              [sg.Text("2. Look at the plot by clicking the Plot button", font = ('Helvetica', 12))],
              [sg.Text("3. Perform operations on the selected spectrum from the Spectra pre-processing or Spectra processing frames", font = ('Helvetica', 12))],
              [sg.Text("4. View the result by clicking the Preview spec. button", font = ('Helvetica', 12))],
              [sg.Text("5. If you are satisfied, click Process selected or Process all to save the new spectra", font = ('Helvetica', 12))],
              #[sg.Text('')],
              [sg.HorizontalSeparator()],
              [sg.Text('')],
              [sg.Text('Do you know?', font = ('Helvetica', 12, 'bold'))],
              [sg.Text("- You can perform some spectral analysis on the loaded spectra, or the modified version from the", font = ('Helvetica', 12))],
              [sg.Text("Spectra pre-processing or Spectra processing frames", font = ('Helvetica', 12))],
              [sg.Text("- In the lower right corner, you will find some useful tools to modify a data file, a fits header,", font = ('Helvetica', 12))],
              [sg.Text("  to plot the data generated by the Spectral analysis and to extract 1D spectra from 2D calibrated fits files", font = ('Helvetica', 12))],

              [sg.Text('')],
              [sg.Checkbox("Don't show this window again", default=not first_run, key='check')],
              [sg.Button("OK")]]

    window = sg.Window("SPAN tips", layout, modal=True)

    while True:
        event, values = window.read()

        if event == sg.WINDOW_CLOSED or event == 'OK':
            break

    window.close()

    # Saves the user's choice to show suggestions or not
    save_config(".config.ini", show_tips=not values['check'])

def save_config(file_path, show_tips=True):
    config = {
        'show_tips': show_tips
    }
    with open(file_path, 'w') as config_file:
        for key, value in config.items():
            config_file.write(f"{key}={value}\n")

def load_config(file_path):
    config = {}
    with open(file_path, 'r') as config_file:
        for line in config_file:
            key, value = line.strip().split('=')
            config[key] = bool(value.lower() == 'true')
    return config

sg.theme('DefaultNoMoreNagging')

# Check if it is the first execution
if not os.path.exists(".config.ini"):
    show_tips_window(True)
    save_config(".config.ini", show_tips=True)
else:
    config = load_config(".config.ini")
    if config['show_tips']:
        show_tips_window(False)






print ('***********************************************')
print ('********* Welcome to SPAN version 5.0 *********')
print ('********* Written by Daniele Gasparri *********')
print ('***********************************************')
print ('')
print ('SPAN is a GUI Python software to perform operations and analysis on 1D reduced spectra, both stars and galaxies, from the UV to the NIR (but you can test it for other wavelength ranges as well)')
print ('')
print ('This is the output where the infos are showed.')
print ('If you just click the Load Spectra button, the example files are loaded and you can make some practise. Otherwise:')
print ('Please, load some spectra WITH THE SAME LAMBDA UNITS or just one spectrum in the upper left panel.')
print ('')
print ('NOTE: all the SPAN wavelength units are expressed in nm, except where clearly stated (yes, I know you prefer Angstrom)')
print ('***********************************************')

while True:
    #time.sleep(0.5) #delay of the terminal ambedd window update. USELESS!
    #variables to see if at least I did a task and it's worth to save the results
    task_done = 0
    task_done2 = 0
    task_spec = 0
    task_spec2 = 0
    util_task = 0
    timestamp = time.strftime("%Y%m%d_%H%M%S")

    window, event, values = sg.read_all_windows()

    if event in (sg.WIN_CLOSED, 'Exit'):
        break

    #Copy and paste event
    if event in ('Copy', 'Paste'):
        widget = window.find_element_with_focus().widget
        try:
            if event == 'Copy' and widget.select_present():
                text = widget.selection_get()
                window.TKroot.clipboard_clear()
                window.TKroot.clipboard_append(text)
            elif event == 'Paste':
                if widget.select_present():
                    widget.delete(sg.tk.SEL_FIRST, sg.tk.SEL_LAST)
                widget.insert(sg.tk.INSERT, window.TKroot.clipboard_get())
        except AttributeError:
            continue

    if event == 'Clean output':
        window['-OUTPUT-'].update('')

#****************** Initializing and checking the variables of the spectra frame ******************

    #create a spectra list file
    if event == 'listfile':
        list_layout = [
        [sg.Text("Select the folder with the spectra:")],
        [sg.InputText(key='-FOLDER-'), sg.FolderBrowse()],
        [sg.Button('Save')],
        ]

        list_window = sg.Window('Generate spectra list', list_layout)

        while True:
            list_event, list_values = list_window.read()

            if list_event == sg.WINDOW_CLOSED:
                break
            elif list_event == 'Save':
                folder_path = list_values['-FOLDER-']
                if folder_path:
                    file_list = span.get_files_in_folder(folder_path)
                    output_file = 'spectra_list.txt'
                    span.save_to_text_file(file_list, output_file)
                    sg.Popup('Spectra file list saved in', output_file, 'You can now browse and load this list file')

        list_window.close()

    spectra_list = values['spec_list']
    spectra_list_name = os.path.splitext(os.path.basename(spectra_list))[0]

    #assigning lambda units of the spectra
    if (values['wave_units_nm'] == True):
        lambda_units = 'nm'
    if (values['wave_units_a'] == True):
        lambda_units = 'a'
    if (values['wave_units_mu'] == True):
        lambda_units = 'mu'

    if event == 'About SPAN':
        sg.popup ('SPAN is a Python 3.X 1D spectra analysis tool. It can modify the spectra and perform measurements, using both built-in and external (e.g. ppxf) algorithms')
    if event == 'Version':
        sg.popup ('This is version 5.0 with improved and semplified layout')

    # In the case I want to deselect all the active tasks in one click
    if event == 'Clear all tasks':
        print ('All tasks cleared')
        window ['show_hdr']. Update (value = False)
        window ['show_step']. Update (value = False)
        window ['show_res']. Update (value = False)
        window ['convert_spec']. Update (value = False)
        window ['compare_spec']. Update (value = False)
        window ['convert_flux']. Update (value = False)
        window ['show_snr']. Update (value = False)

        window ['cropping']. Update (value = False)
        window ['sigma_clip']. Update (value = False)
        window ['wavelet_cleaning']. Update (value = False)
        window ['dopcor']. Update (value = False)
        window ['helio_corr']. Update (value = False)

        window ['rebin']. Update (value = False)
        window ['degrade_resolution']. Update (value = False)
        window ['norm_spec']. Update (value = False)
        window ['cont_sub']. Update (value = False)
        window ['broadening_spec']. Update (value = False)
        window ['add_noise']. Update (value = False)
        window ['filter_denoise']. Update (value = False)
        window ['use_for_spec_an']. Update (value = False)
        window ['subtract_norm_avg']. Update (value = False)
        window ['subtract_norm_spec']. Update (value = False)
        window ['add_pedestal']. Update (value = False)
        window ['multiply']. Update (value = False)

        window ['bb_fitting']. Update (value = False)
        window ['xcorr']. Update (value = False)
        window ['sigma_measurement']. Update (value = False)
        window ['ew_measurement']. Update (value = False)
        window ['line_fitting']. Update (value = False)
        window ['ppxf_kin']. Update (value = False)
        window ['ppxf_pop']. Update (value = False)
        window ['sigma_coeff']. Update (value = False)
        window ['sigma_corr']. Update (value = False)

        window ['save_plots']. Update (value = False)

        #Radio value sepctra math to default
        window ['none']. Update (value = True)




#******************* Initializing and checking the variables of the utility frame *****************
    #1) show the header
    show_hdr = values['show_hdr']

    #2) show the sampling
    show_sample = values['show_step']

    #3) show resolution and check on the input values
    show_resolution = values['show_res']
    if show_resolution == True:
        try:
            res_wave1 = float(values['lambda_res_left'])
        except ValueError:
            sg.popup('Wave is not a number!')
            continue

        try:
            res_wave2 = float(values['lambda_res_right'])
        except ValueError:
            sg.popup('Wave is not a number!')
            continue
        if res_wave1 >= res_wave2:
            sg.popup('Wave1 must be SMALLER than Wave2')
            continue

    #4) convert to ASCII or FITS
    convert = values['convert_spec']
    convert_ascii = values['convert_to_txt']
    convert_fits = values['convert_to_fits']

    #5) compare the spectrum with another
    compare_spec = values['compare_spec']
    spec_compare_file = values['spec_to_compare']

    #6) convert the flux units
    convert_flux = values['convert_flux']
    convert_to_fnu = values['convert_to_fnu']
    convert_to_flambda = values['convert_to_fl']

    #7) show the snr and check on the input values
    show_snr = values['show_snr']
    if show_snr == True:
        try:
            snr_wave = float(values['wave_snr'])
        except ValueError:
            sg.popup('Wave interval is not a number!')
            continue

        try:
            epsilon_wave_snr = float(values['delta_wave_snr'])
        except ValueError:
            sg.popup('Epsilon wave is not a number!')
            continue




#********** Initializing and checking the variables of the Spectra pre-processing frame **********

    #1) CROPPING PARAMETERS
    cropping_spectrum = values['cropping']
    if cropping_spectrum == True:
        try:
            cropping_low_wave = float(values['cropping_low_wave'])
            cropping_high_wave = float(values['cropping_high_wave'])
        except:
            sg.popup ('Cropping parameters not valid')
            continue


    #2) DYNAMIC CLEANING PARAMETERS
    sigma_clipping = values['sigma_clip']
    if event  == ('Clean parameters'):

        sg.theme('LightBlue1')
        clean_layout = [
            [sg.Text('Sigma to clip:',tooltip='Clipping factor'), sg.InputText(clip_factor, size = (3,1), key = 'clip_factor'), sg.Text('Res. (R)',tooltip='Spectrum resolution'), sg.InputText(sigma_clip_resolution, size = (5,1), key = 'res_spec_for_sigma_clip'), sg.Radio('Velocity dispersion (km/s)', "RADIOCLIP", default = sigma_clip_single_vel, key = 'single_vel_clip', tooltip='Velocity dispersion'), sg.InputText(sigma_clip_single_value, size = (4,1), key = 'clip_to_vel')],
            [sg.Radio('R and sigma vel file', "RADIOCLIP", default = sigma_clip_have_file, key = 'file_for_clip',tooltip='ASCII file with R and sigma to perform sigma clipping for all the loaded spectra'), sg.InputText(sigma_clip_sigma_file, size=(14, 1), key = 'sigma_clip_file'), sg.FileBrowse(tooltip='Load an ASCII file containing: Name of the spectrum, Resolution (R), sigma (km/s), in the same order of the original spectra list')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Clean spectra window open. The main panel will be inactive until you close the window ***')
        clean_window = sg.Window('Clean spectra parameters', clean_layout)

        while True:
            clean_event, clean_values = clean_window.read()

            if clean_event == sg.WIN_CLOSED:
                break

            try:
                clip_factor = float(clean_values['clip_factor'])
                sigma_clip_single_value = float(clean_values['clip_to_vel'])
                sigma_clip_resolution = int(clean_values['res_spec_for_sigma_clip'])
                if clip_factor <=0:
                    sg.popup('Invalid sigma clip factor. Must be > 0!')
                    continue
            except ValueError:
                sg.popup('Sigma clip factor is not a number!')
                continue
                    #check values

            sigma_clip_single_vel = clean_values['single_vel_clip']
            sigma_clip_have_file = clean_values['file_for_clip']
            sigma_clip_sigma_file = clean_values['sigma_clip_file']

            if clean_event == 'Confirm':
                print ('Clean parameters confirmed. This main panel is now active again')
                print ('')
                break

        clean_window.close()

    #3) WAVELET PARAMETERS
    wavelet_cleaning = values['wavelet_cleaning']
    if wavelet_cleaning == True:

        try:
            sigma_wavelets = float(values['sigma_wavelets'])
            wavelets_layers = int(values['wavelets_layers'])
        except:
            sg.popup('Wavelet parameters not valid')
            continue
        if sigma_wavelets <= 0 or wavelets_layers <= 0:
            sg.Popup ('Wavelet parameters must be greater than zero!')
            continue
        if wavelets_layers > 20:
            sg.Popup ('Wavelet layers must be smaller than 20. Try again')
            continue



    #4) FILTERING AND DENOISINS PARAMETERS
    filter_denoise = values['filter_denoise']
    if event == 'Denoise parameters':

        sg.theme('LightBlue1')
        denoise_layout = [
        [sg.Checkbox('Moving average:', font = ('Helvetiva', 11, 'bold'), default = moving_average, key = 'moving_average'), sg.Radio('Simple box:', "MOVAVG", default = box_moving_avg, key = 'box_moving_avg', font = ('Helvetica', 11, 'bold')), sg.Text('Box size (pix):'), sg.InputText(box_moving_avg_size, key = 'box_moving_avg_size', size = (7,1)),sg.Radio('Gaussian kernel:', "MOVAVG", default = gauss_moving_avg, key = 'gauss_moving_avg'), sg.Text('Sigma kernel (pix):'), sg.InputText(gauss_moving_avg_kernel, key = 'gauss_moving_avg_kernel', size = (5,1))],

        [sg.HorizontalSeparator()],
        [sg.Checkbox('Low-pass filter (Butterworth)', font = ('Helvetiva', 11, 'bold'), default = low_pass_filter, key = 'low_pass_filter'), sg.Text('Cut-off:'), sg.InputText(lowpass_cut_off, key = 'lowpass_cut_off', size = (7,1)), sg.Text('Filter order:'), sg.InputText(lowpass_order, key = 'lowpass_order', size = (7,1))],
        [sg.Checkbox('Band-pass filter (Butterworth)', font = ('Helvetiva', 11, 'bold'), default = bandpass_filter, key = 'bandpass_filter'), sg.Text('lower Cut-off:'), sg.InputText(bandpass_lower_cut_off, key = 'bandpass_lower_cut_off', size = (7,1)), sg.Text('upper Cut-off:'), sg.InputText(bandpass_upper_cut_off, key = 'bandpass_upper_cut_off', size = (7,1)), sg.Text('Filter order:'), sg.InputText(bandpass_order, key = 'bandpass_order', size = (7,1))],
        [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
        ]

        print ('*** Denoise window open. The main panel will be inactive until you close the window ***')
        denoise_window = sg.Window('Denoise parameters', denoise_layout)

        while True:
            denoise_event, denoise_values = denoise_window.read()

            if denoise_event == sg.WIN_CLOSED:
                break

            moving_average = denoise_values['moving_average']
            box_moving_avg = denoise_values['box_moving_avg']
            gauss_moving_avg = denoise_values['gauss_moving_avg']
            low_pass_filter = denoise_values['low_pass_filter']
            bandpass_filter = denoise_values['bandpass_filter']

            try:
                if moving_average ==True and box_moving_avg == True:
                    box_moving_avg_size = int(denoise_values['box_moving_avg_size'])
                if moving_average == True and gauss_moving_avg == True:
                    gauss_moving_avg_kernel = float(denoise_values['gauss_moving_avg_kernel'])
                    if gauss_moving_avg_kernel <= 0 or gauss_moving_avg_kernel > 1000:
                        sg.Popup('Gauss kernel must be greater than zero and smaller than 1000')
                        gauss_moving_avg_kernel = 5
                        continue

                if low_pass_filter == True:
                    lowpass_cut_off = float(denoise_values['lowpass_cut_off'])
                    if lowpass_cut_off <=0 or lowpass_cut_off >= 1:
                        sg.Popup ('Low-pass cut-off must be greater than 0 and smaller than 1')
                        lowpass_cut_off = 0.1
                        continue
                    lowpass_order = int(denoise_values['lowpass_order'])
                    if lowpass_order <=0 or lowpass_order >30:
                        sg.Popup ('Filter order must be between 1 and 30')
                        lowpass_order = 4
                        continue
                if bandpass_filter == True:
                    bandpass_lower_cut_off = float(denoise_values['bandpass_lower_cut_off'])
                    bandpass_upper_cut_off = float(denoise_values['bandpass_upper_cut_off'])
                    if bandpass_lower_cut_off >= bandpass_upper_cut_off:
                        sg.Popup ('Lower cut-off must be greater than lower cut-off')
                        bandpass_lower_cut_off = 0.1
                        bandpass_upper_cut_off = 0.5
                        continue
                    if bandpass_lower_cut_off <=0 or bandpass_lower_cut_off >= 1 or bandpass_upper_cut_off <=0 or bandpass_upper_cut_off >= 1:
                        sg.Popup('Bandpass cut-offs must be greater than 0 and smaller than 1')
                        bandpass_lower_cut_off = 0.1
                        bandpass_upper_cut_off = 0.5
                        continue
                    bandpass_order = int(denoise_values['bandpass_order'])
                    if bandpass_order <=0 or bandpass_order >30:
                        sg.Popup ('Bandpass filter order must be between 1 and 30')
                        bandpass_order = 4
                        continue
            except:
                sg.Popup ('Parameters not valid!')
                box_moving_avg_size = 11
                gauss_moving_avg_kernel = 5
                lowpass_cut_off = 0.1
                lowpass_order = 4
                continue


            if denoise_event == 'Confirm':
                print ('Denoise parameters confirmed. This main panel is now active again')
                print ('')
                break

        denoise_window.close()



    #5) DOPPLER CORRECTION PARAMETERS
    dop_cor = values['dopcor']

    if event  == ('Dopcor parameters'):

        sg.theme('LightBlue1')
        dopcor_layout = [

             [sg.Radio ('I have a file', "RADIODOP", default = dop_cor_have_file, key = 'file_for_dopcor'), sg.InputText(dop_cor_file, size=(14, 1), key = 'dopcor_file'), sg.FileBrowse(tooltip='Load an ASCII file containing: Name of the spectrum, radial velocity to correct (km/s), in the same order of the original spectra list')],
            [sg.Radio('Single shot', "RADIODOP", default = dop_cor_single_shot, key ='dopcor_single_value'), sg.Text('Rec vel (km/s)'), sg.InputText(dop_cor_single_shot_vel, size = (8,1), key = 'dopcor_value')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Dopcor parameters window open. The main panel will be inactive until you close the window ***')
        dopcor_window = sg.Window('Dopcor parameters', dopcor_layout)

        while True:
            dopcor_event, dopcor_values = dopcor_window.read()

            if dopcor_event == sg.WIN_CLOSED:
                break

            dop_cor_have_file = dopcor_values['file_for_dopcor']
            dop_cor_file = dopcor_values['dopcor_file']
            dop_cor_single_shot = dopcor_values['dopcor_single_value']

            try:
                dop_cor_single_shot_vel = float(dopcor_values['dopcor_value'])
            except ValueError:
                sg.popup('Dopcor value is not a number!')
                continue

            if dopcor_event == 'Confirm':
                print ('Dopcor parameters confirmed. This main panel is now active again')
                print ('')
                break

        dopcor_window.close()


    #6) HELIOCENTRIC CORRECTION PARAMETERS
    helio_corr = values['helio_corr']
    if event  == ('Heliocor parameters'):

        sg.theme('LightBlue1')
        heliocor_layout = [

             [sg.Radio ('I have a file with location, date, RA and Dec. for all the spectra:', "RADIOHEL", default = helio_have_file, key = 'file_for_helio'), sg.InputText(helio_file, size = (37,1), key = 'helio_file'), sg.FileBrowse(tooltip='Load an ASCII file containing: Location, Date (YYYY-MM-DD), RA, Dec.')],
            [sg.Radio('Single correction', "RADIOHEL", default = helio_single_shot, key = 'helio_single_value'), sg.Text('Location:'), sg.InputText(helio_single_shot_location, size = (11,1), key = 'helio_location'), sg.Text('Date:'), sg.InputText(helio_single_shot_date, size = (10,1), key = 'helio_date'), sg.Text('RA:'), sg.InputText(ra_obj, size = (10,1), key = 'helio_ra'), sg.Text('Dec.:'), sg.InputText(dec_obj, size = (10,1), key = 'helio_dec'), sg.Button('loc.list',button_color=('black','light blue'),tooltip='Click to see the pre-loaded location list for heliocentric correction')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Heliocor parameters window open. The main panel will be inactive until you close the window ***')
        heliocor_window = sg.Window('Heliocor parameters', heliocor_layout)

        while True:
            heliocor_event, heliocor_values = heliocor_window.read()

            if heliocor_event == sg.WIN_CLOSED:
                break

            helio_have_file = heliocor_values['file_for_helio']
            helio_file = heliocor_values['helio_file']
            helio_single_shot = heliocor_values['helio_single_value']
            helio_single_shot_location = heliocor_values['helio_location']
            helio_single_shot_date = heliocor_values['helio_date']
            if helio_corr == True and helio_single_shot == True:
                try:
                    ra_obj = float(heliocor_values['helio_ra'])
                    dec_obj = float(heliocor_values['helio_dec'])
                except Exception:
                    sg.popup('Coordinates not valid!')
                    continue
                try:
                    datetime.datetime.strptime(helio_single_shot_date, '%Y-%m-%d')
                except Exception:
                    sg.popup ('Date format not valid. It must be: YYYY-MM-DD')
                    continue
                try:
                    location = EarthLocation.of_site(helio_single_shot_location)
                except Exception:
                    sg.popup ('Location not in the list')
                    continue
    #activating the button location list
            if(heliocor_event == 'loc.list'):
                try:
                    location_list = EarthLocation.get_site_names()
                    sg.popup_scrolled(location_list, size=(100, 40))
                except Exception:
                    sg.popup('Location list not available. I need an internet connection')

            if heliocor_event == 'Confirm':
                print ('Heliocor parameters confirmed. This main panel is now active again')
                print ('')
                break

        heliocor_window.close()


#************ Initializing and checking the variables of the Spectra processing frame ***********

    #1) REBINNING PARAMETERS
    rebinning = values['rebin']

    #a) linear rebinning
    rebinning_linear = values['rebin_pix_lin']
    if rebinning == True and rebinning_linear == True:
        try:
            usr_step_linear = float(values['rebin_step_pix'])
            if usr_step_linear <=0:
                sg.popup('Invalid step. Must be > 0!')
                continue
        except ValueError:
            sg.popup('Step is not a number!')
            continue

    #b) log rebinning
    rebinning_log = values['rebin_sigma_lin']
    if rebinning == True and rebinning_log == True:
        try:
            usr_step_log = float(values['rebin_step_sigma'])
            if usr_step_log <0:
                sg.popup('Invalid step. Must be >= 0!')
                continue
        except ValueError:
            sg.popup('Step is not a number!')
            continue


    #2) DEGRADE RESOLUTION PARAMETERS
    degrade = values['degrade_resolution']
    if event  == ('Degrade parameters'):

        sg.theme('LightBlue1')
        degrade_res_layout = [
            [sg.Radio('From R:', "RADIORESR", default = is_initial_res_r, key = 'is_initial_res_r', font = ('Helvetica', 12, 'bold') ), sg.InputText(initial_res_r, size = (6,1), key = 'degrade_from_r'), sg.Radio('to R:', "RADIORESRTOR", default = res_degrade_to_r, key = 'res_degrade_to_r' ), sg.InputText(final_res_r, size = (6,1), key = 'degrade_to_r'), sg.Radio('to FWHM (A):', "RADIORESRTOR", default = res_degrade_to_fwhm, key = 'res_degrade_to_fwhm'), sg.InputText(final_res_r_to_fwhm, size = (6,1), key = 'final_res_r_to_fwhm')],
            [sg.HorizontalSeparator()],
            [sg.Radio('From FWHM (A):', "RADIORESR", default = is_initial_res_fwhm, key = 'is_initial_res_fwhm', font = ('Helvetica', 12, 'bold')), sg.InputText(initial_res_fwhm, size = (4,1), key = 'degrade_from_l'), sg.Text('to FWHM (A):'), sg.InputText(final_res_fwhm, size = (4,1), key = 'degrade_to_l')],

            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Degrade resolution parameters window open. The main panel will be inactive until you close the window ***')
        degrade_res_window = sg.Window('Degrade resolution parameters', degrade_res_layout)

        while True:
            degrade_res_event, degrade_res_values = degrade_res_window.read()

            if degrade_res_event == sg.WIN_CLOSED:
                break

            try:
                is_initial_res_r = degrade_res_values['is_initial_res_r']
                initial_res_r = int(degrade_res_values['degrade_from_r'])
                res_degrade_to_r = degrade_res_values['res_degrade_to_r']
                final_res_r = int(degrade_res_values['degrade_to_r'])
                res_degrade_to_fwhm = degrade_res_values['res_degrade_to_fwhm']
                final_res_r_to_fwhm = float(degrade_res_values['final_res_r_to_fwhm'])

                is_initial_res_fwhm = degrade_res_values['is_initial_res_fwhm']
                initial_res_fwhm = float(degrade_res_values['degrade_from_l'])
                final_res_fwhm = float(degrade_res_values['degrade_to_l'])
            except Exception:
                sg.Popup('Degrade resolution parameters not valid')
                continue

            if initial_res_r <=0 or final_res_r <=0 or final_res_r_to_fwhm <=0 or initial_res_fwhm <=0 or final_res_fwhm <=0:
                sg.Popup ('Resolution values cannot be negative or zero!')
                continue

            if final_res_fwhm < initial_res_fwhm or initial_res_r<final_res_r:
                sg.popup('You want to improve the resolution? That''s impossible!')
                continue

            if degrade_res_event == 'Confirm':
                print ('Degrade resolution parameters confirmed. This main panel is now active again')
                print ('')
                break

        degrade_res_window.close()


    #3) NORMALISATION PARAMETERS
    normalize_wave = values['norm_spec']
    if normalize_wave == True:
        try:
            norm_lambda = float(values['norm_wave'])
        except ValueError:
            sg.popup('Normalisation wave not valid!')
            continue


    #4) SIGMA BROADENING PARAMETERS
    sigma_broad = values['broadening_spec']
    if sigma_broad == True:
        try:
            sigma_value = float(values['sigma_to_add'])
            if sigma_value < 0:
                sg.popup('Invalid sigma broadening. Must be >= 0!')
                continue
        except ValueError:
            sg.popup('Sigma broadening not valid!')
            continue

    #5) ADD NOISE PARAMETERS
    add_noise = values['add_noise']
    if add_noise == True:
        try:
            noise = float(values['noise_to_add'])
            if noise <=0:
                sg.popup('Invalid SNR. Must be > 0!')
                continue
        except ValueError:
            sg.popup('Noise value not valid!')
            continue


    #6) CONTINUUM MODELLING PARAMETERS
    continuum_sub = values['cont_sub']
    if event == 'Continuum parameters':
        sg.theme('LightBlue1')
        continuum_layout = [
        [sg.Radio('Continuum model: automatic filtering of the spectrum (works good for smooth spectrum and no emission)', "CONTMODE", default = cont_model_filtering, key = 'cont_model_filtering', font = ('Helvetica', 11, 'bold'))],
        [sg.HorizontalSeparator()],
        [sg.Radio('Continuum model: fine-tuning polynomial fitting', "CONTMODE", default = cont_model_poly, key = 'cont_model_poly',font = ('Helvetica', 11, 'bold')), sg.Checkbox('Regions to mask:', default = cont_want_to_maks, key = 'cont_want_to_maks'), sg.InputText(cont_mask_ranges_str, size = (14,1), key = 'cont_mask_ranges'), sg.Text('Polynomial degree:'), sg.InputText(cont_poly_degree, size = (6,1), key = 'cont_poly_degree')],
        [sg.HorizontalSeparator()],
        [sg.Text('Operation on the spectrum:'), sg.InputCombo(markers_cont_operations, key='markers_cont_operations', default_value=cont_math_operation, readonly=True)],
        [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
        ]

        print ('*** Continuum subtraction window open. The main panel will be inactive until you close the window ***')
        continuum_window = sg.Window('Continuum parameters', continuum_layout)

        while True:
            continuum_event, continuum_values = continuum_window.read()

            if continuum_event == sg.WIN_CLOSED:
                break

            cont_model_filtering = continuum_values['cont_model_filtering']
            cont_model_poly = continuum_values['cont_model_poly']
            cont_math_operation = continuum_values['markers_cont_operations']
            #print (cont_math_operation)
            if cont_model_poly == True:

                cont_want_to_maks = continuum_values['cont_want_to_maks']
                if cont_want_to_maks == True:
                    try:
                        cont_mask_ranges_str = continuum_values['cont_mask_ranges']
                        cont_mask_ranges = eval(cont_mask_ranges_str)
                    except:
                        sg.Popup('Masking values not valid')
                        continue
                try:
                    cont_poly_degree = int(continuum_values['cont_poly_degree'])
                except:
                    sg.Popup ('Polynomial degree not valid')
                    continue
                if cont_poly_degree <0 or cont_poly_degree > 11:
                    sg.Popup('Polynomial degree must be between 0 and 11')
                    cont_poly_degree = 5
                    continue


            if continuum_event == 'Confirm':
                print ('Continuum parameters confirmed. This main panel is now active again')
                print ('')
                break

        continuum_window.close()





#***************** Initializing and checking the variables of the Spec math frame ****************
    #1) average all
    average_all = values['avg_all']

    #2) normalize and average all
    norm_and_average = values['norm_avg_all']

    #3) do nothing if you don't want to perform math operations
    do_nothing = values['none']

    #4) sum all
    sum_all = values['sum_all']

    #5) normalize and sum all
    normalize_and_sum_all = values['norm_sum_all']

    #6) use for spectral analysis the resulting averaged or summed spectrum
    use_for_spec_an = values['use_for_spec_an']

    #7) subratc normalized average to the selected spectrum
    subtract_normalized_avg = values['subtract_norm_avg']

    #8) subtract normalized average to the selected and normalized spectrum
    subtract_normalized_spec = values['subtract_norm_spec']
    spectra_to_subtract = values['spec_to_sobtract']

    #9) add pedestal and check on the input values
    add_pedestal = values['add_pedestal']
    if add_pedestal == True:
        try:
            constant_pedestal = float(values['pedestal_to_add'])
        except ValueError:
            sg.popup('Pedestal value not valid!')
            continue

    #10) multiply by a constant and check on the input values
    multiply = values['multiply']
    if multiply == True:
        try:
            multiply_constant = float(values['multiply_factor'])
            if multiply_constant <=0:
                sg.popup('Invalid multiply constant. Must be > 0!')
                continue
        except ValueError:
            sg.popup('Multiply value not valid!')
            continue






#*********************************************************************************************************************
#*********************************************************************************************************************
#*********************************************************************************************************************
#*************************************** SUB WINDOWS DEFINITION AND PARAMETERS ***************************************

    #1) BLACKBODY PARAMETERS
    bb_fit = values['bb_fitting']
    if (event == 'Blackbody parameters'):
        sg.theme('LightBlue1')
        bb_layout = [
        [sg.Text('Wave interval (nm):'), sg.InputText(wave1_bb, size = (6,1), key = 'left_wave_bb'), sg.Text('-'), sg.InputText(wave2_bb, size = (6,1), key = 'right_wave_bb'), sg.Text('Initial Temperature guess'), sg.InputText(t_guess, size = (8,1), key = 't_guess_bb')],
        [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
        ]

        print ('*** Blackbody fitting parameters window open. The main panel will be inactive until you close the window ***')
        bb_window = sg.Window('Blackbody fitting parameters', bb_layout)

        while True:
            bb_event, bb_values = bb_window.read()

            if bb_event == sg.WIN_CLOSED:
                break

            try:
                wave1_bb = float(bb_values['left_wave_bb'])
                wave2_bb = float(bb_values['right_wave_bb'])
                t_guess = float(bb_values['t_guess_bb'])

            except Exception:
                sg.popup ('Invalid input parameters!')
                continue
            if t_guess <=0:
                sg.Popup ('No blackbody has a negative temperature!')
                t_guess = 4000.
                continue
            if t_guess > 1e7:
                sg.Popup ('No blackbody has a temperature greater than 10 million degrees!')
                t_guess = 4000.
                continue

            if wave1_bb >= wave2_bb:
                sg.popup ('The first wavelength cannot be greater than the second!')
                continue

            epsilon_wave_check = 5.
            if wave2_bb - wave1_bb <= epsilon_wave_check:
                sg.popup ('The wavelength interval is too small to perform a good fit. Enlarge it!')
                continue

            if bb_event == 'Confirm':
                print ('Blackbody parameters confirmed. This main panel is now active again')
                print ('')
                break

        bb_window.close()



    #2) CROSS-CORRELATION PARAMETERS
    cross_corr = values['xcorr']
    if (event == 'Xcorr parameters'):
        sg.theme('LightBlue1')
        xcorr_layout = [
        [sg.Text('Select a template:'), sg.InputText(template_crosscorr, size = (15,1), key = 'xcorr_template'), sg.FileBrowse(tooltip='Load a template'), sg.Text('Template wavelegth is in:'),sg.Radio ('nm', "RADIOCORR", default = lambda_units_template_crosscorr_nm, key = 'xcorr_template_wave_nm'), sg.Radio('a', "RADIOCORR", default = lambda_units_template_crosscorr_a, key = 'xcorr_template_wave_a'), sg.Radio('mu', "RADIOCORR", key = 'xcorr_template_wave_mu', default = lambda_units_template_crosscorr_mu), sg.Checkbox('Add broadening to template (km/s):', key = 'xcorr_smooth_template',tooltip='Add a sigma broadeing to the template (km/s)', default = smooth_template_crosscorr), sg.InputText(smooth_value_crosscorr, size = (4,1), key = 'xcorr_smooth_template_value'), sg.Text(' '), sg.Button('View template',button_color=('black','light blue'))],
        [sg.HorizontalSeparator()],
        [sg.Radio('Wavelength interval to cross-correlate (nm):', "RADIOONLY", default = limit_range_corr, key = 'xcorr_wave_range',tooltip='Wavelength range to cross-correlate in nm'), sg.InputText(low_wave_corr, size = (6,1), key = 'xcorr_left_lambda'), sg.Text('-'), sg.InputText(high_wave_corr, size = (6,1), key = 'xcorr_right_lambda'), sg.Radio('Velocity range allowed (km/s):', "RADIOONLY2", default = vel_range_corr, key = 'xcorr_vel_range',tooltip='Velocity range, in km/s'), sg.InputText(low_vel_corr, size = (7,1), key = 'xcorr_low_vel'), sg.Text('-'), sg.InputText(high_vel_corr, size = (7,1), key = 'xcorr_high_vel')],
        [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
        ]

        print ('*** Xcorr parameters window open. The main panel will be inactive until you close the window ***')
        xcorr_window = sg.Window('Cross-correlation parameters', xcorr_layout)

        while True:
            xcorr_event, xcorr_values = xcorr_window.read()

            if xcorr_event == sg.WIN_CLOSED:
                break

            lambda_units_template_crosscorr_nm = xcorr_values['xcorr_template_wave_nm']
            lambda_units_template_crosscorr_a = xcorr_values['xcorr_template_wave_a']
            lambda_units_template_crosscorr_mu = xcorr_values['xcorr_template_wave_mu']
            template_crosscorr = xcorr_values['xcorr_template']
            if (lambda_units_template_crosscorr_nm == True):
                lambda_units_template_crosscorr = 'nm'
            if (lambda_units_template_crosscorr_a== True):
                lambda_units_template_crosscorr = 'a'
            if (lambda_units_template_crosscorr_mu == True):
                lambda_units_template_crosscorr = 'mu'
            smooth_template_crosscorr = xcorr_values['xcorr_smooth_template']
            if smooth_template_crosscorr == True:
                try:
                    smooth_value_crosscorr = float(xcorr_values['xcorr_smooth_template_value'])
                    if smooth_value_crosscorr <0:
                        sg.popup('Invalid smooth value for template. Must be >= 0!')
                        continue
                except ValueError:
                    sg.popup('Smooth template value not valid!')
                    continue
            else:
                smooth_value_crosscorr = 0
            limit_range_corr = xcorr_values['xcorr_wave_range']
            if limit_range_corr == True:
                try:
                    low_wave_corr = float(xcorr_values['xcorr_left_lambda'])
                    high_wave_corr = float(xcorr_values['xcorr_right_lambda'])
                    wave_interval_corr = np.array([low_wave_corr,high_wave_corr])
                except Exception:
                    sg.popup('Limit wave values not valid!')
                    continue
                real_low_wave_corr = np.min(wave_interval_corr)
                real_high_wave_corr = np.max(wave_interval_corr)

            vel_range_corr = xcorr_values['xcorr_vel_range']

            #existence of correct values of velocity range
            if vel_range_corr == True:
                try:
                    low_vel_corr = float(xcorr_values['xcorr_low_vel'])
                    high_vel_corr = float(xcorr_values['xcorr_high_vel'])
                    vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                    low_vel_corr = np.min(vel_interval_corr)
                    high_vel_corr = np.max(vel_interval_corr)
                except Exception:
                    sg.popup('Limit velocity values not valid!')
                    low_vel_corr = -1000
                    high_vel_corr = 1000
                    vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                    continue
                epsilon_vel = 10
                if abs(low_vel_corr - high_vel_corr)<epsilon_vel:
                    sg.Popup('Velocity interval too small')
                    low_vel_corr = -1000
                    high_vel_corr = 1000
                    vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                    continue

            if xcorr_event == 'View template':
                cond01 = (os.path.isfile(template_crosscorr))
                if cond01 == False:
                    sg.popup('The template does not exist. I have nothing to show!')
                    continue

                wave_template1, flux_template1, step_temp1, name_temp1 = span.read_spec(template_crosscorr, lambda_units_template_crosscorr)

                #doing the broadening, if selected. Fix it: for now only if it's greater than zero but you should also consider the relative Checkbox, here and somewhere else!
                if smooth_value_crosscorr > 0:
                    flux_template1 = span.sigma_broad(wave_template1, flux_template1, smooth_value_crosscorr)
                plt.title(template_crosscorr)
                plt.plot(wave_template1, flux_template1)
                plt.xlim(real_low_wave_corr,wave_interval_corr[len(wave_interval_corr)-1])
                plt.xlabel('Wavelength (nm)')
                plt.ylabel('Norm flux')
                plt.show()

            #CLOSING THE WINDOW ONCE I CLICK "CONFIRM"
            if xcorr_event == 'Confirm':
                print ('Xcorr parameters confirmed. This main panel is now active again')
                print ('')
                break

        xcorr_window.close()



    # 3) VELOCITY DISPERSION PARAMETERS
    sigma_measurement = values['sigma_measurement']
    if (event == 'Sigma parameters'):
        sg.theme('LightBlue1')
        sigma_layout = [
            [sg.Text('Select a template:'), sg.InputText(template_sigma, size = (18,1), key = 'sigma_template'), sg.FileBrowse(tooltip='Load a template'), sg.Text('Template wavelegth is in:'), sg.Radio ('nm', "RADIOSIGMA", default = lambda_units_template_sigma_nm, key = 'sigma_template_wave_nm'), sg.Radio('a', "RADIOSIGMA", default = lambda_units_template_sigma_a, key = 'sigma_template_wave_a'), sg.Radio('mu', "RADIOSIGMA", default = lambda_units_template_sigma_mu, key = 'sigma_template_wave_mu'), sg.Text('Resolution template (0 if (E)MILES)'), sg.InputText(resolution_template, size = (5,1), key = 'sigma_res_template'), sg.Push(), sg.Button('View template',button_color=('black','light blue'))],
            [sg.HorizontalSeparator()],
            [sg.Text('Pre-loaded bands to fit for sigma:'), sg.Radio('CaT', "RADIOBAND", default = band_cat, key = 'sigma_band_cat'), sg.Radio('Ha', "RADIOBAND", default = band_halpha, key = 'sigma_band_ha'), sg.Radio('Nad', "RADIOBAND", default = band_nad, key = 'sigma_band_nad'), sg.Radio('H band', "RADIOBAND", default = band_h, key = 'sigma_band_h'), sg.Radio('K band', "RADIOBAND", default = band_k, key = 'sigma_band_k'), sg.Radio('Custom band', "RADIOBAND", default = band_custom, key = 'sigma_custom_band'), sg.Text('Wave interval (nm)'), sg.InputText(low_wave_sigma, size = (5,1), key = 'sigma_left_lambda'), sg.Text('-'), sg.InputText(high_wave_sigma, size = (5,1), key = 'sigma_right_lambda'), sg.Text('Cont. interval'), sg.InputText(low_wave_cont, size = (5,1), key = 'sigma_cont_left_lambda'), sg.Text('-'), sg.InputText(high_wave_cont, size = (5,1), key = 'sigma_cont_right_lambda')],
            [sg.HorizontalSeparator()],
            [sg.Text('Resolution spectrum (R)'), sg.InputText(resolution_spec, size=(5,1), key = 'sigma_spec_res')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Sigma parameters window open. The main panel will be inactive until you close the window ***')
        sigma_window = sg.Window('Sigma parameters', sigma_layout)

        while True:
            sigma_event, sigma_values = sigma_window.read()

            if sigma_event == sg.WIN_CLOSED:
                break

            lambda_units_template_sigma_nm = sigma_values['sigma_template_wave_nm']
            lambda_units_template_sigma_a = sigma_values['sigma_template_wave_a']
            lambda_units_template_sigma_mu = sigma_values['sigma_template_wave_mu']

            template_sigma = sigma_values['sigma_template']

            #assigning lambda units of the template spectra
            if (lambda_units_template_sigma_nm == True):
                lambda_units_template_sigma = 'nm'
            if (lambda_units_template_sigma_a == True):
                lambda_units_template_sigma = 'a'
            if (lambda_units_template_sigma_mu == True):
                lambda_units_template_sigma = 'mu'

            #preloaded bands
            band_cat = sigma_values['sigma_band_cat']
            band_halpha = sigma_values['sigma_band_ha']
            band_nad = sigma_values['sigma_band_nad']
            band_h = sigma_values['sigma_band_h']
            band_k = sigma_values['sigma_band_k']

    #************* Define the preloaded bands for the velocity dispersion measurement ********

            if band_cat == True:
                band_sigma = np.array([844., 872.])
                cont_sigma = np.array([856.,864.])

            if band_halpha == True:
                band_sigma = np.array([642.,661])
                cont_sigma = np.array([651., 654.])

            if band_nad == True:
                band_sigma = np.array([560., 615.])
                cont_sigma = np.array([591., 597.])

            if band_h == True:
                band_sigma = np.array([1660., 1720.]) #test this band
                cont_sigma = np.array([1693., 1704.])

            if band_k == True:
                band_sigma = np.array([2270., 2370.]) #np.array([2250., 2330.]) #test this band
                cont_sigma = np.array([2270., 2280.])


            if sigma_measurement == True:
                try:
                    resolution_spec = float(sigma_values['sigma_spec_res'])
                    resolution_template = float(sigma_values['sigma_res_template'])
                    if resolution_spec <=0 or resolution_template < 0:
                        sg.popup('Invalid resolution values for the spectrum or the template')
                        continue
                except ValueError:
                    sg.popup('Resolution values for sigma not valid!')
                    continue

            band_custom = sigma_values['sigma_custom_band']
            if sigma_measurement == True and band_custom == True:
                try:
                    low_wave_sigma = float(sigma_values['sigma_left_lambda'])
                    high_wave_sigma = float(sigma_values['sigma_right_lambda'])
                    low_wave_cont = float(sigma_values['sigma_cont_left_lambda'])
                    high_wave_cont = float(sigma_values['sigma_cont_right_lambda'])

                    if band_custom == True:
                        band_sigma = np.array([low_wave_sigma, high_wave_sigma])
                        cont_sigma = np.array([low_wave_cont, high_wave_cont])
                except ValueError:
                    sg.popup('Band values for sigma not valid!')
                    continue

            if sigma_event == 'View template':

                #test if file file exist
                cond02 = (os.path.isfile(template_sigma))
                if cond02 == False:
                    sg.popup('The template does not exist. I have nothing to show!')
                    continue

                wave_template2, flux_template2, step_temp2, name_temp2 = span.read_spec(template_sigma, lambda_units_template_sigma)
                plt.title(template_sigma)
                plt.plot(wave_template2, flux_template2)
                plt.xlim(band_sigma[0],band_sigma[1])
                plt.xlabel('Wavelength (nm)')
                plt.ylabel('Norm flux')
                plt.show()


            #CLOSING THE WINDOW ONCE I CLICK "CONFIRM"
            if sigma_event == 'Confirm':
                print ('Sigma parameters confirmed. This main panel is now active again')
                print ('')
                break

        sigma_window.close()



    #4) EQUIVALENT WIDTH PARAMETERS
    ew_measurement = values['ew_measurement']

    if (event == 'Equivalent width parameters'):
        sg.theme('LightBlue1')
        ew_layout = [
            [sg.Radio('User indices on a list file:', "RADIOEW", default = have_index_file, key = 'ew_idx_file',  font = ('Helvetica', 12, 'bold')), sg.InputText(index_file, size = (48,1), key = 'idx_file'), sg.FileBrowse(size = (10,1))],
            [sg.HorizontalSeparator()],
            [sg.Radio('Single index', "RADIOEW", default = single_index, key = 'ew_single_idx',font = ('Helvetica', 12, 'bold')), sg.Text('blue cont.:'), sg.InputText(idx_left_blue, size = (5,1), key = 'left_wave_blue_cont'), sg.Text('-'), sg.InputText(idx_right_blue, size = (5,1), key = 'right_wave_blue_cont'), sg.Text('red cont.:'), sg.InputText(idx_left_red, size = (5,1), key = 'left_wave_red_cont'), sg.Text('-'),  sg.InputText(idx_right_red, size = (5,1), key = 'right_wave_red_cont'), sg.Text('line:'), sg.InputText(idx_left_line, size = (5,1), key = 'left_line'), sg.Text('-'), sg.InputText(idx_right_line, size = (5,1), key = 'right_line')],
            [sg.HorizontalSeparator()],
            [sg.Radio('Lick/IDS indices:', "RADIOEW", default = lick_ew, key = 'ew_lick', font = ('Helvetica', 12, 'bold')), sg.Radio('Constant resolution FWHM:', "RADIOLICKRES", default = lick_constant_fwhm, key ='lick_constant_fwhm'), sg.InputText(spec_lick_res_fwhm, key = 'spec_lick_res_fwhm',size = (7,1)), sg.Radio('Constant resolution R:', "RADIOLICKRES", default = lick_constant_r, key ='lick_constant_r'), sg.InputText(spec_lick_res_r, key = 'spec_lick_res_r',size = (8,1))],
            [sg.Text(' '), sg.Checkbox('Emission line(s) correction:', default = lick_correct_emission, key = 'lick_correct_emission'), sg.Text('Redshift guess'), sg.InputText(z_guess_lick_emission, key = 'z_guess_lick_emission', size = (15,1)), sg.Text(' '), sg.Checkbox('Perform Doppler correction', default = dop_correction_lick, key = 'dop_correction_lick')],
            [sg.Text(' '), sg.Checkbox('Correct for sigma:', default = correct_ew_sigma, key = 'correct_ew_sigma'), sg.Radio('Auto', "RADIOLICKSIGMA", default = radio_lick_sigma_auto, key = 'radio_lick_sigma_auto'), sg.Radio('Single (km/s):', "RADIOLICKSIGMA", default = radio_lick_sigma_single, key = 'radio_lick_sigma_single'), sg.InputText(sigma_single_lick, size = (5,1), key = 'sigma_single_lick'), sg.Radio('List:', "RADIOLICKSIGMA", default = radio_lick_sigma_list, key = 'radio_lick_sigma_list'), sg.InputText(sigma_lick_file, key = 'sigma_lick_file', size = (17,1)), sg.FileBrowse(size = (10,1)) ],
            [sg.Text(' '), sg.Checkbox('Estimate stellar parameters with SSP (Thomas 2010)', default = stellar_parameters_lick, key = 'stellar_parameters_lick')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Equivalent width parameters window open. The main panel will be inactive until you close the window ***')
        ew_window = sg.Window('EW parameters', ew_layout)

        while True:
            ew_event, ew_values = ew_window.read()

            if ew_event == sg.WIN_CLOSED:
                break

            index_file = ew_values['idx_file']

            have_index_file = ew_values['ew_idx_file']
            index_file = ew_values['idx_file']
            single_index = ew_values['ew_single_idx']

            lick_ew = ew_values['ew_lick']
            lick_constant_fwhm = ew_values['lick_constant_fwhm']
            lick_constant_r = ew_values['lick_constant_r']

            lick_correct_emission = ew_values['lick_correct_emission']
            radio_lick_sigma_single = ew_values['radio_lick_sigma_single']
            radio_lick_sigma_list = ew_values['radio_lick_sigma_list']
            radio_lick_sigma_auto = ew_values['radio_lick_sigma_auto']
            sigma_lick_file = ew_values['sigma_lick_file']
            correct_ew_sigma = ew_values['correct_ew_sigma']
            stellar_parameters_lick = ew_values['stellar_parameters_lick']
            dop_correction_lick = ew_values['dop_correction_lick']

            try:
                idx_left_blue = float(ew_values['left_wave_blue_cont'])
                idx_right_blue = float(ew_values['right_wave_blue_cont'])
                idx_left_red = float(ew_values['left_wave_red_cont'])
                idx_right_red = float(ew_values['right_wave_red_cont'])
                idx_left_line = float(ew_values['left_line'])
                idx_right_line = float(ew_values['right_line'])
                spec_lick_res_fwhm = float(ew_values['spec_lick_res_fwhm'])
                spec_lick_res_r = float(ew_values['spec_lick_res_r'])
                sigma_single_lick = float(ew_values['sigma_single_lick'])
                z_guess_lick_emission = float(ew_values['z_guess_lick_emission'])

                #building the index
                index_usr = np.array([idx_left_blue, idx_right_blue, idx_left_red, idx_right_red, idx_left_line, idx_right_line]).T #e' il trasposto, credo!
            except ValueError:
                sg.popup('Index values for EW measurement not valid!')
                continue

            if lick_constant_fwhm == True and (spec_lick_res_fwhm < 0):
                sg.popup ('FWHM resolution must be positive!')
                continue

            if lick_constant_r == True and (spec_lick_res_r < 0):
                sg.popup ('R resolution must be positive!')
                continue

            if correct_ew_sigma == True and radio_lick_sigma_single == True and sigma_single_lick < 0:
                sg.popup ('Sigma value must be positive!')
                continue

            #Check if the sigma file exist
            if correct_ew_sigma == True and radio_lick_sigma_list == True:

                #test if file file exist
                cond0000 = (os.path.isfile(sigma_lick_file))
                if cond0000 == False:
                    sg.popup('The sigma list file does not exist. Skipping...')
                    continue

            #CLOSING THE WINDOW ONCE I CLICK "CONFIRM"
            if ew_event == 'Confirm':
                print ('Equivalent width parameters confirmed. This main panel is now active again')
                print ('')
                break

        ew_window.close()



    #5) LINE(S) FITTING PARAMETERS
    line_fitting = values['line_fitting']

    if (event == 'Line fitting parameters'):
        sg.theme('LightBlue1')
        linefit_layout = [
            [sg.Radio('Automatic fit of the CaT lines', "RADIOFILEFIT", key = 'cat_fit', default = cat_band_fit,tooltip='Automatic CaT band fitting with three gaussian functions and a line')],
            [sg.Radio('Manual fit of the following line:', "RADIOFILEFIT", default = usr_fit_line, key = 'line_fit_single',tooltip='Fitting of user defined line with the parameters on the right'),sg.Checkbox('Emission', default = emission_line, key = 'emission_line'), sg.Text('Wave:'), sg.InputText(low_wave_fit, size = (4,1), key = 'left_wave_fitting'), sg.Text('-'), sg.InputText(high_wave_fit, size = (4,1), key = 'right_wave_fitting'), sg.Text('Guess:',tooltip='Initial guess only for usr line, fitted with a gaussian and a line'), sg.Text('Y-off'), sg.InputText (y0, key = 'y0', size = (3,1)), sg.Text('Line'), sg.InputText(x0, key = 'x0', size = (4,1)), sg.Text('Height'), sg.InputText(a, key = 'a', size = (3,1)), sg.Text('Sigma'), sg.InputText(sigma, key = 'sigma', size = (3,1)), sg.Text('Slope'), sg.InputText(m, key = 'm', size = (2,1)), sg.Text('Intercept'), sg.InputText(c, key = 'c', size = (2,1))],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Line fitting parameters window open. The main panel will be inactive until you close the window ***')
        linefit_window = sg.Window('EW parameters', linefit_layout)

        while True:
            linefit_event, linefit_values = linefit_window.read()

            if linefit_event == sg.WIN_CLOSED:
                break

            cat_band_fit = linefit_values['cat_fit']
            usr_fit_line = linefit_values['line_fit_single']
            emission_line = linefit_values['emission_line']

            try:
                low_wave_fit = float(linefit_values['left_wave_fitting'])
                high_wave_fit = float(linefit_values['right_wave_fitting'])
                y0 = float(linefit_values['y0'])
                x0 = float(linefit_values['x0'])
                a = float(linefit_values['a'])
                sigma = float(linefit_values['sigma'])
                m = float(linefit_values['m'])
                c = float(linefit_values['c'])
                wave_interval_fit = np.array([low_wave_fit,high_wave_fit])
                guess_param = [y0,x0,a,sigma,m,c]
            except ValueError:
                sg.popup ('At least one of the parameters of the Line(s) fitting task is not valid!')
                continue

            #real_cat1 = 849.8
            #real_cat2 = 854.2
            #real_cat3 = 866.2
            #index_ca1 = [847.4,848.4,856.3,857.7,848.4,851.3]
            #index_ca2 = [847.4,848.4,856.3,857.7,852.2,856.2]
            #index_ca3 = [861.9,864.2,870,872.5,864.2,868.2]


            if linefit_event == 'Confirm':
                print ('Line fitting parameters confirmed. This main panel is now active again')
                print ('')
                break

        linefit_window.close()



    #6) KINEMATICS WITH PPXF
    perform_kinematics = values['ppxf_kin']
    if (event == 'ppxf kin parameters'):
        sg.theme('LightBlue1')
        ppxf_kin_layout = [
            [sg.Text('Wavelength interval (nm):',font = ('Helvetica', 11, 'bold')), sg.InputText(wave1_kin, size = (5,1), key = 'left_wave_ppxf_kin'), sg.Text('-',font = ('Helvetica', 11, 'bold')), sg.InputText(wave2_kin, size = (5,1), key = 'right_wave_ppxf_kin'), sg.Text('Stellar library to use:',font = ('Helvetica', 11, 'bold')), sg.InputCombo(markers_ppxf_kin, key='markers_ppxf_kin', default_value=stellar_library_kin, readonly=True)],
            [sg.HorizontalSeparator()],
            [sg.Radio('Spec. constant FWHM resolution (A):', "RADIORES1", default = constant_resolution_lambda, key = 'constant_resolution_lambda',tooltip='Instrumental resolution (FWHM) in A of the spectral region',font = ('Helvetica', 11, 'bold')), sg.InputText(resolution_kin , size = (4,1), key = 'ppxf_resolution'), sg.Radio('Spec. constant R resolution:', "RADIORES1", key = 'constant_resolution_r', default = constant_resolution_r,font = ('Helvetica', 11, 'bold')), sg.InputText(resolution_kin_r, size = (5,1), key = 'ppxf_resolution_r')],
            [sg.HorizontalSeparator()],
            [sg.Text('Velocity dispersion guess (km/s):',font = ('Helvetica', 11, 'bold')), sg.InputText(sigma_guess_kin, size = (5,1), key = 'sigma_guess_kin'), sg.Text('Redshift guess:',font = ('Helvetica', 11, 'bold')),sg.InputText(redshift_guess_kin, size = (7,1), key = 'redshift_guess_kin')],
            [sg.HorizontalSeparator()],
            [sg.Text('Polynomial degree:', font = ('Helvetica', 11, 'bold')), sg.InputText(additive_degree_kin, size = (3,1), key = 'additive_degree_kin')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** ppxf kin parameters window open. The main panel will be inactive until you close the window ***')
        ppxf_kin_window = sg.Window('ppxf kinematics parameters', ppxf_kin_layout)

        while True:

            ppxf_kin_event, ppxf_kin_values = ppxf_kin_window.read()

            if ppxf_kin_event == sg.WIN_CLOSED:
                break

            constant_resolution_lambda = ppxf_kin_values['constant_resolution_lambda']
            constant_resolution_r = ppxf_kin_values['constant_resolution_r']
            stellar_library_kin = ppxf_kin_values['markers_ppxf_kin']

            #check on the wavelength band
            try:
                wave1_kin = float(ppxf_kin_values['left_wave_ppxf_kin'])
                wave2_kin = float(ppxf_kin_values['right_wave_ppxf_kin'])
                resolution_kin = float(ppxf_kin_values['ppxf_resolution'])
                resolution_kin_r = float(ppxf_kin_values['ppxf_resolution_r'])
                sigma_guess_kin = float(ppxf_kin_values['sigma_guess_kin'])
                redshift_guess_kin = float(ppxf_kin_values['redshift_guess_kin'])
                additive_degree_kin = int(ppxf_kin_values['additive_degree_kin'])

            except ValueError:
                sg.popup ('Input parameters are not valid numbers!')
                continue

            if ppxf_kin_event == 'Confirm':
                print ('ppxf kin parameters confirmed. This main panel is now active again')
                print ('')
                break

        ppxf_kin_window.close()



    #7) STELLAR POPULATIONS WITH PPXF
    stellar_pop = values['ppxf_pop']

    if (event == 'ppxf pop parameters'):
        sg.theme('LightBlue1')

        ppxf_pop_layout = [
            [sg.Text('Wavelength interval (nm):', font = ('Helvetica', 11, 'bold')), sg.InputText(wave1_pop, size = (4,1), key = 'left_wave_ppxf_pop'), sg.Text('-'), sg.InputText(wave2_pop, size = (4,1), key = 'right_wave_ppxf_pop'), sg.Text('Spec. resolution FWHM (A):', font = ('Helvetica', 11, 'bold'),tooltip='Instrumental resolution (FWHM) in A of the spectral region'), sg.InputText(res_pop , size = (3,1), key = 'resolution_ppxf_pop')],
            #[sg.Text('', font = ('Helvetica', 1))],
            [sg.HorizontalSeparator()],
            [sg.Text('Velocity dispersion guess (km/s):', font = ('Helvetica', 11, 'bold')), sg.InputText(sigma_guess_pop, size = (6,1), key = 'sigma_guess_pop'), sg.Text('Redshift guess (z):', font = ('Helvetica', 11, 'bold')), sg.InputText(z_pop, size = (8,1), key = 'ppxf_z_pop')],
            #[sg.Text('', font = ('Helvetica', 1))],
            [sg.HorizontalSeparator()],
            [sg.Radio('Fitting with gas', "RADIOPOP", key = 'gas_pop', default = pop_with_gas, font = ('Helvetica', 11, 'bold')), sg.Checkbox('Tie Balmer', key = 'ppxf_pop_tie_balmer', default = ppxf_pop_tie_balmer), sg.Text('Reddening'), sg.InputText(ppxf_pop_reddening, size = (5,1), key = 'ppxf_pop_reddening'), sg.Radio('Fitting without gas',"RADIOPOP", key = 'no_gas_pop', default = pop_without_gas, font = ('Helvetica', 11, 'bold'))],
            #[sg.Text('', font = ('Helvetica', 1))],
            [sg.HorizontalSeparator()],
            [sg.Text('Regul. error:', font = ('Helvetica', 11, 'bold')), sg.InputText(regul_err, size = (4,1), key = 'regul_err'), sg.Text('Additive degree:', font = ('Helvetica', 11, 'bold')), sg.InputText(additive_degree, size = (3,1), key = 'additive_degree'), sg.Text('Multiplicative degree:', font = ('Helvetica', 11, 'bold')), sg.InputText(multiplicative_degree, size = (3,1), key = 'multiplicative_degree')],
            #[sg.Text('', font = ('Helvetica', 1))],
            [sg.HorizontalSeparator()],
            [sg.Text('Stellar library to use:', font = ('Helvetica', 11, 'bold')), sg.InputCombo(markers_ppxf, key='markers_ppxf',default_value=stellar_library, readonly=True), sg.Checkbox('Calculate errors for age and met', font = ('Helvetica', 11, 'bold'), key = 'ppxf_err_pop', default = with_errors,tooltip='Calculate the errors for age and met with MonteCarlo simulations')],
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** ppxf pop parameters window open. The main panel will be inactive until you close the window ***')
        ppxf_pop_window = sg.Window('ppxf Population parameters', ppxf_pop_layout)

        while True:

            ppxf_pop_event, ppxf_pop_values = ppxf_pop_window.read()

            if ppxf_pop_event == sg.WIN_CLOSED:
                break
            stellar_library = ppxf_pop_values['markers_ppxf']
            pop_with_gas = ppxf_pop_values['gas_pop']
            if pop_with_gas == True:
                fit_components = ('with_gas')
                ppxf_pop_tie_balmer = ppxf_pop_values['ppxf_pop_tie_balmer']
            pop_without_gas = ppxf_pop_values['no_gas_pop']
            if pop_without_gas == True:
                fit_components = ('without_gas')

            try:
                wave1_pop = float(ppxf_pop_values['left_wave_ppxf_pop'])
                wave2_pop = float(ppxf_pop_values['right_wave_ppxf_pop'])
                res_pop = float(ppxf_pop_values['resolution_ppxf_pop'])
                sigma_guess_pop = float(ppxf_pop_values['sigma_guess_pop'])
                with_errors = ppxf_pop_values['ppxf_err_pop']
                regul_err = float(ppxf_pop_values['regul_err'])
                additive_degree = int(ppxf_pop_values['additive_degree'])
                multiplicative_degree = int(ppxf_pop_values['multiplicative_degree'])
                z_pop = float(ppxf_pop_values['ppxf_z_pop'])
                ppxf_pop_reddening = float(ppxf_pop_values['ppxf_pop_reddening'])

            except ValueError:
                sg.popup ('Invalid input parameters!')
                continue

            if ppxf_pop_event == 'Confirm':
                print ('ppxf pop parameters confirmed. This main panel is now active again')
                print ('')
                break

        ppxf_pop_window.close()



    #8) SIGMA COEFF DETERMINATION
    sigma_corr_coeff = values['sigma_coeff']
    if (event == 'Sigma coeff parameters'):
        sg.theme('LightBlue1')
        sigmacorr_layout = [
            [sg.Radio('Index list file:', "RADIOCOEFF1", default = have_index_file_corr, key = 'ew_corr_idx_file'), sg.InputText(index_file_corr, size = (15,1), key = 'idx_corr_file'), sg.Radio('Usr index', "RADIOCOEFF1", default = single_index_corr, key = 'ew_corr_single_idx'), sg.Text('blue continuum:'), sg.InputText(idx_left_blue, size = (5,1), key = 'left_wave_blue_cont'), sg.Text('-'), sg.InputText(idx_right_blue, size = (5,1), key = 'right_wave_blue_cont'), sg.Text('red continuum:'), sg.InputText(idx_left_red, size = (5,1), key = 'left_wave_red_cont'), sg.Text('-'),  sg.InputText(idx_right_red, size = (5,1), key = 'right_wave_red_cont'), sg.Text('line:'), sg.InputText(idx_left_line, size = (5,1), key = 'left_line'), sg.Text('-'), sg.InputText(idx_right_line, size = (5,1), key = 'right_line')],
            [sg.Text('Sample spectra list:'), sg.InputText(stellar_spectra_coeff_file, size = (17,1), key = 'sigma_coeff_sample_list'), sg.FileBrowse(tooltip='Load a list file containing the names of the sample spectra'), sg.Radio('nm', "RADIOCOEFF", key = 'sigma_coeff_sample_list_wave_nm', default = lambda_units_coeff_nm), sg.Radio('A', "RADIOCOEFF", key = 'sigma_coeff_sample_list_wave_a', default = lambda_units_coeff_a), sg.Radio('mu', "RADIOCOEFF", default = lambda_units_coeff_mu, key = 'sigma_coeff_sample_list_wave_mu'), sg.Checkbox('Add a sigma (km/s): ', key = 'sigma_coeff_sample_smooth', default = smooth_stellar_sample ), sg.InputText(smooth_value_sample, size = (5,1), key = 'sigma_coeff_sample_smooth_sigma')],

            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Sigma coeff parameters window open. The main panel will be inactive until you close the window ***')
        sigmacorr_window = sg.Window('ppxf Population parameters', sigmacorr_layout)


        print (single_index_corr)
        while True:

            sigmacorr_event, sigmacorr_values = sigmacorr_window.read()

            if sigmacorr_event == sg.WIN_CLOSED:
                break

            index_file_corr = sigmacorr_values['idx_corr_file']
            have_index_file_corr = sigmacorr_values['ew_corr_idx_file']
            single_index_corr = sigmacorr_values['ew_corr_single_idx']

            try:
                idx_left_blue = float(sigmacorr_values['left_wave_blue_cont'])
                idx_right_blue = float(sigmacorr_values['right_wave_blue_cont'])
                idx_left_red = float(sigmacorr_values['left_wave_red_cont'])
                idx_right_red = float(sigmacorr_values['right_wave_red_cont'])
                idx_left_line = float(sigmacorr_values['left_line'])
                idx_right_line = float(sigmacorr_values['right_line'])
                #building the index
                index_usr_corr = np.array([idx_left_blue, idx_right_blue, idx_left_red, idx_right_red, idx_left_line, idx_right_line]).T #e' il trasposto, credo!
            except ValueError:
                sg.popup('Index values not valid!')
                continue

            stellar_spectra_coeff_file = sigmacorr_values['sigma_coeff_sample_list']
            lambda_units_coeff_nm = sigmacorr_values['sigma_coeff_sample_list_wave_nm']
            lambda_units_coeff_a = sigmacorr_values['sigma_coeff_sample_list_wave_a']
            lambda_units_coeff_mu = sigmacorr_values['sigma_coeff_sample_list_wave_mu']
            #assigning lambda units of the spectra
            if (lambda_units_coeff_nm == True):
                lambda_units_coeff = 'nm'
            if (lambda_units_coeff_a == True):
                lambda_units_coeff = 'a'
            if (lambda_units_coeff_mu == True):
                lambda_units_coeff = 'mu'

            smooth_stellar_sample = sigmacorr_values['sigma_coeff_sample_smooth']
            if smooth_stellar_sample == True:
                smooth_value_sample = float(sigmacorr_values['sigma_coeff_sample_smooth_sigma'])
            else:
                smooth_value_sample = 0.

            if sigmacorr_event == 'Confirm':
                print ('sigma coeff parameters confirmed. This main panel is now active again')
                print ('')
                break

        sigmacorr_window.close()





    #9) CORRECT EWS FOR SIGMA
    correct_ew = values['sigma_corr']
    if (event == 'Sigma corr parameters'):
        sg.theme('LightBlue1')
        correw_layout = [
            [sg.Text('Sigma list file'), sg.InputText(sigma_vel_file, size = (14,1), key = 'sigma_file'), sg.FileBrowse(tooltip='Load the ASCII file of the results of the velocity dispersion task, that contains: Spec. name, sigma, err_sigma'), sg.Text('EW file to correct:'), sg.InputText(ew_list_file, size = (14,1), key = 'ew_file_to_correct'), sg.FileBrowse(tooltip='Load the ASCII file of the results of the equivalent width task, that contains: Spec. name, EW, err_ew'), sg.Text('Correction coeff. file'), sg.InputText(sigma_coeff_file, size = (14,1), key = 'coeff_sigma_file'), sg.FileBrowse(tooltip='Load the ASCII file of the results of the Sigma coeff determination task, that contains: coeff. indices, coeff. errors')] ,
            [sg.Push(), sg.Button('Confirm',button_color= ('black','orange'), size = (18,1))]
            ]

        print ('*** Sigma corr parameters window open. The main panel will be inactive until you close the window ***')
        correw_window = sg.Window('Sigma correction parameters', correw_layout)

        while True:

            correw_event, correw_values = correw_window.read()

            if correw_event == sg.WIN_CLOSED:
                break

            sigma_vel_file = correw_values['sigma_file']
            ew_list_file = correw_values['ew_file_to_correct']
            sigma_coeff_file = correw_values['coeff_sigma_file']

            if correw_event == 'Confirm':
                print ('sigma corr parameters confirmed. This main panel is now active again')
                print ('')
                break

        correw_window.close()


    #********************************** last options **********************************
    save_intermediate_files = values['save_intermediate_files']
    save_plot = values['save_plots']

    #********************************** STAND ALONE SUB APPLICATIONS *************************

    #******************simple text editor**********************
    if event == 'Text editor':
        print('***** Text editor open. The main panel will be inactive until you close the editor *****')

        sg.theme('DarkBlue3')

        editor_layout = [
            [sg.Multiline(size=(90, 30), key='-TEXT-', font=('Helvetica', 12))],
            [sg.Button('Open', key='-OPEN-', size = (15,1), font=('Helvetica', 12), button_color=('black','light green')), sg.Button('Save', key='-SAVE-', size = (15,1), font=('Helvetica', 12)),  sg.Button('Find', size = (15,1), font=('Helvetica', 12)), sg.Button('Undo', size = (15,1), font=('Helvetica', 12)) ],
            [sg.Button('Find/Replace', size = (15,1), font=('Helvetica', 12)), sg.Button('Match rows', size = (15,1), font=('Helvetica', 12)), sg.Button('Create New Column', size = (15,1), font=('Helvetica', 12)), sg.Button('Delete Columns', size = (15,1), font=('Helvetica', 12)), sg.Push(), sg.Button('Close', button_color=('white','orange'), size = (15,1), font=('Helvetica', 12, 'bold'))]
        ]

        window_editor = sg.Window('Text editor', editor_layout)
        file_modified = False
        text_backup = ""

        while True:
            editor_event, editor_values = window_editor.read()

            if editor_event == sg.WIN_CLOSED or editor_event == 'Close':
                if file_modified:
                    confirm_close = sg.popup_yes_no(
                        'Changes have not been saved. Are you sure you want to close?', 'Close')
                    if confirm_close == 'Yes':
                        print('Text editor closed. This main panel is now active again')
                        print('')
                        break
                else:
                    print('Text editor closed. This main panel is now active again')
                    print('')
                    break
            elif editor_event == '-SAVE-':
                text = editor_values['-TEXT-']
                filename = sg.popup_get_file('Save the file', save_as=True, default_extension=".txt")
                if filename:
                    span.save_file(filename, text)
                    sg.popup(f'The file {filename} has been saved.')
                    file_modified = False  # Reset the modification flag
            elif editor_event == '-OPEN-':
                if file_modified:
                    confirm_open = sg.popup_yes_no(
                        'Changes have not been saved. Are you sure you want to open a new file?', 'Open')
                    if confirm_open == 'No':
                        continue
                filename = sg.popup_get_file('Open file', default_extension=".txt")
                if filename:
                    with open(filename, 'r') as file:
                        try:
                            text = file.read()
                            text_backup = text  # Backup the original text
                        except UnicodeDecodeError:
                            sg.popup('Invalid file. I just read simple txt files!')
                            continue
                    window_editor['-TEXT-'].update(text)
                    file_modified = False  # Reset the modification flag
            elif editor_event == 'Find':
                find_text = sg.popup_get_text('Enter text to find:')
                if find_text:
                    text_to_search = editor_values['-TEXT-']
                    if find_text in text_to_search:
                        sg.popup(f'Text found at position: {text_to_search.find(find_text)}')
                    else:
                        sg.popup('Text not found.')
            elif editor_event == 'Find/Replace':
                find_text = sg.popup_get_text('Enter text to find:')
                if find_text:
                    replace_text = sg.popup_get_text('Enter text to replace with:')
                    if replace_text is not None:
                        replace_all = sg.popup_yes_no('Replace all occurrences?', 'Replace All')
                        if replace_all == 'Yes':
                            text_to_search = editor_values['-TEXT-']
                            updated_text = span.find_replace(text_to_search, find_text, replace_text, replace_all)
                            window_editor['-TEXT-'].update(updated_text)
                            file_modified = True  # Set the modification flag
            elif editor_event == 'Match rows':
                sg.theme('DarkBlue3')

                match_layout = [
                    [sg.Text('Select the first file:'), sg.InputText(key='-FILE1-', readonly=True),
                        sg.FileBrowse(file_types=(("Text Files", "*.*"),))],
                    [sg.Text('Select the second file:'), sg.InputText(key='-FILE2-', readonly=True),
                        sg.FileBrowse(file_types=(("Text Files", "*.*"),))],
                    [sg.Text('Select the common column:'), sg.InputText(key='-COMMON_COLUMN-')],
                    [sg.Button('Merge'), sg.Button('Exit')]
                ]

                match_window = sg.Window('Match and merge rows', match_layout)

                while True:
                    match_event, match_values = match_window.read()

                    if match_event == sg.WIN_CLOSED or match_event == 'Exit':
                        break
                    elif match_event == 'Merge':
                        file1_path = match_values['-FILE1-']
                        file2_path = match_values['-FILE2-']
                        common_column = match_values['-COMMON_COLUMN-']

                        if file1_path and file2_path and common_column:
                            span.merge_files(file1_path, file2_path, common_column)
                        else:
                            sg.popup_error('Please select both files and enter a common column.')

                match_window.close()
            elif editor_event == 'Create New Column':
                new_column_name = sg.popup_get_text('Enter the name for the new column:')
                if new_column_name:
                    col1_name = sg.popup_get_text('Enter the name of the first column:')
                    col2_name = sg.popup_get_text('Enter the name of the second column:')
                    expression = sg.popup_get_text('Enter the algebraic expression (e.g., col1 + col2):')
                    if col1_name and col2_name and expression:
                        try:
                            df = pd.read_csv(io.StringIO(editor_values['-TEXT-']), delimiter='\s+')

                            col1_name_clean = col1_name.replace(' ', '_')
                            col2_name_clean = col2_name.replace(' ', '_')

                            df = span.create_new_column(df, new_column_name, col1_name_clean, col2_name_clean, expression)

                            if df is not None:
                                window_editor['-TEXT-'].update(df.to_csv(index=False, sep=' ', na_rep=''))
                                file_modified = True  # Set the modification flag
                        except Exception as e:
                            sg.popup_error(f'Error creating the new column: {str(e)}')
                    else:
                        sg.popup_error('Please enter names for both columns and the algebraic expression.')

            elif editor_event == 'Delete Columns':
                columns_to_delete = sg.popup_get_text(
                    'Enter column names to delete (comma-separated):')
                if columns_to_delete:
                    try:
                        df = pd.read_csv(io.StringIO(editor_values['-TEXT-']), delimiter='\s+')
                        columns_to_delete_list = [col.strip() for col in columns_to_delete.split(',')]
                        df = df.drop(columns=columns_to_delete_list, errors='ignore')
                        window_editor['-TEXT-'].update(df.to_csv(index=False, sep=' ', na_rep=''))
                        file_modified = True  # Set the modification flag
                    except Exception as e:
                        sg.popup_error(f'Error deleting columns: {str(e)}')


            elif editor_event == 'Undo':
                # Ripristina il testo alla sua versione precedente
                window_editor['-TEXT-'].update(text_backup)
                file_modified = True  # Imposta il flag di modifica
            elif editor_event == '-TEXT-':
                # Aggiorna il backup del testo quando viene modificato
                text_backup = editor_values['-TEXT-']
                file_modified = True  # Imposta il flag di modifica


        window_editor.close()




    #*********************** FITS HEADER EDITOR *******************************************
    if event == 'FITS header editor':
        sg.theme('DarkBlue3')
        fitsheader_layout = [
            [sg.Text('Please, select what operation you want to perform on the header of the fits file(s)')],
            [sg.Button('Single fits header editor',button_color= ('black','orange'), size = (22,2), key ='hdr_single_file'), sg.Button('List of fits header editor',button_color= ('black','orange'), size = (22,2), key ='hdr_list_file'), sg.Button('Extract keyword from a list',button_color= ('black','orange'), size = (22,2), key ='extract_keyword')],
            [sg.Button('Close')]
            ]

        print ('*** Fits header editor open. The main panel will be inactive until you close the window ***')
        fitsheader_window = sg.Window('Fits header editor', fitsheader_layout)

        while True:

            fitsheader_event, fitsheader_values = fitsheader_window.read()

            if fitsheader_event == sg.WIN_CLOSED or fitsheader_event == 'Close':
                print ('Fits editor closed. This main panel is now active again')
                print ('')
                break

            #modify/add/delete keyword for a single fits
            if fitsheader_event == 'hdr_single_file':
                sg.theme('DarkBlue3')
                subfitsheader_layout = [
                    [sg.Text("Select a FITS file")],
                    [sg.Input(key='-FILE-', enable_events=True), sg.FileBrowse()],
                    [sg.Multiline(key='-HEADER-', size=(60, 15), disabled=True)],
                    [sg.Text("Modify/Add Keyword"),
                    sg.Input(key='-KEY-', size=(20, 1)),
                    sg.Input(key='-VALUE-', size=(20, 1)),
                    sg.Checkbox("Numerical value", key='-NUMERIC-', enable_events=True),
                    sg.Button("Add/Modify"), sg.Button("Delete")],  # Added "Delete" button
                    [sg.Button("Save Header"), sg.Button("Exit")]
                ]

                subfitsheader_window = sg.Window("Single FITS header editor", subfitsheader_layout)

                while True:
                    subfitsheader_event, subfitsheader_values = subfitsheader_window.read()

                    if subfitsheader_event == sg.WINDOW_CLOSED or subfitsheader_event == 'Exit':
                        break

                    if subfitsheader_event == '-FILE-':
                        file_path = subfitsheader_values['-FILE-']
                        header = span.read_fits_header(file_path)
                        subfitsheader_window['-HEADER-'].update(repr(header))

                    if subfitsheader_event == 'Add/Modify':
                        key = subfitsheader_values['-KEY-']
                        value = subfitsheader_values['-VALUE-']
                        is_numeric = subfitsheader_values['-NUMERIC-']

                        if key:
                            if is_numeric:
                                try:
                                    value = float(value)
                                except ValueError:
                                    sg.popup_error("Il valore deve essere numerico.")
                                    continue

                            header[key] = value
                            subfitsheader_window['-HEADER-'].update(repr(header))

                    if subfitsheader_event == 'Delete':
                        key_to_delete = subfitsheader_values['-KEY-']
                        if key_to_delete:
                            delete_result = span.delete_keyword(header, key_to_delete)
                            if delete_result is True:
                                subfitsheader_window['-HEADER-'].update(repr(header))
                            else:
                                sg.popup_error(f"Error during deletion: {delete_result}")


                    if subfitsheader_event == 'Save Header':
                        if 'file_path' in locals():
                            save_result = span.save_fits_header(file_path, header)
                            if save_result is True:
                                sg.popup("Header saved with succes!")
                            else:
                                sg.popup_error(f"Error during the saving of the header: {save_result}")
                        else:
                            sg.popup_error("First select a FITS file.")

                subfitsheader_window.close()


            if fitsheader_event == 'hdr_list_file':
                sg.theme('DarkBlue3')

                hdr_list_layout = [
                    [sg.Text("Select a list containing only FITS files")],
                    [sg.Input(key='-FILELIST-', enable_events=True), sg.FileBrowse()],
                    [sg.Text("Select a list containing the keyword you want to change (format: key=value=type)"), sg.Input(key='-KEYFILE-', enable_events=True), sg.FileBrowse()],
                    [sg.Multiline(key='-HEADER-', size=(60, 15), disabled=True)],
                    [sg.Button("Add/Modify"), sg.Button("Delete"), sg.Button("Exit")]
                ]

                hdr_list_window = sg.Window("FITS header editor", hdr_list_layout)

                while True:
                    hdr_list_event, hdr_list_values = hdr_list_window.read()

                    if hdr_list_event == sg.WINDOW_CLOSED or hdr_list_event == 'Exit':
                        break

                    if hdr_list_event == '-FILELIST-':
                        file_list_path = hdr_list_values['-FILELIST-']

                    if hdr_list_event == '-KEYFILE-':
                        key_file_path = hdr_list_values['-KEYFILE-']
                    try:
                        if hdr_list_event == 'Add/Modify':
                            if not file_list_path or not key_file_path:
                                sg.popup_error("Something is wrong. Check the files")
                                continue

                            file_paths = span.read_file_list(file_list_path)
                            if not file_paths:
                                sg.popup_error("Something is wrong. Check the files")
                                continue

                            try:
                                key_paths = span.read_file_list(key_file_path)
                                key_name, key_value = span.read_keyword_values_from_file(key_file_path)
                            except ValueError:
                                sg.popup_error('The keyword file is not correct. Chek it!')
                                continue

                            if len(file_paths) != len(key_paths):
                                sg.popup ('The length of the fits file is different from the length of the key file, or you just loaded wrong files. Try again')
                                continue

                            cond = 0

                            try:
                                for i in range (len(file_paths)):
                                    with fits.open(file_paths[i], mode='update') as hdul:
                                    # Aggiungi la keyword all'header del primo HDU (Header Data Unit)
                                        hdul[0].header[key_name[i]] = (key_value[i], 'radius')

                                    # Salva le modifiche
                                        hdul.flush()

                                    cond = cond +1
                                    hdr = hdul[0].header

                                    hdr_list_window['-HEADER-'].update(repr(hdr))

                            except (AttributeError, ValueError):
                                sg.popup_error('Something is wrong. Check and try again')

                            sg.popup('Successfully modified headers: ', cond, '/', len(file_paths))
                    except Exception:
                        sg.popup('File missing')
                        continue

                    try:
                        if hdr_list_event == 'Delete':
                            file_paths = span.read_file_list(file_list_path)
                            key_to_delete = sg.popup_get_text("Enter the keyword to delete:")
                            if key_to_delete:
                                cond = 0
                                try:
                                    for i in range(len(file_paths)):
                                        try:
                                            with fits.open(file_paths[i], mode='update') as hdul:
                                                # Aggiungi la keyword all'header del primo HDU (Header Data Unit)
                                                header = hdul[0].header
                                                header.remove(key_to_delete)
                                                # Salva le modifiche
                                                hdul.flush()

                                            cond = cond + 1
                                            hdr = hdul[0].header
                                        except KeyError:
                                            print ('Keyword not found')
                                            continue

                                        hdr_list_window['-HEADER-'].update(repr(hdr))
                                except FileNotFoundError:
                                    sg.popup ('Incorrect file or missing')
                                    continue
                                if cond > 0:
                                    sg.popup(f'Successfully deleted keyword "{key_to_delete}" from headers: {cond}/{len(file_paths)}')
                                else:
                                    sg.popup ('Keyword not found')
                    except NameError:
                        sg.popup ('No file to process!')
                        continue
                hdr_list_window.close()


            if fitsheader_event == 'extract_keyword':

                sg.theme('DarkBlue3')

                ext_key_layout = [
                    [sg.Text("Select a list of FITS files")],
                    [sg.Input(key='-FILELIST-', enable_events=True), sg.FileBrowse()],
                    [sg.Text("Insert the keyword to extract (case insensitive)"), sg.Input(key='-KEYWORD-')],
                    [sg.Multiline(key='-OUTPUT-', size=(60, 15), disabled=True)],
                    [sg.Button("Extract and Save"), sg.Button("Exit")]
                ]

                ext_key_window = sg.Window("Extract and Save Keyword", ext_key_layout)

                while True:
                    ext_key_event, ext_key_values = ext_key_window.read()

                    if ext_key_event == sg.WINDOW_CLOSED or ext_key_event == 'Exit':
                        break

                    if ext_key_event == '-FILELIST-':
                        file_list_path = ext_key_values['-FILELIST-']

                    try:
                        if ext_key_event == 'Extract and Save':
                            if not file_list_path:
                                sg.popup_error("Select a list of FITS files with relative path included.")
                                continue

                            keyword = ext_key_values['-KEYWORD-'].strip()
                            if not keyword:
                                sg.popup_error("Insert the keyword you want to extract")
                                continue
                            try:
                                file_paths = [line.strip() for line in open(file_list_path) if not line.startswith('#')]
                                data = []
                            except Exception:
                                sg.popup ('Problems with the fits list file. Chek it, please')
                                continue

                            for file_path in file_paths:
                                file_path = file_path.strip()
                                value = span.extract_keyword(file_path, keyword)
                                data.append({'file': file_path, 'keyword': keyword, 'value': value})

                            ext_key_window['-OUTPUT-'].update('')
                            for entry in data:
                                ext_key_window['-OUTPUT-'].print(f"{entry['file']} - {entry['keyword']}: {entry['value']}")

                            output_file = sg.popup_get_file('Save on file', save_as=True, file_types=(("Text Files", "*.txt"),))
                            if output_file:
                                span.save_to_text_file(data, output_file)
                                sg.popup(f"Results saved on: '{output_file}'")
                    except NameError:
                        sg.popup ('File not found!')
                        continue


                ext_key_window.close()

        fitsheader_window.close()

    #********************* 2D SPECTRA EXTRACTION ***********************

    # Initialize x_axis before the event loop
    if event == '2D spec extraction':
        x_axis = np.array([])

        #sg.SetOptions(tooltip_time=1000)
        sg.theme('DarkBlue3')
        # Define PySimpleGUI layout
        spec_extr_layout = [
            [sg.Text("Select FITS File:", font=("Helvetica", 12, 'bold'), text_color = 'light blue'), sg.InputText(default_text = file_path_spec_extr, key="file_path", size = (38,1)), sg.FileBrowse()],
            [sg.Text("Select Y Range for Trace Fitting:"), sg.InputText(default_text= trace_y_range_str, key="trace_y_range",size=(12, 1)), sg.Text("Degree to fit:"), sg.InputText(default_text= poly_degree_str, key="poly_degree",size=(5, 1))],
            [sg.Button("1) Open 2D Spectrum", button_color=('black','light blue'), size=(18, 1), tooltip='First we have to load and visualise the spectrum'), sg.Button("2) Fit Trace",button_color=('black','light green'), size=(19, 1), tooltip='Now we find the trace of the spectrum along the dispersion axis'), sg.Button("3) Correct Spectrum",button_color=('black','orange'), size=(18, 1), tooltip='Finally we correct the distortion of the spectrum before the extraction')],
            [sg.HorizontalSeparator()],
            [sg.Button("Extract 1D Spectrum",size=(20, 1), tooltip='Extract 1D spectrum within the selected Y range. Useful for point sources'), sg.Text("Y Range for Extract 1D Spectrum:"), sg.InputText(default_text=extract_y_range_str, key="extract_y_range",size=(12, 1))],
            [sg.Button("Extract SNR bin Spectra",size=(20, 1), tooltip='Extract n bins with the selected SNR Threshold. Useful for extended sources'), sg.Text('SNR Threshold:'), sg.InputText(key='snr',size=(4, 1), default_text=snr_threshold_str), sg.Text('Pix scale ("/pix):'), sg.InputText(key='pix_scale',size=(5, 1), default_text=pixel_scale_str)],
            [sg.Canvas(key="-CANVAS-")],
            [sg.Button("Help", size=(12, 1),button_color=('black','orange')), sg.Push(), sg.Button("Exit", size=(12, 1))]
        ]

        print ('*** 2D spectra extraction open. The main panel will be inactive until you close the window ***')

        spec_extr_window = sg.Window("2D spectra extraction", spec_extr_layout, finalize=True)
        canvas_elem = spec_extr_window["-CANVAS-"]
        canvas = canvas_elem.Widget

        trace_model = None
        check_cond = 0
        # Event loop
        while True:
            spec_extr_event, spec_extr_values = spec_extr_window.read()

            if spec_extr_event in (sg.WIN_CLOSED, "Exit"):
                print('2D spec window closed. This main panel is now active again')
                print('')
                break

            file_path_spec_extr_spec_extr = spec_extr_values["file_path"]
            trace_y_range_str = spec_extr_values["trace_y_range"]
            poly_degree_str = spec_extr_values["poly_degree"]
            extract_y_range_str = spec_extr_values["extract_y_range"]
            pixel_scale_str = spec_extr_values['pix_scale']
            snr_threshold_str = spec_extr_values['snr']
            file_path_spec_extr = spec_extr_values['file_path']


            if spec_extr_event == "1) Open 2D Spectrum":
                #file_path = spec_extr_values["file_path"]
                try:
                    trace_model = None
                    check_cond = 1
                    spectrum, header = span.open_fits(file_path_spec_extr)
                    x_axis = np.arange(len(spectrum[0]))
                    plt.imshow(spectrum, cmap="viridis", norm=LogNorm())
                    plt.title("2D Spectrum")
                    plt.show()
                    plt.close()
                except Exception:
                    sg.popup ('Spectrum not valid. Must be a 2D fits image!')

            if spec_extr_event == "2) Fit Trace":
                #trace_y_range_str = spec_extr_values["trace_y_range"]
                #poly_degree_str = spec_extr_values["poly_degree"]
                try:
                    trace_y_range = eval(trace_y_range_str)
                    poly_degree = int(poly_degree_str)

                    if poly_degree < 1 or poly_degree > 5:
                        sg.popup ('The polynomial degree should be between 1 and 5')
                        continue

                    trace_model = span.find_and_fit_spectroscopic_trace(spectrum, trace_y_range, poly_degree, True, True)

                except Exception as e:
                    sg.popup_error(f"Error: {str(e)}")

            if spec_extr_event == "3) Correct Spectrum":
                #trace_y_range_str = spec_extr_values["trace_y_range"]
                trace_y_range = eval(trace_y_range_str)

                if trace_model is not None:
                    corrected_spectrum = span.correct_distortion_slope(spectrum, trace_model, trace_y_range)
                else:
                    sg.popup_error("Please find and fit the spectroscopic trace first.")

            if spec_extr_event == "Extract 1D Spectrum":
                if trace_model is not None:
                    #extract_y_range_str = spec_extr_values["extract_y_range"]
                    extract_y_range = eval(extract_y_range_str)
                    extracted_filename = os.path.splitext(os.path.basename(file_path_spec_extr))[0]
                    span.extract_1d_spectrum(corrected_spectrum, extract_y_range, header, x_axis, output_fits_path= (f"{extracted_filename}_extracted_.fits"))
                    sg.popup ('1D spectrum saved in the working directory')
                else:
                    sg.popup_error("Please find and fit the spectroscopic trace first.")

            if spec_extr_event == "Extract SNR bin Spectra":
                if trace_model is not None and 'corrected_spectrum' in locals():
                    #snr_threshold_str = spec_extr_values['snr']#sg.popup_get_text("Enter Mean Signal-to-Noise Threshold:")

                    try:
                        snr_threshold = float(snr_threshold_str)
                        pixel_scale = float(pixel_scale_str)
                    except Exception:
                        sg.popup ('SNR or pixel scale values not valid!')
                        continue

                    if snr_threshold < 0 or pixel_scale < 0:
                        sg.popup ('SNR and pixel scale values canoot be negative')
                        continue

                    span.extract_and_save_snr_spectra(corrected_spectrum, trace_model, header, x_axis, snr_threshold, pixel_scale, file_path_spec_extr)
                else:
                    sg.popup_error("Please correct the spectrum and find the spectroscopic trace first.")

            if spec_extr_event == 'Help':
                f = open('help_files/help_2d_spec.txt', 'r')
                file_contents = f.read()
                sg.popup_scrolled(file_contents, size=(100, 40))

        spec_extr_window.close()



    #************************ DATA PLOTTING ***********************************************
    if event == 'Plot data':
        sg.theme('DarkBlue3')
        markers = ['red', 'green', 'yellow', 'blue', 'purple', 'black', 'orange']
        plot_layout = [
            [sg.Text('File to plot:', font=("Helvetica", 12, 'bold'), text_color = 'lightgreen'), sg.InputText(file_to_plot,key='-FILE-', readonly=True, size=(35, 1)), sg.FileBrowse(file_types=(('Text Files', '*.*'),),tooltip='Browse an ASCII file with space or tab soaced columns and first line containing the names of columns'), sg.Button('Load', button_color=('black','light green'), size=(7, 1), font=("Helvetica", 12), tooltip='After you browse for your data file, click here to load it')],
            [sg.Text(' x-axis data:', font=("Helvetica", 12, 'bold')), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-X_COLUMN-', enable_events=True, size=(20, 5)), sg.Text('y-axis data:', font=("Helvetica", 12, 'bold')), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-Y_COLUMNS-', size=(20, 5))],
            [sg.Checkbox('x errbars:',default = False, key = '-XERRBARS-', font=("Helvetica", 12)), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-X_ERR-', enable_events=True, size=(20, 5)), sg.Checkbox('y errbars:',default = False, key = '-YERRBARS-', font=("Helvetica", 12)), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-Y_ERR-', size=(20, 5))],
            [sg.Checkbox('Linear Fit of the data', default=False, key='-LINEAR_FIT-'), sg.Push(), sg.Checkbox('X log scale', default=False, key='-X_LOG-', font=("Helvetica", 10)),sg.Checkbox('Y log scale', default=False, key='-Y_LOG-', font=("Helvetica", 10))],
            [sg.HorizontalSeparator()],
            [sg.Text('X-axis Range:'), sg.InputText(key='-X_RANGE_MIN-', size=(8, 1)), sg.Text(' to '), sg.InputText(key='-X_RANGE_MAX-', size=(8, 1)),
            sg.Text('Y-axis Range:'), sg.InputText(key='-Y_RANGE_MIN-', size=(8, 1)), sg.Text(' to '), sg.InputText(key='-Y_RANGE_MAX-', size=(8, 1))],
            [sg.Text('X-axis label:'), sg.InputText(key='-X_LABEL-', size=(20, 1)),sg.Text('Y-axis label:'), sg.InputText(key='-Y_LABEL-', size=(20, 1))],
            [sg.Text('X-axis label size:'), sg.InputText(default_text='14', key='-X_LABEL_SIZE-', size=(5, 1)), sg.Text('Y-axis label size:'), sg.InputText(default_text='14', key='-Y_LABEL_SIZE-', size=(5, 1))],
            [sg.Text('X-ticks size:'), sg.InputText(default_text='14', key='-X_TICKS_SIZE-', size=(5, 1)), sg.Text('Y-ticks size:'), sg.InputText(default_text='14', key='-Y_TICKS_SIZE-', size=(5, 1))],
            [sg.Text('Marker color:'), sg.InputCombo(markers, key='-MARKER_COLOR-',default_value=markers[0],readonly=True), sg.Text('Marker size:'), sg.Slider(range=(1, 100), orientation='h', default_value=40, key='-MARKER_SIZE-')],
            [sg.Text('Plot size (inches):'), sg.InputText('8, 6', key='-PLOT_SIZE-', size=(5, 1)), sg.Checkbox ('Show legend', default = True, key = '-LEGEND-')],
            [sg.Button('Plot', button_color=('white','orange'), size=(15, 1), font=("Helvetica", 12)), sg.Button('SavePS', button_color=('black','light gray'), size=(15, 1), font=("Helvetica", 12)), sg.Button("Help", size=(12, 1),button_color=('black','orange')), sg.Push(), sg.Button('Exit', size=(15, 1))]
        ]

        print ('*** Plotting window open. The main panel will be inactive until you close the window ***')

        plot_window = sg.Window('Data Plotter', plot_layout)

        while True:
            plot_event, plot_values = plot_window.read()

            try:
                file_to_plot = plot_values['-FILE-']
            except Exception:
                sg.popup ('Cannot read the file to plot')
                continue

            if plot_event == sg.WIN_CLOSED or plot_event == 'Exit':
                print('Plot window closed. This main panel is now active again')
                print('')
                break
            elif plot_event == 'Load':
                file_path = plot_values['-FILE-']
                if file_path:
                    column_names = span.get_column_names(file_path)
                    plot_window['-X_COLUMN-'].update(values=column_names)
                    plot_window['-Y_COLUMNS-'].update(values=column_names)
                    plot_window['-X_ERR-'].update(values=column_names)
                    plot_window['-Y_ERR-'].update(values=column_names)

            elif plot_event == 'Plot' or plot_event == 'SavePS':
                file_path = plot_values['-FILE-']
                x_column = plot_values['-X_COLUMN-']
                y_columns = plot_values['-Y_COLUMNS-']
                x_err = plot_values['-X_ERR-']
                y_err = plot_values['-Y_ERR-']
                x_label = plot_values['-X_LABEL-']
                y_label = plot_values['-Y_LABEL-']
                legend = plot_values['-LEGEND-']
                marker_color = plot_values['-MARKER_COLOR-']
                add_error_bars_x = plot_values['-XERRBARS-']
                add_error_bars_y = plot_values['-YERRBARS-']
                marker_size = int(plot_values['-MARKER_SIZE-'])
                plot_size = tuple(map(float, plot_values['-PLOT_SIZE-'].split(',')))
                x_label_size = int(plot_values['-X_LABEL_SIZE-'])
                y_label_size = int(plot_values['-Y_LABEL_SIZE-'])
                x_tick_size = int(plot_values['-X_TICKS_SIZE-'])
                y_tick_size = int(plot_values['-Y_TICKS_SIZE-'])
                enable_linear_fit = plot_values['-LINEAR_FIT-']
                x_log_scale = plot_values['-X_LOG-']
                y_log_scale = plot_values['-Y_LOG-']

                try:
                    x_range_min = float(plot_values['-X_RANGE_MIN-']) if plot_values['-X_RANGE_MIN-'] else None
                    x_range_max = float(plot_values['-X_RANGE_MAX-']) if plot_values['-X_RANGE_MAX-'] else None
                    y_range_min = float(plot_values['-Y_RANGE_MIN-']) if plot_values['-Y_RANGE_MIN-'] else None
                    y_range_max = float(plot_values['-Y_RANGE_MAX-']) if plot_values['-Y_RANGE_MAX-'] else None
                except ValueError:
                    sg.popup ('Range values not valid!')
                    continue

                if plot_event == 'Plot':
                    span.plot_data(file_path, x_column, y_columns, x_label, y_label, marker_color, marker_size, plot_size, x_label_size, y_label_size, x_tick_size, y_tick_size, legend, add_error_bars_x, add_error_bars_y, x_err, y_err, False, enable_linear_fit, x_log_scale, y_log_scale, x_range_min, x_range_max, y_range_min, y_range_max)



                if plot_event == 'SavePS':
                    span.plot_data(file_path, x_column, y_columns, x_label, y_label, marker_color, marker_size, plot_size, x_label_size, y_label_size, x_tick_size, y_tick_size, legend, add_error_bars_x, add_error_bars_y, x_err, y_err, True, enable_linear_fit, x_log_scale, y_log_scale, x_range_min, x_range_max, y_range_min, y_range_max)

            if plot_event == 'Help':
                f = open('help_files/help_me_plot.txt', 'r')
                file_contents = f.read()
                sg.popup_scrolled(file_contents, size=(100, 40))

        plot_window.close()



# ************************* parameter definitions done ****************************
#################################################################################################
    #spec_names = 0
    #spectra_number = 0
    #fatal_condition = 0
    #reading the spectra list to have the spectra number, only if the file exists!
    if values['one_spec'] == False: #I have a list, reading the list.

        #if I press the Load spectra button, then I print some infos and update the list of spectra.
        if event == 'Load spectra':
            fatal_condition = 0
            #test if file file exist
            cond00 = (os.path.isfile(spectra_list))
            if cond00 == True:
                try:
                    df_list_spec = pd.read_csv(spectra_list, delimiter = ' ')
                    spectra_number = len(df_list_spec.index)
                except Exception:
                    sg.popup('Cannot read the spectra list. You sure it is ok?')
                    continue

            if cond00 == False:
                sg.popup('We don''t start well: the spectra file list does not exist. Try again...')
                continue

            print('You want to load ', spectra_number, 'spectra')
            print('Now I check if they really exist and are valid spectra')
            print (df_list_spec)
            print ('')
            print ('Guessing the type of the spectra. It is correct?')
            #updating the listbox on the left with the spectra names
            spec_names = np.loadtxt(spectra_list, dtype = 'str', delimiter = ' ', usecols=[0])
            listbox1 = spec_names

            window['-LIST-'].Update(listbox1) #update the listbox. Amazing!


            #2)Check if the header of the list file is present
            len_condition = 0
            if len(spec_names) != spectra_number:
                len_condition = 1
                sg.popup ('Warning: The format of the spectra list files is not correct. Maybe you forgot to add #spectrum as first line? I will crash if you press Process all')
                #continue

            #1) check if the spectra actually exist
            stop_condition = 0
            #fatal_condition = 0
            spec_not_exist = []
            spec_exist = []
            for x in range (len(spec_names)):
                cond_spec_existence = (os.path.isfile(spec_names[x]))
                if cond_spec_existence == False:
                    spec_not_exist.append(spec_names[x])
                    stop_condition = 1

            if stop_condition == 1:
                if len(spec_not_exist) == len(spec_names):
                    sg.popup ('None of the spectra exists. Please, check the file list and load it again!')
                    print('Congratulation, you loaded ZERO valid spectra')
                    spectra_number = 0
                    fatal_condition = 1
                    continue
                else:
                    sg.popup ('The following spectra do not exist! I will update the listbox considering only existing spectra', spec_not_exist)
                    spec_names = np.setdiff1d(spec_names, spec_not_exist)
                    listbox1 = spec_names
                    window['-LIST-'].Update(listbox1)

                    spectra_number = len(spec_names)
                    spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]

            if stop_condition == 0:
                spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]


            #3) Check if the files loaded are really valid spectra
            spec_not_readable = []
            stop_condition2 = 0
            for x in range (len(spec_names)):

                #progress meter if I have more than 5 spectra to load
                if len(spec_names)> 5:
                    if not sg.OneLineProgressMeter('Reading spectra', x+1, spectra_number, 'Processing spectra:', orientation='h',button_color=('white','red')):
                        print ('***CANCELLED***')
                        print ('')
                        break
                try:
                    wavelength, flux, step, name = span.read_spec(spec_names[x], lambda_units)
                except Exception:
                    stop_condition2 = 1
                    spec_not_readable.append(spec_names[x])
                    #sg.popup('Ops! Cannot read the spectrum. Maybe you upload a list of spectra?')
                    continue

            if stop_condition2 == 1:
                if len(spec_not_readable) == len(spec_names):
                    sg.popup ('None of the spectra is valid. Please, check the file list and load it again!')
                    print('Congratulation, you loaded ZERO valid spectra')
                    spectra_number = 0
                    fatal_condition = 1

                else:
                    sg.popup ('Cannot read the following spectra. I will exclude from the list', spec_not_readable)
                    readable_spec = np.setdiff1d(spec_names, spec_not_readable)
                    spec_names = readable_spec
                    listbox1 = spec_names
                    window['-LIST-'].Update(listbox1)

                    spectra_number = len(spec_names)
                    spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]

            print ('')
            print('You loaded ', spectra_number, 'valid spectra')
            print (spec_names)
            print ('')

            print ('')
            print ('*** Please, check the correct spectra wavelength range with plot button before doing anything ***')
            print ('')


        if len(spec_names) != spectra_number and spectra_number > 0:
            sg.popup ('I was joking. I will not crash, but the format of the spectra list files is not correct yet. Try to adjust the spectra file list')
            continue


        if fatal_condition == 1:
            sg.popup ('You did not load any valid spectra. I can do nothing but show you this message until you will load a valid spectra list')
            continue


        if (spec_names[0] == 0 and (event == 'Preview spec.' or event == 'Process selected' or event == 'Show info' or event == 'Preview result' or event == 'Process all' or event == 'Plot' or event =='Original spec.' or event == 'One' or event == 'All' or event == 'Compare' or event == ' One' or event == ' All' or event == 'Show snr' or event == 'See plot' or event == 'Save one' or event == 'Save all')):
            sg.popup('Please, load some spectra!')
            continue

        #convert the '-LIST-' keyword to a string, to be used as a variable to read_spec and plot
        prev_spec = ''
        prev_spec = prev_spec.join(values['-LIST-'])
        #prev_spec_nopath = Path(prev_spec).stem
        prev_spec_nopath = os.path.splitext(os.path.basename(prev_spec))[0]

    #I have just on spectrum:
    if values['one_spec'] == True:
        cond00 = (os.path.isfile(spectra_list))
        spectra_number = 1
        if event == 'Load spectra':
                #test if file file exist
            print ('Guessing the type of the spectra. It is correct?')
            if cond00 == False:
                sg.popup('We don''t start well: the spectrum does not exist. Try again...')
                continue

            prev_spec = ''
            prev_spec = spectra_list

           #control whether the spectrum is really a spectrum or something else, maybe a list
            try:
                wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                #prev_spec_nopath = Path(prev_spec).stem
                prev_spec_nopath = os.path.splitext(os.path.basename(prev_spec))[0]
                spec_name = [prev_spec_nopath, ' ' ]
                listbox2 = spec_name
                window['-LIST-'].Update(listbox2) #update the listbox
            except Exception:
                sg.popup('Ops! Cannot read the spectrum. You sure is a spectrum?')
                prev_spec = ''
                print ('Please, reload a valid spectrum or a list')
                continue

            #prev_spec_nopath = Path(prev_spec).stem
            #spec_name = [prev_spec_nopath, ' ' ]
            #listbox2 = spec_name
            #window['-LIST-'].Update(listbox2) #update the listbox
            print ('*** Please, check the correct spectrum wavelength range with plot button before doing anything ***')

    #check if I select one spec but do not load
    if values['one_spec'] == True:
        try:
            prev_spec ==''
        except NameError:
            sg.popup('Did you forget to load the spectrum??')
            continue

    #Warning in case I load the spectra but I don't select one!
    if ( (event == 'Preview spec.' or event == 'Process selected' or event == 'Show info' or event == 'Preview result' or event == 'Plot' or event == 'See plot' or event == 'Save one' or event == 'Original spec.'or event == 'One' or event == 'All' or event == 'Compare' or event == ' One' or event == ' All' or event == 'Show snr') and prev_spec == ''):
        sg.popup('No spectrum selected. Please, select one spectrum in the list. Doing nothing')
        continue


    #every time I select a loaded spectrum and press plot, I read the spectrum and plot it!
    if event == 'Plot':
        wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
        wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
        plt.plot(wavelength, flux)
        plt.xlabel('Wavelength nm', fontsize = 9)
        plt.title(prev_spec_nopath)
        plt.ylabel('Flux')
        plt.show()

    if event == 'Original spec.':
        wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
        wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
        plt.plot(wavelength, flux)
        plt.xlabel('Wavelength nm', fontsize = 9)
        plt.title(prev_spec_nopath)
        plt.ylabel('Flux')
        plt.show()

    if event == 'Read me':
        f = open('help_files/readme_span.txt', 'r')
        file_contents = f.read()
        sg.popup_scrolled(file_contents, size=(100, 40))

    if event == 'I need help':
        f = open('help_files/need_help_spec_proc.txt', 'r')
        file_contents = f.read()
        sg.popup_scrolled(file_contents, size=(100, 40))

    if event == 'Help me':
        f = open('help_files/help_me_spec_analysis.txt', 'r')
        file_contents = f.read()
        sg.popup_scrolled(file_contents, size=(100, 40))

    if event == 'Quick start':
        f = open('help_files/quick_start.txt', 'r')
        file_contents = f.read()
        sg.popup_scrolled(file_contents, size=(100, 40))

    try:
        original_flux = flux
        original_wavelength = wavelength
    except Exception:
        print ('Please, load some spectra')

#*********************** Utilities event **************
    if (event == 'Show info'):
        #reading the spectrum selected
        wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
        original_wavelength = wavelength
        #original_flux = flux
        wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

        #******************* Spectra utilities

        #show header
        if show_hdr == True:
            util_task = 1
            print ('*** Showing header *** ')
            header = span.show_hdr(prev_spec)
            sg.popup_scrolled(header, size=(100, 40))

        #show sampling
        if show_sample == True:
            util_task = 1
            print ('*** Showing sampling ***')
            step_spectrum, is_linear = span.show_sampling(wavelength)
            if is_linear == True:
                sg.popup('Step: ', round(step_spectrum,4), 'nm. LINEAR')
            else:
                sg.popup('Step: ', round(step_spectrum,4), 'nm. NOT LINEAR')

        #show resolution
        if show_resolution == True:
            util_task = 1
            print ('*** Showing the resolution of the spectrum ***')
            #check values
            if res_wave1 < wave_limits[0] or res_wave1 > wave_limits[1]:
                sg.popup('Wavelength window outside the limits of the spectrum!')
                continue
            if res_wave2 < wave_limits[0] or res_wave2 > wave_limits[1]:
                sg.popup('Wavelength window outside the limits of the spectrum!')
                continue

            resolution_R, line_wave, line_flux_spec_norm, line_flux_spec_fit = span.resolution (wavelength, flux, res_wave1, res_wave2)
            print ('Resolution R: ', resolution_R)

            plt.plot(line_wave, line_flux_spec_norm, label = 'Spectrum')
            plt.plot(line_wave, line_flux_spec_fit, label = 'Fit line spec')
            plt.xlabel('Wavelength nm', fontsize = 9)
            plt.ylabel('Flux')
            plt.title('Resolution: ' + str(round(resolution_R)))
            plt.legend(fontsize = 10)
            plt.show()


        if util_task == 0:
            sg.popup('You need to select an option before click Show info')
            continue


    if (event == 'One'):
        #reading the spectrum selected
        wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
        original_wavelength = wavelength
        #original_flux = flux
        wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
        convert_task = 0
    #Convert spectrum
        if convert == True:
            convert_task = 1
            print ('*** Converting spectrum ***')
            if convert_ascii == True:
                type_spec_to_convert = 'ASCII'
                span.convert_spec(wavelength, flux, prev_spec, type_spec_to_convert)
                print ('Spectrum', prev_spec_nopath, ' converted to ASCII')
            else:
                type_spec_to_convert = 'FITS'
                span.convert_spec(wavelength, flux, prev_spec, type_spec_to_convert)
                print ('Spectrum', prev_spec_nopath, ' converted to fits table')

        if convert_task == 0:
            sg.popup('You need to activate the option if you expect something!')
            continue

    if (event == 'All'):
        if convert == True:
            convert_task = 1

            if convert_ascii == True:
                type_spec_to_convert = 'ASCII'

                for i in range(spectra_number):
                    wavelength, flux, original_step, obj_name = span.read_spec(spec_names[i], lambda_units)
                    span.convert_spec(wavelength, flux, spec_names[i], type_spec_to_convert)

            if convert_ascii == False:
                type_spec_to_convert = 'FITS'

                for i in range(spectra_number):
                    wavelength, flux, original_step, obj_name = span.read_spec(spec_names[i], lambda_units)
                    span.convert_spec(wavelength, flux, spec_names[i], type_spec_to_convert)

        if event == 'All' and values['one_spec'] == True:
            sg.popup ('You have just one spectrum. Save all does not work!')
            continue

        if convert_task == 0:
            sg.popup('You need to activate the option if you expect something!')
            continue



    ##### Compare spectrum #####
    if (event == 'Compare'):
        compare_task = 0
        if compare_spec == True:
            compare_task = 1
            print ('*** Comparing spectra ***')

            #test if file file exist
            cond = (os.path.isfile(spec_compare_file))
            if cond == False:
                sg.popup('The spectrum to compare does not exist.')
                print ('The spectrum to compare does not exist.')
                continue
            try:
                wave_compare, flux_compare, compare_step, compare_name = span.read_spec(spec_compare_file, lambda_units)

                #normalizing
                wave_norm = wavelength[100]
                epsilon_avg = step*10
                norm_flux = span.norm_spec(wavelength, flux, wave_norm, epsilon_avg, flux)
                norm_compare_flux = span.norm_spec(wave_compare, flux_compare, wave_norm, epsilon_avg, flux_compare)

                #plotting

                fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10,5))
                fig.suptitle('Compared spectra')
                ax1.plot(wavelength, flux, label = 'Selected spectrum')
                ax1.plot(wave_compare, flux_compare, label = 'Comparison spectrum')
                ax1.set_xlabel('Wavelength nm')
                ax1.set_ylabel('Flux')
                ax1.legend(fontsize = 10)

                ax2.plot(wavelength, norm_flux, label = 'Norm. selected spectrum')
                ax2.plot(wave_compare, norm_compare_flux, label = 'Norm. comparison spectrum')
                ax2.set_xlabel('Wavelength (nm)')
                ax2.set_ylabel('Norm flux')
                ax2.legend(fontsize = 10)
                plt.show()
            except:
                sg.popup ('Cannot compare spectra. Check the comparison spectrum: does it exit and have the same lambda units?')

        if compare_task == 0:
            sg.popup('You need to select the option if you expect something!')
            continue



    ################################################# Flux convert ##############################

    if event == 'See plot' or event == ' One':
        flux_conv_task = 0

        if convert_flux == True:
            flux_conv_task = 1

            if convert_to_flambda == True:
                type_to_convert = 'to_flambda'
            if convert_to_fnu == True:
                type_to_convert = 'to_fnu'

            if event == 'See plot' or event == ' One':

                #read the spectrum
                wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
                #original_wavelength = wavelength
                #original_flux = flux

                converted_flux = span.convert_flux(wavelength, flux, prev_spec, type_to_convert, lambda_units)


                #plotting
                if event == 'See plot':
                    fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10,5))
                    fig.suptitle('Original - Converted spectrum')
                    ax1.plot(wavelength, flux, label = 'Original spectrum')
                    ax1.set_xlabel('Wavelength nm')
                    ax1.set_ylabel('Flux density')
                    ax1.legend(fontsize = 10)

                    ax2.plot(wavelength, converted_flux, label = 'Converted flux')
                    ax2.set_xlabel('Wavelength (nm)')
                    ax2.set_ylabel('Flux density')
                    ax2.legend(fontsize = 10)
                    plt.show()

                if event == ' One':
                    file_converted = result_spec+'f_converted_' + prev_spec_nopath +'.dat'
                    np.savetxt(file_converted, np.column_stack([wavelength, converted_flux]), header="wavelength \t flux_density")
                    print ('Spectrum converted flux saved somewhere')

        if flux_conv_task == 0:
            sg.popup('You need to activate the option if you expect something!')
            continue


    # Convert flux event
    if event == ' All':
        flux_conv_task = 0
        if convert_flux == True and values['one_spec'] == False:
            flux_conv_task = 1

            for i in range(spectra_number):
                #read the spectra
                wavelength, flux, original_step, obj_name = span.read_spec(spec_names[i], lambda_units)
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                #convert the spectra
                converted_flux = span.convert_flux(wavelength, flux, spec_names[i], type_to_convert, lambda_units)
                #save the spectra
                #filename = 'flux_converted' + spec_names_nopath
                file_converted = result_spec+'f_converted_' + spec_names_nopath[i] + '.dat'
                np.savetxt(file_converted, np.column_stack([wavelength, converted_flux]), header="wavelength \t flux_density")

        if flux_conv_task == 0 and values['one_spec'] == False:
            sg.popup('You need to activate the option if you expect something!')
            continue

        if event == ' All' and values['one_spec'] == True:
            sg.popup ('You should activate the option if you expect something, but "All" does not work anyway with just one spectrum!')
            continue

        #if event == ' All' and values['one_spec'] == True and flux_conv_task == 1:
            #sg.popup ('You have just one spectrum. Save all does not work!')
            #continue

   #show snr
    if event == 'Show snr':
        snr_task = 0
        #reading the spectrum selected
        wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
        #original_wavelength = wavelength
        #original_flux = flux
        wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

        if show_snr == True:
            snr_task = 1
            print ('*** Showing the SNR per pix *** ')
            #check values
            if snr_wave < wave_limits[0] or snr_wave > wave_limits[1]:
                sg.popup('Wavelength window outside the limits of the spectrum!')
                continue
            if epsilon_wave_snr < 0 or ((snr_wave+epsilon_wave_snr) > (wave_limits[1])) or (( snr_wave-epsilon_wave_snr) < wave_limits[0]):
                sg.popup('Wavelength window exceed the wavelength range of the spectrum!')
                continue

            snr_pix, snr_ang = span.show_snr(wavelength, flux, snr_wave, epsilon_wave_snr)
            sg.popup('SNR per pix: ', int(round(snr_pix)), 'SNR per Ang: ', int(round(snr_ang)), 'at ', snr_wave, 'nm')

        if snr_task == 0:
            sg.popup('You need to activate the option if you expect something!')
            continue

    #############saving the SNR, per pix and per angstrom ##########################
    if show_snr == True and (event == 'Save one' or event == 'Save all'):
        snr_task = 1
        if event == 'Save one':

            #reading the spectrum selected
            wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
            #original_wavelength = wavelength
            #original_flux = flux
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            print ('*** Showing the SNR per pix *** ')
            #check values
            if snr_wave < wave_limits[0] or snr_wave > wave_limits[1]:
                sg.popup('Wavelength window outside the limits of the spectrum!')
                continue
            if epsilon_wave_snr < 0 or ((snr_wave+epsilon_wave_snr) > (wave_limits[1])) or (( snr_wave-epsilon_wave_snr) < wave_limits[0]):
                sg.popup('Wavelength window exceed the wavelength range of the spectrum!')
                continue

            snr_pix, snr_ang = span.show_snr(wavelength, flux, snr_wave, epsilon_wave_snr)
            print ('SNR per pix: ', int(round(snr_pix)), 'SNR per Ang: ', int(round(snr_ang)), ('at ', snr_wave, 'nm'))

        if event == 'Save all' and values['one_spec'] == False:
            snr_pix_array = np.zeros(spectra_number)
            snr_ang_array = np.zeros(spectra_number)
            ctr_cond = 0


            #cycle for all the spectra
            for i in range(spectra_number):

                wavelength, flux, original_step, obj_name = span.read_spec(spec_names[i], lambda_units)
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
                            #check values
                if snr_wave < wave_limits[0] or snr_wave > wave_limits[1]:
                    print('*** WARNING*** Wavelength window outside the limits of the spectrum!')
                    ctr_cond = 1
                    continue
                elif epsilon_wave_snr < 0 or ((snr_wave+epsilon_wave_snr) > (wave_limits[1])) or (( snr_wave-epsilon_wave_snr) < wave_limits[0]):
                    print('*** WARNING*** Wavelength window exceed the wavelength range of the spectrum!')
                    ctr_cond = 1
                    continue
                else:
                    #snr spectra
                    snr_pix, snr_ang = span.show_snr(wavelength, flux, snr_wave, epsilon_wave_snr)
                    snr_pix_array[i] = (int(snr_pix))
                    snr_ang_array[i] = (int(snr_ang))

            #save the data
            file_snr_pix = result_snr_dir+'/'+spectra_list_name+'_SNR_pix_@'+str(snr_wave)+'nm_'+timestamp +'.dat'
            file_snr_ang = result_snr_dir+'/'+spectra_list_name+'_SNR_ang_@'+str(snr_wave)+'nm_'+timestamp +'.dat'
            snr_pix_id = ['#Spectrum', 'SNR_per_pix@'+str(snr_wave)+'nm']
            snr_ang_id = ['#Spectrum', 'SNR_per_Ang@'+str(snr_wave)+'nm']

            snr_pix_data_array = np.column_stack((spec_names_nopath, snr_pix_array))
            snr_ang_data_array = np.column_stack((spec_names_nopath, snr_ang_array))

            #generating the dataframe and adding the data
            df_snr_pix = pd.DataFrame(snr_pix_data_array, columns = snr_pix_id)
            df_snr_ang = pd.DataFrame(snr_ang_data_array, columns = snr_ang_id)

            #writing to a file
            df_snr_pix.to_csv(file_snr_pix, index= False, sep=' ')
            df_snr_ang.to_csv(file_snr_ang, index= False, sep=' ')

            print('File ', file_snr_pix, ' and ', file_snr_ang, ' saved')

        if event == 'Save all' and values['one_spec'] == True:
            sg.popup ('You have just one spectrum. Save all does not work!')
            continue

        if snr_task == 0:
            sg.popup('You need to activate the option if you expect something!')
            continue

    if show_snr == False and (event == 'Save one' or event == 'Save all'):
        sg.popup('You need to activate the option if you expect something!')
        continue


#################################################################################################
#################################################################################################





























#  ************************* MEGA EVENT 1: PRESS PREVIEW SPECTRUM OR PROCESS SELECTED! ****************************
# VALIDD FOR SPECTRA PRE-PROCESSING, PROCESSING AND MATH FRAMES

    if (event == 'Preview spec.' or event == 'Preview result' or event == 'Process selected'):

        #reading the spectrum selected
        try:
            wavelength, flux, step, name = span.read_spec(prev_spec, lambda_units)
            wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
            original_wavelength = wavelength
            original_flux = flux
        except IndexError:
            sg.popup('You still need to load a valid spectrum. I don''t change my mind')
            continue

    #**************** spectra pre-processing ***********************************
        # 1) CROPPING
        if cropping_spectrum == True:
            task_done = 1
            task_spec = 1
            print ('*** Cropping task ***')
            cropping_range = np.array([cropping_low_wave,cropping_high_wave])
            cropped_wavelength, cropped_flux = span.crop_spec(wavelength, flux, cropping_range)
            if len(cropped_wavelength)> 10:
                wavelength =  cropped_wavelength
                flux = cropped_flux
            else:
                print ('WARNING: The crop window is not in the spectral range. Skypping...')

            try:
                if event == 'Process selected' and save_intermediate_files == True :
                    file_cropped = result_spec+'crop_' + prev_spec_nopath + '.dat'
                    np.savetxt(file_cropped, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_cropped)
                    print('')
            except ValueError:
                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                continue

            #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

        # 2) DYNAMIC CLEANING
        if sigma_clipping == True and sigma_clip_have_file == False:
            task_done = 1
            task_spec = 1
            print ('*** Sigma clip task ***')

            clip_wavelength, clip_flux = span.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution, sigma_clip_single_value)
            wavelength = clip_wavelength
            flux = clip_flux

            try:
                if event == 'Process selected' and save_intermediate_files == True :
                    file_clipped = result_spec+'clip_' + prev_spec_nopath + '.dat'
                    np.savetxt(file_clipped, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_clipped)
                    print('')
            except ValueError:
                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                continue

        elif sigma_clipping == True and sigma_clip_have_file == True:
            sg.popup ('If you want to process just one file, please select a single sigma value')
            continue


        # 3) WAVELET CLEANING
        if wavelet_cleaning == True:
            task_done = 1
            task_spec = 1
            print ('*** Wavelet denoise task ***')

            denoised_flux = span.wavelet_cleaning(wavelength, flux, sigma_wavelets, wavelets_layers)
            #original_flux = flux
            flux = denoised_flux
            try:
                if event == 'Process selected' and save_intermediate_files == True :
                    file_wavelet = result_spec+'wavelet_' + prev_spec_nopath + '.dat'
                    np.savetxt(file_wavelet, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_wavelet)
                    print('')
            except ValueError:
                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                #continue


        # 4) FILTERING AND DENOISING
        if (filter_denoise == True):
            task_done = 1
            task_spec = 1
            print ('*** Denoising ***')

            if moving_average == True and box_moving_avg == True:
                denoised_flux = span.mov_avg(flux, box_moving_avg_size)
                flux = denoised_flux
            if moving_average == True and gauss_moving_avg == True:
                denoised_flux = span.mov_avg_gauss(wavelength, flux, gauss_moving_avg_kernel)
                flux = denoised_flux
            if low_pass_filter == True:
                denoised_flux = span.lowpass(wavelength, flux, lowpass_cut_off, lowpass_order)
                flux = denoised_flux
            if bandpass_filter == True:
                denoised_flux = span.bandpass(wavelength, flux, bandpass_lower_cut_off, bandpass_upper_cut_off, bandpass_order)
                flux = denoised_flux

            if event == 'Process selected' and save_intermediate_files == True:
                #denoised_suffix = str(int(round(box_moving_avg_size)))
                file_mov_avg = result_spec+'denoised_' + prev_spec_nopath + '.dat'
                np.savetxt(file_mov_avg, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_mov_avg)
                print('')


        # 5) DOPPLER CORRECTION
        if (dop_cor == True and dop_cor_single_shot == True):
            task_done = 1
            task_spec = 1
            print ('*** Doppler correction ***')
            dopcor_wave, dopcor_flux = span.dopcor(wavelength, flux, dop_cor_single_shot_vel)
            wavelength = dopcor_wave
            flux = dopcor_flux

            #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            if event == 'Process selected' and save_intermediate_files == True:
                file_dopcor = result_spec+'dopcor_' + prev_spec_nopath + '.dat'
                np.savetxt(file_dopcor, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_dopcor)
                print('')
        elif (dop_cor == True and dop_cor_single_shot == False):
            sg.popup('If you want to process just one file, please select the one shot value!')
            continue


        #6) HELIOCENTRIC CORRECTION
        if (helio_corr == True and helio_single_shot == True):
            task_done = 1
            task_spec = 1
            print ('*** Heliocentric correction ***')
            correction, new_wavelength, new_flux = span.helio_corr(wavelength, flux, helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj)
            print ('Heliocentric correction: ', correction, 'km/s')
            wavelength = new_wavelength
            flux = new_flux

            #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            if event == 'Process selected' and save_intermediate_files == True:
                file_helio = result_spec+'helio_' + prev_spec_nopath + '.dat'
                np.savetxt(file_helio, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_helio)
                print('')
        elif (helio_corr == True and helio_single_shot == False):
            sg.popup('If you want to process just one file, please select the one shot value!')
            continue



#************************************** SPECTRA PROCESSING *************************

        #1) REBIN
        #if rebinning linear selected, I do it
        if rebinning == True and rebinning_linear == True:
            task_done = 1
            task_spec = 1
            print ('*** Rebinning linear ***')
            rebinned_wave, rebinned_flux, npoints = span.resample(wavelength, flux, usr_step_linear)

            #update the variables. necessary because I will use always wavelength and flux for the other functions!
            wavelength = rebinned_wave
            flux = rebinned_flux

            if event == 'Process selected' and save_intermediate_files == True:
                file_rebinned = result_spec+'rebinned_' + prev_spec_nopath + '.dat'
                np.savetxt(file_rebinned, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_rebinned)
                print('')

        #if rebinning log selected, I do it.
        if (rebinning == True and rebinning_log == True):
            task_done = 1
            task_spec = 1

            print ('*** Rebinning log ***')
            rebinned_wave_log, rebinned_flux_log = span.log_rebin(wavelength, flux, usr_step_log)
            wavelength = rebinned_wave_log
            flux = rebinned_flux_log

            if event == 'Process selected' and save_intermediate_files == True:
                file_rebinned_log = result_spec+'rebinned_log_' + prev_spec_nopath + '.dat'
                np.savetxt(file_rebinned_log, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_rebinned_log)
                print('')



        # 2) DEGRADE RESOLUTION
            #a) DEGRADE FROM R TO R
        if degrade == True and is_initial_res_r == True and res_degrade_to_r == True:

            task_done = 1
            task_spec = 1
            print ('*** Degrade resolution ***')

            degraded_wave, degraded_flux = span.degrade(wavelength, flux, initial_res_r, final_res_r, True)
            #update the variables. necessary because I will use always wavelength and flux for the other functions!
            wavelength = degraded_wave
            flux = degraded_flux

            if event == 'Process selected' and save_intermediate_files == True:
                degraded_res = str(int(round(final_res_r)))
                file_degraded = result_spec+'degraded_R' + degraded_res + '_' + prev_spec_nopath + '.dat'
                np.savetxt(file_degraded, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_degraded)
                print('')


            #B) DEGRADE FROM R TO FWHM
        if degrade == True and is_initial_res_r == True and res_degrade_to_fwhm == True:
            task_done = 1
            task_spec = 1

            print ('*** Degrade resolution from R to FWHM ***')

            degraded_wave, degraded_flux = span.degradeRtoFWHM(wavelength, flux, initial_res_r, final_res_r_to_fwhm)
            wavelength = degraded_wave
            flux = degraded_flux

            if event == 'Process selected' and save_intermediate_files == True:
                degraded_res_R_to_FWHM = str(float(round(final_res_r_to_fwhm,1)))
                file_degraded_R_to_FWHM = result_spec+'degraded_FWHM' + degraded_res_R_to_FWHM + '_' + prev_spec_nopath + '.dat'
                np.savetxt(file_degraded_R_to_FWHM, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_degraded_R_to_FWHM)
                print('')


            #C) DEGRADE FROM FWHM TO FWHM
        if degrade == True and is_initial_res_fwhm == True:

            task_done = 1
            task_spec = 1

            print ('*** Degrade resolution in FWHM ***')

            degraded_wave, degraded_flux = span.degrade_lambda(wavelength, flux, initial_res_fwhm, final_res_fwhm)
            #update the variables. necessary because I will use always wavelength and flux for the other functions!
            wavelength = degraded_wave
            flux = degraded_flux

            if event == 'Process selected' and save_intermediate_files == True:
                degraded_res_lambda = str(float(round(final_res_fwhm,1)))
                file_degraded_lambda = result_spec+'degraded_FWHM' + degraded_res_lambda + '_' + prev_spec_nopath + '.dat'
                np.savetxt(file_degraded_lambda, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_degraded_lambda)
                print('')



        # 3) NORMALISE SPECTRUM TO
        if normalize_wave == True:
            task_done = 1
            task_spec = 1

            #check the limits
            if (norm_lambda < wave_limits[0] or norm_lambda > wave_limits[1]):
                sg.popup('Normalisation wavelength exceeds the range of the spectrum!')
                continue

            print ('*** Normalise ***')
            step = wavelength[1]-wavelength[0]
            epsilon_norm = step*10. #averaging on 10 steps values, rather than one value
            norm_flux = span.norm_spec(wavelength, flux, norm_lambda, epsilon_norm, flux)
            flux = norm_flux

            if event == 'Process selected' and save_intermediate_files == True:
                norm_suffix = str(norm_lambda)
                file_normalized = result_spec+'norm' + norm_suffix + '_' + prev_spec_nopath + '.dat'
                np.savetxt(file_normalized, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_normalized)
                print('')



        # 4) SIGMA BROADENING
        if (sigma_broad == True):
            task_done = 1
            task_spec = 1
            print ('*** Sigma broadening ***')
            broadened_flux = span.sigma_broad(wavelength, flux, sigma_value)
            flux = broadened_flux

            if event == 'Process selected' and save_intermediate_files == True:
                broad_suffix = str(int(round(sigma_value)))
                file_broad = result_spec+'broad' + broad_suffix + prev_spec_nopath + '.dat'
                np.savetxt(file_broad, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_broad)
                print('')



        # 5) ADD NOISE
        if (add_noise == True):
            task_done = 1
            task_spec = 1
            print ('*** Add noise ***')
            noisy_flux = span.add_noise(wavelength, flux, noise)
            flux = noisy_flux

            if event == 'Process selected' and save_intermediate_files == True:
                noise_suffix = str(int(round(noise)))
                file_noise = result_spec+'SNR' + noise_suffix + prev_spec_nopath + '.dat'
                np.savetxt(file_noise, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_noise)
                print('')



        # 6) CONTINUUM MODELLING
        if continuum_sub == True:
            task_done = 1
            task_spec = 1
            print ('*** Continuum subtraction ***')

            if cont_model_filtering == True:
                #print (cont_math_operation)
                corrected_flux, continuum_flux = span.sub_cont(wavelength, flux, cont_math_operation)

            if cont_model_poly == True:
                if event == 'Process selected' or event == 'Preview result':
                    corrected_flux, continuum_flux = span.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, False)
                else:
                    corrected_flux, continuum_flux = span.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, True)

            flux = corrected_flux

            if event == 'Process selected' and save_intermediate_files == True:
                file_cont_sub = result_spec+'cont_sub_' + prev_spec_nopath + '.dat'
                file_cont = result_spec+'cont_' + prev_spec_nopath + '.dat'
                np.savetxt(file_cont_sub, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                np.savetxt(file_cont, np.column_stack([wavelength, continuum_flux]), header="wavelength \t flux")
                print ('File saved: ', file_cont_sub)
                print ('File saved: ', file_cont)
                print('')






#************************************** SPEC MATH *******************************************

        # 1) subtract normalized average
        if (subtract_normalized_avg == True and values['one_spec'] == False):
            task_done = 1
            task_spec = 1
            print ('*** Subract normalised average ***')
            subtracted_flux = span.sub_norm_avg(wavelength, flux, lambda_units, spectra_number, spec_names)
            flux = subtracted_flux

            if event == 'Process selected' and save_intermediate_files == True:
                file_subtracted_avg = result_spec+'subtracted_average' + prev_spec_nopath + '.dat'
                np.savetxt(file_subtracted_avg, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_subtracted_avg)
                print('')
        if (subtract_normalized_avg == True and values['one_spec'] == True):
            sg.popup('There is no average to subtract!')
            continue

        # 2) subtract normalized single
        if (subtract_normalized_spec == True):
            task_done = 1
            task_spec = 1
            print ('*** Subtract normalised spectrum ***')

            #test if file file exist
            cond0 = (os.path.isfile(spectra_to_subtract))
            if cond0 == False:
                sg.popup('The file to subtract does not exist. Skipping...')
                continue

            subtracted_single_flux = span.sub_norm_single(wavelength, flux, spectra_to_subtract, lambda_units)
            flux = subtracted_single_flux

            if event == 'Process selected' and save_intermediate_files == True:
                file_subtracted_single = result_spec+'subtracted_single' + prev_spec_nopath + '.dat'
                np.savetxt(file_subtracted_single, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_subtracted_single)
                print('')

        # 3) add pedestal
        if (add_pedestal == True):
            task_done = 1
            task_spec = 1
            print ('*** Add pedestal ***')
            flux = flux + constant_pedestal

            if event == 'Process selected' and save_intermediate_files == True:
                pedestal_suffix = str(int(round(constant_pedestal)))
                file_pedestal = result_spec+'pedestal' + pedestal_suffix + prev_spec_nopath + '.dat'
                np.savetxt(file_pedestal, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_pedestal)
                print('')

        # 4) multiply by a constant
        if (multiply == True):
            task_done = 1
            task_spec = 1
            print ('*** Multiply by a constant ***')
            flux = flux*multiply_constant

            if event == 'Process selected' and save_intermediate_files == True:
                multiplied_suffix = str(int(round(multiply_constant)))
                file_multiplied = result_spec+'multiplied' + multiplied_suffix + prev_spec_nopath + '.dat'
                np.savetxt(file_multiplied, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                print ('File saved: ', file_multiplied)
                print('')

        #plotting. Not for the average and sum methods, that is if do_nothing == True
        if (do_nothing == True and event == 'Preview spec.'):
            try:
                plt.plot(original_wavelength, original_flux, label = 'Original spec.')
                plt.plot(wavelength, flux, label = 'Processed')
                plt.xlabel('Wavelength nm', fontsize = 9)
                plt.title(prev_spec_nopath)
                plt.ylabel('Flux')
                plt.legend(fontsize = 10)
                plt.show()
            except ValueError:
                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                continue

        #math operations within all the spectra
        if (do_nothing == False):

           #average all
            if (average_all == True and values['one_spec'] == False):
                task_done = 1
                task_spec = 1
                print ('*** Average all ***')
                average_spec = span.average(lambda_units, spectra_number, spec_names) # Questi primi 4 metodi lavorano su tutti gli spettri (spectra_list)
                proc_wavelength = average_spec[:,0]
                proc_flux = average_spec[:,1]

                if event == 'Process selected' and save_intermediate_files == True:
                    file_avg = result_spec+'avg_spectra.dat'
                    np.savetxt(file_avg, np.column_stack([proc_wavelength, proc_flux]), header="wavelength \t flux")
                    print ('File saved: ', file_avg)
                    print('')
            if (average_all == True and values['one_spec'] == True):
                sg.popup ('You just have one spectrum. Cannot do what you want!')
                continue

            #normalize and average
            if (norm_and_average == True and values['one_spec'] == False):
                task_done = 1
                task_spec = 1
                print ('*** Normalise and average all ***')
                average_norm_spec = span.average_norm(lambda_units, wavelength, flux, spectra_number, spec_names)
                proc_wavelength = average_norm_spec[:,0]
                proc_flux = average_norm_spec[:,1]

                if event == 'Process selected' and save_intermediate_files == True:
                    #saving file. No need to put the save intermediate option.
                    file_avg_norm = result_spec+'norm_avg_spectra.dat'
                    np.savetxt(file_avg_norm, np.column_stack([proc_wavelength, proc_flux]), header="wavelength \t flux")
                    print ('File saved: ', file_avg_norm)
                    print('')
            if (norm_and_average == True and values['one_spec'] == True):
                sg.popup ('You just have one spectrum. Cannot do what you want!')
                continue

            #sum all
            if (sum_all == True and values['one_spec'] == False):
                task_done = 1
                task_spec = 1
                print ('*** Sum all ***')
                sum_spec = span.sum_spec(lambda_units, spectra_number, spec_names)
                proc_wavelength = sum_spec[:,0]
                proc_flux = sum_spec[:,1]

                if event == 'Process selected' and save_intermediate_files == True:
                    #saving file. No need to put the save intermediate option.
                    file_sum = result_spec+'sum_spectra.dat'
                    np.savetxt(file_sum, np.column_stack([proc_wavelength, proc_flux]), header="wavelength \t flux")
                    print ('File saved: ', file_sum)
                    print('')
            if (sum_all == True and values['one_spec'] == True):
                sg.popup ('You just have one spectrum. Cannot do what you want!')
                continue

            #normalize and sum
            if (normalize_and_sum_all == True and values['one_spec'] == False):
                task_done = 1
                task_spec = 1
                print ('*** Normalise and sum all ***')
                sum_norm_spec = span.sum_norm_spec(lambda_units, spectra_number, spec_names)
                proc_wavelength = sum_norm_spec[:,0]
                proc_flux = sum_norm_spec[:,1]

                if event == 'Process selected' and save_intermediate_files == True:
                    #saving file. No need to put the save intermediate option.
                    file_sum_norm = result_spec+'norm_sum_spectra.dat'
                    np.savetxt(file_sum_norm, np.column_stack([proc_wavelength, proc_flux]), header="wavelength \t flux")
                    print ('File saved: ', file_sum_norm)
                    print('')
            if (normalize_and_sum_all == True and values['one_spec'] == True):
                sg.popup ('You just have one spectrum. Cannot do what you want!')
                continue

            if (use_for_spec_an == True and values['one_spec'] == False):
                print ('Using sum or average to spectral analysis')
                wavelength = proc_wavelength
                flux = proc_flux
            if (use_for_spec_an == True and values['one_spec'] == True):
                sg.popup ('You just have one spectrum. Cannot do what you want!')
                continue

            #plotting the spech mat average and sum all
            if (event == 'Preview spec.' and do_nothing == False  and values['one_spec'] == False):
                plt.plot(original_wavelength, original_flux, label = 'Original spec.')
                plt.plot(proc_wavelength, proc_flux, label = 'Processed')
                plt.xlabel('Wavelength nm', fontsize = 9)
                plt.title('Combined all')
                plt.ylabel('Flux')
                plt.legend(fontsize = 10)
                plt.show()
            if (event == 'Preview spec.' and do_nothing == False  and values['one_spec'] == True):
                sg.popup ('You just have one spectrum. Cannot do what you want!')
                continue


#************************************** SPECTRA ANALYSIS ********************************

        # 1) BLACKBODY FITTING
        task_analysis = 0
        if (bb_fit == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1
            #store the spectrum in temp variables
            wavelength_temp = wavelength
            flux_temp = flux

            if wave1_bb >= wave2_bb:
                sg.popup ('Like I said, the first wavelength cannot be greater than the second!')
                continue

            #check the limits
            if (wave1_bb < wave_limits[0] or wave2_bb > wave_limits[1]):
                sg.popup('Wavelength interval for blackbody fitting exceeds the range of the spectrum!')
                continue

            print ('*** Blackbody fitting *** ')

            temperature_bb, residual_bb = span.blackbody_fit(wavelength, flux, wave1_bb, wave2_bb, t_guess, True)
            print ('Best Black body temperature: ', int(temperature_bb), ' K')
            print ('')



        # 2) CROSS-CORRELATION
        if (cross_corr == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1
            #store the spectrum in temp variables
            wavelength_temp = wavelength
            flux_temp = flux
            #test if file file exist
            cond01 = (os.path.isfile(template_crosscorr))
            if cond01 == False:
                sg.popup('The template file does not exist. Skipping...')
                continue

            #reading the template for the check
            wave_temp_xcorr, flux_temp_xcorr, step_temp_xcorr, name_temp_xcorr = span.read_spec(template_crosscorr, lambda_units_template_crosscorr)
            wave_limits_template_xcorr = np.array([wave_temp_xcorr[0], wave_temp_xcorr[len(wave_temp_xcorr)-1]])

            #check the limits
            if (real_low_wave_corr < wave_limits[0] or real_high_wave_corr > wave_limits[1] or real_low_wave_corr < wave_limits_template_xcorr[0] or real_high_wave_corr > wave_limits_template_xcorr[1]):
                sg.popup('Wavelength interval for cross-correlation exceeds the range of the spectrum or the template!')
                continue

            print ('*** Cross-correlation *** ')

            rv, cc, rv_at_max, max_corr_fcn, wavelength_temp, flux_temp, wavelength_template_crosscorr, flux_template_crosscorr = span.crosscorr (wavelength_temp, flux_temp, template_crosscorr, lambda_units_template_crosscorr, wave_interval_corr, smooth_value_crosscorr, vel_interval_corr)
            print ('Rv:', rv_at_max, 'km/s')
            print ('')

            #if preview result I do also the plots
            if event == 'Preview result':
                rv_plot = str(round(rv_at_max,1))
                fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (8.5,4.5))
                fig.suptitle('Cross-correlation for ' + prev_spec_nopath + ' with ' + template_crosscorr)
                ax1.plot(rv, cc)
                ax1.plot(rv_at_max, max_corr_fcn, 'ro', label = 'RV: ' + rv_plot + 'km/s')
                ax1.set_xlabel('RV (km/s)')
                ax1.set_ylabel('Xcorr fcn')
                ax1.legend(fontsize = 10)

                ax2.plot(wavelength_temp, flux_temp, label = 'Spectrum')
                ax2.plot(wavelength_template_crosscorr, flux_template_crosscorr, label = 'Template')
                ax2.set_xlim(real_low_wave_corr, real_high_wave_corr)
                ax2.set_ylim(0.4, 1.8)
                ax2.set_xlabel('Wavelength (nm)')
                ax2.set_ylabel('Norm flux')
                ax2.legend(fontsize = 10)
                plt.show()



        # 3) VELOCITY DISPERSION
        if (sigma_measurement == True and event == 'Process selected'):
            task_done = 1
            task_analysis = 1
            #test if file file exist
            cond02 = (os.path.isfile(template_sigma))
            if cond02 == False:
                sg.popup('The template file does not exist. Skipping...')
                continue

            #reading the template for the check
            wave_temp_sigma, flux_temp_sigma, step_temp_sigma, name_temp_sigma = span.read_spec(template_sigma, lambda_units_template_sigma)
            wave_limits_template_sigma = np.array([wave_temp_sigma[0], wave_temp_sigma[len(wave_temp_sigma)-1]])

            #check the limits, for the spectrum and the template
            if ((band_sigma[0] < wave_limits[0] or cont_sigma[0] < wave_limits[0] or band_sigma[1]> wave_limits[1] or cont_sigma[1] > wave_limits[1] or band_sigma[0] < wave_limits_template_sigma[0] or cont_sigma[0] < wave_limits_template_sigma[0] or band_sigma[1]> wave_limits_template_sigma[1] or cont_sigma[1] > wave_limits_template_sigma[1])):
                sg.popup('Wavelength interval for the band is out the range of the spectrum or the template!')
                continue

            if (band_custom == True and (band_sigma[0] > band_sigma[1] or cont_sigma[0] > cont_sigma[1])):
                sg.popup('It seems we have a problem. Did you invert the wavelength range?')
                continue

            print ('*** Sigma measurement (might take a while!) ***')
            sigma, error, chisqr, band_wave, band_flux, band_flux_template_fitted, sigma_instrumental = span.sigma_measurement(wavelength, flux, template_sigma, lambda_units_template_sigma, resolution_spec, resolution_template, band_sigma, cont_sigma, True)
            print (prev_spec_nopath)
            print ('Sigma: ', sigma, '+/-', round(error,2), '    Chi Square: ', chisqr)
            print ('')

        if (sigma_measurement == True and event == 'Preview result'):
            task_done = 1
            task_analysis = 1
            #test if file file exist
            cond02 = (os.path.isfile(template_sigma))
            if cond02 == False:
                sg.popup('The template file does not exist. Skipping...')
                continue

                        #reading the template for the check
            wave_temp_sigma, flux_temp_sigma, step_temp_sigma, name_temp_sigma = span.read_spec(template_sigma, lambda_units_template_sigma)
            wave_limits_template_sigma = np.array([wave_temp_sigma[0], wave_temp_sigma[len(wave_temp_sigma)-1]])

            if ((band_sigma[0] < wave_limits[0] or cont_sigma[0] < wave_limits[0] or band_sigma[1]> wave_limits[1] or cont_sigma[1] > wave_limits[1] or band_sigma[0] < wave_limits_template_sigma[0] or cont_sigma[0] < wave_limits_template_sigma[0] or band_sigma[1]> wave_limits_template_sigma[1] or cont_sigma[1] > wave_limits_template_sigma[1])):
                sg.popup('Wavelength interval for the band is out the range of the spectrum or the template!')
                continue

            if (band_custom == True and (band_sigma[0] > band_sigma[1] or cont_sigma[0] > cont_sigma[1])):
                sg.popup('It seems we have a problem. Did you invert the wavelength range?')
                continue

            sigma, error, chisqr, band_wave, band_flux, band_flux_template_fitted, sigma_instrumental = span.sigma_measurement(wavelength, flux, template_sigma, lambda_units_template_sigma, resolution_spec, resolution_template, band_sigma, cont_sigma, False) # False means that I don't calculate the errors in the sigma_measurement function. Useful if you want to save time!

            if sigma == sigma_instrumental:
                sg.popup('WARNING: The real velocity dispersion is lower than the instrumental sigma of the spectrum. Do not trust the result!')

            #plot
            sigma_title = str(round(sigma,1))

            fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

            fig.suptitle(prev_spec_nopath + '  Sigma:' + sigma_title + 'km/s')
            ax1.plot(band_wave, band_flux, label = 'Spectrum')
            ax1.plot(band_wave, band_flux_template_fitted, label = 'Fitted template')
            ax1.set_xlabel('Wavelength (nm)')
            ax1.set_ylabel('Norm flux')
            ax1.legend(fontsize = 10)

            #plot residui
            ax2.plot(band_wave, band_flux-band_flux_template_fitted, linewidth=0.5, label = 'Residuals')
            ax2.hlines(y=0, xmin=min(band_wave), xmax=max(band_wave), linestyles='--', lw=2, linewidth=2, color='r')
            ax2.set_xlabel('Wavelength (nm)')
            ax2.set_ylabel('Residuals')
            ax2.legend(fontsize = 10)
            plt.show()



        # 4) EQUIVALENT WIDTH (EW)
            #a) If I want to measure just one index
        if (ew_measurement == True and single_index == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1
            #checking limits
            if (np.min(index_usr) < wave_limits[0] or np.max(index_usr > wave_limits[1])):
                sg.popup ('The index definition wavelength exceeds the wavelength range of the spectrum')
                continue

            #verify the index definition is in the correct sequence
            if (index_usr[0] > index_usr[1] or index_usr[2] >index_usr[3] or index_usr[4] > index_usr[5]):
                sg.popup('It seems we have a problem. Did you invert the wavelengths of the indices?')
                continue

            print ('*** Equivalent width measurement for a single index ***')

            id_array, ew_array, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(wavelength, flux, index_usr, single_index, True, True, True, False, prev_spec, True)
            #err_array_mag= 0.434*abs(err_array/ew_array)
            print ('EW:', round(ew_array,3), '+/-', round(err_array,3))
            print ('EW Mag:', round(ew_array_mag,3), '+/-', round(err_array_mag,3))
            print ('SNR:', int(snr_ew_array), 'per pix')
            print ('')

            #b) If I have an index list file
        if (ew_measurement == True and have_index_file == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1
            #chechink if the file exist
            cond03 = (os.path.isfile(index_file))
            if cond03 == False:
                sg.popup('The index file does not exist. Skipping...')
                continue

            print ('*** Equivalent width measurement for a list of indices ***')

            #exploring the index file for errors
            try:
                idx_names, indices = span.read_idx(index_file)
            except ValueError:
                sg.popup('At least one index in the file is not valid')
                continue

            if len(indices[:,0]) < 6:
                sg.popup ('The length of at least one index is not correct')
                continue

            bad_idx = []
            num_indices_test = len(idx_names)
            true_cond = 0
            idx_error = 0
            for t in range(num_indices_test):
                if (indices[0,t] > indices[1,t] or indices[2,t] > indices[3,t] or indices[4,t] > indices[5,t]):
                    bad_idx.append(idx_names[t])
                    true_cond = 1
            if true_cond == 1:
                sg.popup('It seems we have a problem. Did you invert the wavelengths of these indices?', bad_idx)
                continue

            if (event == 'Preview result'):
                id_array, ew_array, err_array, snr_ew_array, ew_array_mag, err_array_mag = span.ew_measurement(wavelength, flux, index_file, single_index, True, True, True, False, prev_spec, True)

            else:
                id_array, ew_array, err_array, snr_ew_array, ew_array_mag, err_array_mag = span.ew_measurement(wavelength, flux, index_file, single_index, False, True, True, save_plot, prev_spec_nopath,True)
            print (id_array)
            print (np.round(ew_array,3))
            print ('EW in Mag: ', np.round(ew_array,3))
            print ('SNR: ', np.round(snr_ew_array), 'per pix')

            #c) If I want to measure the Lick/IDS indices
        if (ew_measurement == True and lick_ew == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1

            print ('*** Equivalent width measurement of Lick/IDS indices ***')

            # 1) reading the Lick index file
            lick_idx_names, lick_indices = span.read_idx(lick_index_file)

            lick_wavelength = wavelength
            lick_flux = flux
            blocking_cond = 0
            #checking limits
            #wave limits of the spectrum
            lick_wave_limits = np.array([lick_wavelength[0], lick_wavelength[len(lick_wavelength)-1]])
            lick_wave_lower_limit = 420
            lick_wave_upper_limit = 630

            if ((lick_wave_limits[0] < lick_wave_lower_limit and lick_wave_limits[1]< lick_wave_lower_limit) or (lick_wave_limits[0] > lick_wave_upper_limit and lick_wave_limits[1]> lick_wave_upper_limit)):
                sg.Popup ('The window band is completely off the spectrum range')
                blocking_cond = 1

            if blocking_cond == 0:
                # 2) If I want to correct for the emission or doppler correction or sigma correction
                if lick_correct_emission == True or dop_correction_lick == True or (correct_ew_sigma == True and radio_lick_sigma_auto == True):

                    #1 running ppxf to fit the emission and retrieve the emission corrected spectra
                    additive_degree_lick = -1
                    multiplicative_degree_lick = 10
                    epsilon_wavelength = 5
                    min_wavelength = np.min(lick_wavelength)+epsilon_wavelength
                    max_wavelength = np.max(lick_wavelength)-epsilon_wavelength

                    #since ppxf is time consuming, let's limit the wavelength interval to correct the emission
                    if max_wavelength > 650:
                        max_wavelength_lick = 650
                    else:
                        max_wavelength_lick = max_wavelength
                    if min_wavelength < 400:
                        min_wavelength_lick = 400
                    else:
                        min_wavelength_lick = min_wavelength

                    #min_wavelength_lick = 480
                    #max_wavelength_lick = 550

                    sigma_guess_lick = 100
                    #res_lick = 8.4
                    fit_components_lick = ('with_gas')
                    lick_ppxf_with_errors = False
                    lick_save_plot = False
                    regul_err_lick = 0.04

                    if lick_correct_emission == True:
                        print ('Removing the emission lines with ppxf...')
                    if dop_correction_lick == True:
                        print('Doppler correction with ppxf...')

                    #lick_wavelength = wavelength
                    #lick_flux = flux


                    #performing ppxf
                    if lick_constant_fwhm == True: # with a fixed delta lambda resolution, no problem
                        kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, chi_square_lick, err_age_lick, err_met_lick, err_mass_age_lick, err_mass_met_lick, emission_corrected_flux = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, False, lick_ppxf_with_errors, lick_save_plot, 'none', regul_err_lick, additive_degree_lick, multiplicative_degree_lick, False, stellar_library_lick, 0)

                    #if I don't have a constant FWHM resolution:
                    if lick_constant_fwhm == False:
                        #considering a mean fwhm along the lick band. The errors for the indices used for stellar parameters are about 5%, so it's good for now.
                        mean_ref_lick_wavelength = 508
                        spec_lick_res_fwhm = mean_ref_lick_wavelength/spec_lick_res_r*10 #converting in A
                        kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, chi_square_lick, err_age_lick, err_met_lick, err_mass_age_lick, err_mass_met_lick, emission_corrected_flux = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, False, lick_ppxf_with_errors, lick_save_plot, 'none', regul_err_lick, additive_degree_lick, multiplicative_degree_lick, False, stellar_library_lick, 0)


                    if lick_correct_emission == True:
                        lick_wavelength = bestfit_wave_lick/10
                        lick_flux = emission_corrected_flux
                        lick_step = lick_wavelength[1] - lick_wavelength[0]

                        #rebinning linear
                        lick_wavelength, lick_flux, npoint_resampled = span.resample(lick_wavelength, lick_flux, lick_step)

                    if dop_correction_lick == True: #CAUTION HERE: IF PPXF FINDS NO GAS COMPONENTS?
                        #rebinning linear if not done before
                        if lick_correct_emission == False:
                            #rebinning linear
                            lick_step = lick_wavelength[1] - lick_wavelength[0]
                            lick_wavelength, lick_flux, npoint_resampled = span.resample(lick_wavelength, lick_flux, lick_step)
                        lick_doppler_vel = (kinematics_lick[0])
                        dop_vel = lick_doppler_vel[0]
                        lick_wavelength, lick_flux = span.dopcor(lick_wavelength, lick_flux, dop_vel)

                    if radio_lick_sigma_auto == True:
                        sigma_lick_ppxf = (kinematics_lick[0])
                        sigma_to_correct_lick = sigma_lick_ppxf[1]



                # 3) degrading the resolution, only if smaller than the lick system
                if lick_constant_fwhm == True and spec_lick_res_fwhm < 8.4:
                    lick_degraded_wavelength, lick_degraded_flux = span.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_fwhm, lick_constant_fwhm)
                elif lick_constant_fwhm == False and spec_lick_res_r > 600:
                    lick_degraded_wavelength, lick_degraded_flux = span.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_r, lick_constant_fwhm)
                else:
                    print('WARNING: The resolution of the spectrum is smaller than the one needed for the Lick/IDS system. I will still calculate the Lick/IDS indices but the results might be inaccurate.')
                    lick_degraded_wavelength = lick_wavelength
                    lick_degraded_flux = lick_flux


                # 4) Measuring the EW and doing plot
                if (event == 'Preview result'):
                    lick_id_array, lick_ew_array, lick_err_array, lick_snr_ew_array, lick_ew_array_mag, lick_err_array_mag = span.ew_measurement(lick_degraded_wavelength, lick_degraded_flux, lick_index_file, False, True, True, True, False, prev_spec, True)

                    print (lick_id_array)
                    print (lick_ew_array)
                    print ('')
                    print ('Raw EW in Mag: ')
                    print (np.round(lick_ew_array_mag, decimals = 3))
                    print ('SNR: ')
                    print (np.round(lick_snr_ew_array), 'per pix')
                    print ('')

                    # 4) Correcting the EWs
                    if correct_ew_sigma == True and radio_lick_sigma_single == True:
                        #new_ew, new_ew_err, new_ew_mag, new_ew_err_mag
                        corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_single_lick)

                        print ('Corrected EWs for sigma (A):')
                        print (np.round(corrected_lick_ew_array, decimals = 3))
                        print ('Corrected Errors for sigma:')
                        print (np.round(corrected_lick_err_array, decimals = 3))
                        print ('Corrected EWs for sigma (mag):')
                        print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                        print ('Corrected mag Errors for sigma: ')
                        print (np.round(corrected_lick_err_mag_array, decimals = 3))
                        print ('')

                        #uodating the values
                        lick_ew_array = corrected_lick_ew_array
                        lick_err_array = corrected_lick_err_array
                        lick_ew_array_mag = corrected_lick_ew_mag_array
                        lick_err_array_mag = corrected_lick_err_mag_array

                    if correct_ew_sigma == True and radio_lick_sigma_list == True:
                        print ('WARNING: cannot correct for sigma broadening one spectrum with a list of sigmas. Select the single value. Skypping the correction for now...')

                    if correct_ew_sigma == True and radio_lick_sigma_auto == True:
                        corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_to_correct_lick)

                        print ('Corrected EWs for sigma (A):')
                        print (np.round(corrected_lick_ew_array, decimals = 3))
                        print ('Corrected Errors for sigma:')
                        print (np.round(corrected_lick_err_array, decimals = 3))
                        print ('Corrected EWs for sigma (mag):')
                        print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                        print ('Corrected mag Errors for sigma: ')
                        print (np.round(corrected_lick_err_mag_array, decimals = 3))
                        print ('')

                        #uodating the values
                        lick_ew_array = corrected_lick_ew_array
                        lick_err_array = corrected_lick_err_array
                        lick_ew_array_mag = corrected_lick_ew_mag_array
                        lick_err_array_mag = corrected_lick_err_mag_array


                else: #In the case of process selected event, no need to show the plots
                    lick_id_array, lick_ew_array, lick_err_array, lick_snr_ew_array, lick_ew_array_mag, lick_err_array_mag = span.ew_measurement(lick_degraded_wavelength, lick_degraded_flux, lick_index_file, False, False, True, True, save_plot, prev_spec_nopath,True)

                    print (lick_id_array)
                    print (lick_ew_array)
                    print ('')
                    print ('Raw EW in Mag: ')
                    print (np.round(lick_ew_array_mag, decimals = 3))
                    print ('SNR: ')
                    print (np.round(lick_snr_ew_array), 'per pix')
                    print ('')

                                # 4) Correcting the EWs
                    if correct_ew_sigma == True and radio_lick_sigma_single == True:
                        corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_single_lick)

                        print ('Corrected EWs for sigma (A):')
                        print (np.round(corrected_lick_ew_array, decimals = 3))
                        print ('Corrected uncertainties for sigma:')
                        print (np.round(corrected_lick_err_array, decimals = 3))
                        print ('Corrected EWs for sigma (mag):')
                        print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                        print ('Corrected mag uncertainties for sigma: ')
                        print (np.round(corrected_lick_err_mag_array, decimals = 3))
                        print ('')

                        #uodating the values
                        lick_ew_array = corrected_lick_ew_array
                        lick_err_array = corrected_lick_err_array
                        lick_ew_array_mag = corrected_lick_ew_mag_array
                        lick_err_array_mag = corrected_lick_err_mag_array

                    if correct_ew_sigma == True and radio_lick_sigma_list == True:
                        print ('WARNING: cannot correct for sigma broadening one spectrum with a list of sigmas. Select the single value. Skypping the correction for now...')

                    if correct_ew_sigma == True and radio_lick_sigma_auto == True:

                        corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_to_correct_lick)

                        print ('Corrected EWs for sigma (A):')
                        print (np.round(corrected_lick_ew_array, decimals = 3))
                        print ('Corrected uncertainties for sigma:')
                        print (np.round(corrected_lick_err_array, decimals = 3))
                        print ('Corrected EWs for sigma (mag):')
                        print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                        print ('Corrected mag uncertainties for sigma: ')
                        print (np.round(corrected_lick_err_mag_array, decimals = 3))

                        #uodating the values
                        lick_ew_array = corrected_lick_ew_array
                        lick_err_array = corrected_lick_err_array
                        lick_ew_array_mag = corrected_lick_ew_mag_array
                        lick_err_array_mag = corrected_lick_err_mag_array


                #5) Constraining the stellar parameters and uncertainties
                if stellar_parameters_lick == True:
                    print ('Computing the stellar parameters and the uncertainties...')
                    #Loading the models
                    ssp_model = np.loadtxt(lick_ssp_model, delimiter=' ')
                    #assigning the names
                    age_teo, met_teo, alpha_teo, hb_teo, mg2_teo, mgb_teo, fe5270_teo, fe5335_teo, fem_teo, mgfe_teo = ssp_model.T

                    #assigning meaningful names to the indices used for stellar populations and creating the combined ones
                    Hbeta = lick_ew_array[0]
                    Hbetae = lick_err_array[0]
                    Mg2 = lick_ew_array_mag[1]
                    Mg2e = lick_err_array_mag[1]
                    Mgb = lick_ew_array[2]
                    Mgbe = lick_err_array[2]
                    Fe5270 = lick_ew_array[3]
                    Fe5270e = lick_err_array[3]
                    Fe5335 = lick_ew_array[4]
                    Fe5335e = lick_err_array[4]
                    Fem = (Fe5270+Fe5335)/2
                    Feme = np.sqrt((0.5*Fe5270e)**2+(0.5*Fe5335e)**2)
                    MgFe = (np.sqrt(Mgb*(0.72*Fe5270+0.28*Fe5335)))
                    MgFe = np.nan_to_num(MgFe, nan=0)
                    MgFee = np.sqrt((((Fe5270*18/25+Fe5335*7/25)/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Mgbe)**2+((Mgb*18/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5270e)**2+((Mgb*7/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5335e)**2)
                    MgFee = np.nan_to_num(MgFee, nan=0)

                    #points to interpolate
                    points_for_param = np.column_stack((Hbeta, MgFe, Fem, Mgb))

                    # Interpolate
                    age_oss = griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), age_teo, points_for_param, method='linear')
                    met_oss = griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), met_teo, points_for_param, method='linear')
                    alpha_oss = griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), alpha_teo, points_for_param, method='linear')


                    # CALCULATING THE ERRORS WITH MONTECARLO SIMULATIONS
                    sim_number = 50

                    #define the arrays containing normal fluctuations of the EW of the indices with respect to their errors
                    Hbeta_sim_array = np.random.normal(loc=Hbeta, scale=Hbetae, size=sim_number)
                    MgFe_sim_array = np.random.normal(loc=MgFe, scale=MgFee, size=sim_number)
                    Fem_sim_array = np.random.normal(loc=Fem, scale=Feme, size=sim_number)
                    Mgb_sim_array = np.random.normal(loc=Mgb, scale=Mgbe, size=sim_number)

                    #preparing the array of the stellar population simulated parameters
                    age_sim = []
                    met_sim = []
                    alpha_sim = []

                    #doing the simulation
                    for g in range (sim_number):

                        #points to interpolate
                        points_for_param_sim = np.column_stack((Hbeta_sim_array[g], MgFe_sim_array[g], Fem_sim_array[g], Mgb_sim_array[g]))

                        # Interpolate
                        age_sim.append(griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), age_teo, points_for_param_sim, method='linear'))
                        met_sim.append(griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), met_teo, points_for_param_sim, method='linear'))
                        alpha_sim.append(griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), alpha_teo, points_for_param_sim, method='linear'))

                    #remove the nan
                    age_sim = [value for value in age_sim if not np.isnan(value)]
                    met_sim = [value for value in met_sim if not np.isnan(value)]
                    alpha_sim = [value for value in alpha_sim if not np.isnan(value)]

                    #finally calculating the std and associate that to the error in age, met and alpha
                    err_age = np.std(age_sim)
                    err_met = np.std(met_sim)
                    err_alpha = np.std(alpha_sim)

                    print ('')
                    print ('Age (Gyr):', np.round(age_oss[0], decimals = 2), '+/-', round(err_age, 2))
                    print ('[Z/H] (dex):', np.round(met_oss[0], decimals = 2), '+/-', round(err_met,2))
                    print ('Alpha-en:', np.round(alpha_oss[0], decimals = 2), '+/-', round(err_alpha,2))
                    print('')

                #plotting the grids and overplot the spectrum values
                if (event == 'Preview result' and stellar_parameters_lick == True):
                    data = np.genfromtxt(lick_ssp_model, delimiter=' ', skip_header=True)

                    met_values = [-1.35, -0.33, 0, 0.35, 0.67]
                    age_values = [0.6, 0.8, 1, 2, 4, 10, 15]
                    alpha_values = [-0.3, 0, 0.3, 0.5]

                    #round to the closest value. Useful for the mgb-fem grid which strongly depends on age, so I need to fix that
                    age_closest_alpha_plot = age_values[np.abs(age_values-age_oss[0]).argmin()]

                    plt.figure(figsize=(10, 6))

                    # age
                    plt.subplot(1, 2, 1)

                    alpha_value_grid = 0 # fixing a solar alpha enhancment for the mgfe-hbeta plot

                    for i in range(len(age_values)):
                        age_idx = np.where((data[:, 0] == age_values[i]) & (data[:, 2] == alpha_value_grid))[0]
                        plt.plot(data[age_idx, 9], data[age_idx, 3], color='black', linewidth=-1)
                        plt.text(data[age_idx[4], 9] + 0.1, data[age_idx[4], 3] + 0., f'{age_values[i]} Gyr', fontsize=10, color='darkgrey')

                    # met
                    for h in range(len(met_values)):
                        met_idx = np.where((data[:, 1] == met_values[h]) & (data[:, 2] == alpha_value_grid))[0]
                        plt.plot(data[met_idx, 9], data[met_idx, 3], color='black', linewidth=1)
                        plt.text(data[met_idx[15], 9] - 0.1, data[met_idx[15], 3] - 0.25, f'{met_values[h]}', fontsize=10, color='darkgray')
                        if h == 0:
                            plt.text(data[met_idx[15], 9] - 0.7, data[met_idx[15], 3] - 0.25, f'[Fe/H]=', fontsize=10, color='darkgray')

                    plt.xlabel("[MgFe]' (\u00c5)", fontsize=14)
                    plt.ylabel('H\u03B2 (\u00c5)', fontsize=14)
                    plt.tick_params(axis='both', which='both', direction='in', left=True, right=True, top=True, bottom=True)
                    plt.minorticks_on()
                    plt.gca().yaxis.set_minor_locator(MultipleLocator(0.2))
                    plt.gca().xaxis.set_minor_locator(MultipleLocator(0.25))
                    plt.xlim(0.4, 5.80)
                    plt.ylim(0.7, 5.3)
                    plt.xticks(fontsize=14)
                    plt.yticks(fontsize=14)

                    #plotting the value
                    plt.scatter(MgFe, Hbeta, color='red', s = 16)
                    plt.errorbar(MgFe, Hbeta, xerr=MgFee, yerr=Hbetae, linestyle='None', ecolor = 'black', capsize=2)

                    # alpha values, second plot
                    plt.subplot(1, 2, 2)
                    for i in range(len(alpha_values)):
                        alpha_idx = np.where((data[:, 2] == alpha_values[i]) & (data[:, 0] == age_closest_alpha_plot))[0]
                        plt.plot(data[alpha_idx, 5], data[alpha_idx, 8], color='black', linewidth=-1)
                        plt.text(data[alpha_idx[4], 5] - 0.5, data[alpha_idx[4], 8] + 0.05, f' [\u03B1/Fe]={alpha_values[i]}', fontsize=10,
                                color='darkgray')

                    # Imposta i minor ticks per entrambi gli assi
                    plt.minorticks_on()
                    plt.gca().yaxis.set_minor_locator(MultipleLocator(0.2))
                    plt.gca().xaxis.set_minor_locator(MultipleLocator(0.25))

                    plt.yticks(np.arange(1, 6), fontsize=14)
                    plt.xlabel('Mgb (\u00c5)', fontsize=14)
                    plt.ylabel('<Fe> (\u00c5)', fontsize=14)
                    plt.tick_params(axis='both', which='both', direction='in', left=True, right=True, top=True, bottom=True)
                    plt.xlim(0.4, 6.5)
                    plt.ylim(0.7, 5.3)
                    plt.xticks(fontsize=14)
                    plt.yticks(fontsize=14)

                    #plotting the value
                    plt.scatter(Mgb, Fem, color='black', s = 16)
                    plt.errorbar(Mgb, Fem, xerr=Mgbe, yerr=Feme, linestyle='None', ecolor = 'black', capsize=2)

                    plt.tight_layout()
                    plt.show()
                    plt.close()

            else:
                print('Nothing to show')



        # 5) LINE(S) FITTING
        #cat
        if (line_fitting == True and cat_band_fit == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1

            print ('*** CaT fitting with combination of gaussians ***')

            #Performing the fitting of the CaT lines
            #checking limits
            if ( min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                sg.popup ('The window band is out of the spectrum range')
                continue

            cat_wave, cat_flux_norm, cat_fit, momentum = span.cat_fitting(wavelength,flux)

            #finding the relative minima that will be the central CaT line wavelengths:
            min_values_arg = argrelextrema(cat_fit, np.less)
            min_values_arg_extracted = min_values_arg[0]


            #if the fit fails a line:
            try:
                min_wave1 = round(cat_wave[min_values_arg_extracted[0]],1)
            except IndexError:
                min_wave1 = 0.
            try:
                min_wave2 = round(cat_wave[min_values_arg_extracted[1]],1)
            except IndexError:
                min_wave2 = 0.
            try:
                min_wave3 = round(cat_wave[min_values_arg_extracted[2]],1)
            except IndexError:
                min_wave3 = 0.
            try:
                min_flux1 = cat_fit[min_values_arg_extracted[0]]
            except IndexError:
                min_flux1 = 0.
            try:
                min_flux2 = cat_fit[min_values_arg_extracted[1]]
            except IndexError:
                min_flux2 = 0.
            try:
                min_flux3 = cat_fit[min_values_arg_extracted[2]]
            except IndexError:
                min_flux3 = 0.

            #Differences in observed and calculated peaks
            residual_wave1 = min_wave1-real_cat1
            residual_wave2 = min_wave2-real_cat2
            residual_wave3 = min_wave3-real_cat3

            #converting the wavelength residuals in velocities
            c = 299792.458
            delta_rv1 = (residual_wave1/real_cat1)*c
            delta_rv2 = (residual_wave2/real_cat2)*c
            delta_rv3 = (residual_wave3/real_cat3)*c

            #Assigning the sigma of the lines (in pixels)
            sigma_cat1 = momentum[3]
            sigma_cat2 = momentum[9]
            sigma_cat3 = momentum[15]

            #converting to velocities
            sigma_cat1_vel = (sigma_cat1/min_wave1)*c
            sigma_cat2_vel = (sigma_cat2/min_wave1)*c
            sigma_cat3_vel = (sigma_cat3/min_wave1)*c

            #residual spectrum
            residual_flux = cat_flux_norm - cat_fit

            #printing data from the fit
            print ('Central wavelength of the fitted CaT lines (nm)')
            print (min_wave1,min_wave2,min_wave3)
            print ('Real central wavelength of the CaT lines (nm)')
            print (real_cat1,real_cat2,real_cat3)
            print ('Residuals (nm):')
            print (residual_wave1,residual_wave2,residual_wave3)
            print ('Residuals in km/s')
            print (delta_rv1,delta_rv2,delta_rv3)
            print ('Mean delta RV:')
            print ((delta_rv1+delta_rv2+delta_rv3)/3)
            print ('Sigma (nm)')
            print (sigma_cat1, sigma_cat2, sigma_cat3)
            print ('Sigma (km/s)')
            print (sigma_cat1_vel,sigma_cat2_vel,sigma_cat3_vel)


            #plotting the fit result
            fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

            fig.suptitle('CaT lines fitting')
            ax1.plot(cat_wave, cat_flux_norm, label = 'Spectrum')
            ax1.plot(cat_wave, cat_fit, label = 'Fit line spec')
            ax1.set_xlabel('Wavelength (nm)')
            ax1.set_ylabel('Norm flux')
            ax1.legend(fontsize = 10)

            #plot residuals
            ax2.plot(cat_wave, residual_flux, linewidth=0.5, label = 'Residuals')
            ax2.hlines(y=0, xmin=min(cat_wave), xmax=max(cat_wave), linestyles='--', lw=2, linewidth=2, color='r')
            ax2.set_xlabel('Wavelength (nm)')
            ax2.set_ylabel('Residuals')
            ax2.legend(fontsize = 10)
            plt.show()

            #EW measurement of the fitted lines
            #ca1
            id_array, ew_array_ca1, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(cat_wave, cat_fit, index_ca1, True, False, False, True, False, prev_spec, False)

            #ca2
            id_array, ew_array_ca2, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(cat_wave, cat_fit, index_ca2, True, False, False, True, False, prev_spec, False)

            #ca3
            id_array, ew_array_ca3, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(cat_wave, cat_fit, index_ca3, True, False, False, True, False, prev_spec, False)

            #some infos
            print ('Equivalent width from the fit (Ang):')
            print ('Ca1  Ca2  Ca3')
            print (round(ew_array_ca1,2), round(ew_array_ca2,2), round(ew_array_ca3,2))
            print ('')


        #line fitting user line
        if (line_fitting == True and cat_band_fit == False and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1

            print ('*** Line fitting with combination of gaussian and a line for the slope ***')

            #check on the limits of the parameters
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            #checking limits
            if ( min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                sg.popup ('The window band is out of the spectrum range')
                continue

            #Performing the fitting of the line
            line_wave, line_flux_norm, line_fit, momentum = span.line_fitting (wavelength, flux, wave_interval_fit, guess_param)

            #finding the minimum that will be the central CaT line wavelengths:
            if emission_line == False:
                min_value_wave_arg = np.argmin(line_fit)
                min_wave = line_wave[min_value_wave_arg]

            #if I have emission I calculate the maximum!
            if emission_line == True:
                min_value_wave_arg = np.argmax(line_fit)
                min_wave = line_wave[min_value_wave_arg]

            #Assigning the sigma of the lines (in pixels)
            sigma_line = abs(momentum[3])

            #converting to velocities
            c = 299792.458
            sigma_line_vel = (sigma_line/min_wave)*c

            #residual spectrum
            residual_flux = line_flux_norm - line_fit

            #printing data from the fit
            print ('Central wavelength of the fitted line (nm)')
            print (min_wave)
            print ('Sigma (nm)')
            print (sigma_line)
            print ('Sigma (km/s)')
            print (sigma_line_vel)

            #plotting the fit result
            fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

            fig.suptitle('line fitting')
            ax1.plot(line_wave, line_flux_norm, label = 'Spectrum')
            ax1.plot(line_wave, line_fit, label = 'Fit line spec')
            ax1.set_xlabel('Wavelength (nm)')
            ax1.set_ylabel('Norm flux')
            ax1.legend(fontsize = 10)

            #plot residuals
            ax2.plot(line_wave, residual_flux, linewidth=0.5, label = 'Residuals')
            ax2.hlines(y=0, xmin=min(line_wave), xmax=max(line_wave), linestyles='--', lw=2, linewidth=2, color='r')
            ax2.set_xlabel('Wavelength (nm)')
            ax2.set_ylabel('Residuals')
            ax2.legend(fontsize = 10)
            plt.show()



        # 6) KINEMATICS WITH PPXF
        if (perform_kinematics == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1

            print ('*** Kinematics with the ppxf algorithm ***')

            #wave limits of the spectrum
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            #check on the limits of the input parameters
            if wave1_kin < wave2_kin:
                wave_limits_kin = (wave1_kin,wave2_kin)
            elif wave1_kin > wave2_kin:
                #I suppose the wavelength range is inverted:
                wave1_kin_tmp = wave1_kin
                wave1_kin = wave2_kin
                wave2_kin = wave1_kin_tmp
                wave_limits_kin = (wave1_kin, wave2_kin)

            #checking limits
            if ( wave1_kin < wave_limits[0] or wave2_kin > wave_limits[1]):
                sg.popup ('The window band is out of the spectrum range')
                continue

            try:
                if constant_resolution_lambda == True:
                    #fitting with ppxf
                    kinematics, error_kinematics, bestfit_flux, bestfit_wavelength = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin)

                if constant_resolution_lambda == False:
                    #fitting with ppxf
                    kinematics, error_kinematics, bestfit_flux, bestfit_wavelength = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin)

                plt.plot(bestfit_wavelength, bestfit_flux)
                #plt.annotate('ciccia',xy=(0.8, 1.1))



                if (np.all(kinematics !=0)): #doing the plot only if I have meaninggul values
                    vel_string = str(int(kinematics[0]))
                    sigma_string = str(int(kinematics[1]))
                    h3_string = str(round(kinematics[2],3))
                    h4_string = str(round(kinematics[3],3))
                    plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                    plt.show()
                if np.any(kinematics) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                    sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')
                    #continue
            except:
                print ('Something went wrong')



        # 7) STELLAR POPULATIONS WITH PPXF
        if (stellar_pop == True and (event == 'Process selected' or event == 'Preview result')):
            task_done = 1
            task_analysis = 1

            print ('*** Stellar populations with the ppxf algorithm ***')

            #wave limits of the spectrum
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            #check on the limits of the input parameters
            if wave1_pop < wave2_pop:
                wave_limits_pop = (wave1_pop,wave2_pop)
            elif wave1_pop > wave2_pop:
                #I suppose the wavelength range is inverted:
                wave1_pop_tmp = wave1_pop
                wave1_pop = wave2_pop
                wave2_pop = wave1_pop_tmp
                wave_limits_pop = (wave1_pop, wave2_pop)

            #checking limits
            if ( wave1_pop < wave_limits[0] or wave2_pop > wave_limits[1]):
                sg.popup ('The window band is out of the spectrum range')
                continue

            #doing it
            if with_errors == True:
                print ('')
                print ('********* Calculating the errors for age and metallicity. Please sit and wait...*****')
                print ('')

            try:
                kinematics, info_pop, info_pop_mass, mass_light, errors, bestfit_flux, bestfit_wave, bestfit_flux_gas, chi_square, err_age, err_met, err_mass_age_abs, err_mass_met, emission_corrected_flux = span.ppxf_pop(wavelength, flux, wave1_pop, wave2_pop, res_pop, z_pop, sigma_guess_pop, fit_components, True, with_errors, False, 'none', regul_err, additive_degree, multiplicative_degree, ppxf_pop_tie_balmer, stellar_library, ppxf_pop_reddening)
            except TypeError:
                kinematics=info_pop=info_pop_mass=mass_light=errors=bestfit_flux=bestfit_wave=bestfit_flux_gas=chi_square=err_age=err_met=err_mass_age_abs=err_mass_met=emission_corrected_flux=0

            #saving the file with the fit
            if event == 'Process selected':
                try:
                    #pop_suffix = str(int(round(window_size)))
                    file_fit_pop = result_spec+'ppxf_fit_pop_residuals_' + prev_spec_nopath + '.dat'
                    file_fit_stellar_template = result_spec+'ppxf_fit_pop_stellar_template_' + prev_spec_nopath + '.dat'
                    file_spec_emission_corrected = result_spec+'ppxf_fit_pop_emission_corrected_' + prev_spec_nopath + '.dat'

                    bestfit_wave = bestfit_wave/10.
                    step = wavelength[1]-wavelength[0]

                    #resampling the fit and the gas fit to a common. linear step
                    new_bestfit_wave, new_bestfit_flux, npoint_resampled = span.resample(bestfit_wave, bestfit_flux, step)

                    #extracting the flux of the spectrum in the same wave range of the fit
                    interpfunc = interpolate.interp1d(wavelength, flux, kind = 'linear')
                    flux_window = (interpfunc(new_bestfit_wave))


                    #in case I don't have gas
                    try:
                        if bestfit_flux_gas == 0:
                            stellar_fit_flux = new_bestfit_flux

                            #saving the residual file
                            flux_residuals = flux_window - new_bestfit_flux
                            np.savetxt(file_fit_pop, np.column_stack([new_bestfit_wave, flux_residuals]), header="wavelength \t flux")

                            #saving the template without gas:
                            np.savetxt(file_fit_stellar_template, np.column_stack([new_bestfit_wave, stellar_fit_flux]), header="wavelength \t flux")

                            print ('File containing the residuals of the fit saved: ', file_fit_pop)
                            print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                            print('')

                    except ValueError:
                        #considering also the gas template
                        new_bestfit_wave_gas, new_bestfit_flux_gas, npoint_resampled_gas = span.resample(bestfit_wave, bestfit_flux_gas, step)

                        #saving the residual file
                        flux_residuals = flux_window - new_bestfit_flux
                        np.savetxt(file_fit_pop, np.column_stack([new_bestfit_wave, flux_residuals]), header="wavelength \t flux")

                        #saving the template without gas:
                        stellar_fit_flux = new_bestfit_flux-new_bestfit_flux_gas
                        np.savetxt(file_fit_stellar_template, np.column_stack([new_bestfit_wave, stellar_fit_flux]), header="wavelength \t flux")

                        #saving the emission corrected spectra
                        #rebinning linear
                        ppxf_step = wavelength[1]-wavelength[0]
                        linear_wave_ppxf, emission_corrected_flux, points_spec = span.resample(bestfit_wave, emission_corrected_flux, ppxf_step)

                        np.savetxt(file_spec_emission_corrected, np.column_stack([linear_wave_ppxf, emission_corrected_flux]), header="wavelength \t flux")


                        print ('File containing the residuals of the fit saved: ', file_fit_pop)
                        print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                        print ('File containing the emission corrected spectra (empty if no gas selected): ', file_spec_emission_corrected)
                        print('')
                except TypeError:
                    print ('Something went wrong')



        # 8) SIGMA COEFF DETERMINATION
            #a) If I have a single index
        if (sigma_corr_coeff == True and single_index_corr == True and event == 'Preview result'):
            task_done = 1
            task_analysis = 1
            #cheching if the sample file exist
            cond04 = (os.path.isfile(stellar_spectra_coeff_file))
            if cond04 == False:
                sg.popup('The spectra file for sigma coefficients does not exist. Skipping...')
                continue

            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            if (np.min(index_usr_corr) < wave_limits[0] or np.max(index_usr_corr > wave_limits[1])):
                sg.popup ('The index definition wavelength exceeds the wavelength range of the spectrum')
                continue

            #verify the index definition is in the correct sequence
            if (index_usr_corr[0] > index_usr_corr[1] or index_usr_corr[2] >index_usr_corr[3] or index_usr_corr[4] > index_usr_corr[5]):
                sg.popup('It seems we have a problem. Did you invert the wavelengths of the indices?')
                continue

            print ('*** Correction coefficients for sigma and usr index ***')



            #if len(indices[:,0]) < 6:
                #sg.popup ('The length of at least one index is not correct')
                #continue

            #cheching if the spectra in the sample file exist
            spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])

            #check if the spectra actually exist
            check_condition = 0
            sample_spec_not_exist = []
            for x in range (len(spec_names_sample)):
                cond_spec_existence = (os.path.isfile(spec_names_sample[x]))
                if cond_spec_existence == False:
                    sample_spec_not_exist.append(spec_names_sample[x])
                    check_condition = 1
            if check_condition == 1:
                sg.popup ('Warning: the following spectra do not exist! delete from the list or I will crash!', sample_spec_not_exist)
                continue

            #in case is everything ok:
            if (event == 'Preview result'):

                try:
                    idx_array, ew_coeff_array, err_coeff_array, ew_mean, ew_std, stop_cond = span.sigma_coeff (stellar_spectra_coeff_file, index_usr_corr, lambda_units_coeff, True, True, smooth_value_sample, False)

                except ValueError:
                    continue

                print(idx_array)
                print('Spline coefficients for the EWs')
                print(ew_coeff_array)
                print ('')
                print('Spline coefficients for the errors')
                print(err_coeff_array)

            #b) If I have a list of indices
        if (sigma_corr_coeff == True and single_index_corr == False and event == 'Preview result'):
            task_done = 1
            task_analysis = 1
            #cheching if the files exist
            cond04 = (os.path.isfile(stellar_spectra_coeff_file))
            if cond04 == False:
                sg.popup('The spectra file for sigma coefficients does not exist. Skipping...')
                continue

            cond03 = (os.path.isfile(index_file_corr))
            if cond03 == False:
                sg.popup('The index file does not exist. Skipping...')
                continue

            #exploring the index file for errors
            try:
                idx_names, indices = span.read_idx(index_file_corr)
            except ValueError:
                sg.popup('At least one index in the file is not valid')
                continue

            if len(indices[:,0]) < 6:
                sg.popup ('The length of at least one index is not correct')
                continue

            #cheching if the spectra in the sample file exist
            spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])

            #check if the spectra actually exist
            check_condition = 0
            sample_spec_not_exist = []
            for x in range (len(spec_names_sample)):
                cond_spec_existence = (os.path.isfile(spec_names_sample[x]))
                if cond_spec_existence == False:
                    sample_spec_not_exist.append(spec_names_sample[x])
                    check_condition = 1
            if check_condition == 1:
                sg.popup ('Warning: the following spectra does not exist! delete from the list or I will crash!', sample_spec_not_exist)
                continue

            print ('*** Correction coefficients for sigma and a list of indices ***')

            if (event == 'Preview result'):

                try:
                    idx_array, ew_coeff_array, err_coeff_array, ew_mean, ew_std, stop_cond = span.sigma_coeff (stellar_spectra_coeff_file, index_file_corr, lambda_units_coeff, False, True, smooth_value_sample, False)

                except ValueError:
                    continue

                print(idx_array)
                print('Spline coefficients for the EWs')
                print(ew_coeff_array)
                print ('')
                print('Spline coefficients for the errors')
                print(err_coeff_array)

        #some check to show user mistakes
        if (sigma_corr_coeff == True and event == 'Process selected'):
            sg.popup('This task only works with the grey right button Coompute!')
            continue



        # 9) CORRECT EWS FOR SIGMA
        if (correct_ew == True and event == 'Process selected'):
            sg.popup('This task only works with the grey right button Correct!')
            continue

        #checking the existence of the file
        elif (correct_ew == True and event == 'Preview result'):
            cond04 = (os.path.isfile(sigma_vel_file))
            if cond04 == False:
                sg.popup('The sigma file does not exist. Skipping...')
                continue

            cond05 = (os.path.isfile(ew_list_file))
            if cond05 == False:
                sg.popup('The EW file does not exist. Skipping...')
                continue

            cond06 = (os.path.isfile(sigma_coeff_file))
            if cond06 == False:
                sg.popup('The sigma coeff file does not exist. Skipping...')
                continue

            try:
                all_idx_np, new_ew_data = span.corr_ew(ew_list_file, sigma_coeff_file, sigma_vel_file)
            except ValueError:
                sg.popup ('Cannot compare apples with oranges! The EW file and the correction coefficients file do not have the same indices. ')
                continue

            vel_values = np.loadtxt(sigma_vel_file, usecols = [1])
            spec_values = np.loadtxt(sigma_vel_file, dtype = 'str', usecols = [0])
            sg.popup('Spectra to correct', spec_values, 'Sigma values to correct:', vel_values)
            idx_ew_file = np.loadtxt(ew_list_file, dtype = 'str', delimiter = ' ' , max_rows = 1, comments = '##')
            idx_corr_file = np.loadtxt(sigma_coeff_file, dtype = 'str', delimiter = ' ' , max_rows = 1, comments = '##')
            sg.popup('Index to correct', idx_ew_file, 'Index coefficients', idx_corr_file)
            continue

        if (task_analysis == 0 and event == 'Preview result'):
            sg.popup ('No spectral analysis task selected. Nothing to preview!')
            continue


        #Setting up the text files to be saved

        #Test to save only the final results, without the intermediate files
        if (save_intermediate_files == True and event == 'Process selected' and task_done == 0):
            sg.popup ('Nothing to process!')
        if (save_intermediate_files == False and event == 'Process selected' and task_spec == 1):
            file_final = result_spec+'proc_' + prev_spec_nopath + '.dat'
            np.savetxt(file_final, np.column_stack([wavelength, flux]), header="wavelength \t flux")

            #considering also the cont sub task that saves the continuum!
            if (continuum_sub == True):
                file_cont = result_spec+'cont_' + prev_spec_nopath + '.dat'
                np.savetxt(file_cont, np.column_stack([wavelength, continuum_flux]), header="wavelength \t flux")
                print ('File saved: ', file_cont)

            print ('File saved: ', file_final)
            print('')
        elif (save_intermediate_files == False and event == 'Process selected' and task_done == 0):
            sg.popup ('Nothing to process!')

        if (event == 'Preview result' and task_done == 0):
            sg.popup ('Nothing to preview. Please, select a Spectral analysis task!')


################################################################################################
##################################### END TASKS ################################################




#################################################################################################
# ******************************* MEGA EVENT PROCESS ALL **************************************


    if (event == 'Process all' and values['one_spec'] == False):

        #Setting up the ASCII files with the results of the spectral analysis, only if I selected the task! This is useful because if an error occurs during the computation, you still will have the results written until the error!


        #1) Blackbody
        if (bb_fit == True):
            bb_file = result_bb_dir+'/'+spectra_list_name+'_bb_data_' +timestamp + '.dat'
            bb_id = ['#Spectrum', 'T(K)']
            bb_values = np.zeros(spectra_number)
            bb_data_array = np.column_stack((spec_names_nopath, bb_values))

            #generating the dataframe and adding the data
            df_bb = pd.DataFrame(bb_data_array, columns = bb_id)

            #writing to a file
            df_bb.to_csv(bb_file, index= True, sep=' ')


        #2) Cross correlation
        if (cross_corr == True):
            rv_file = result_xcorr_dir+'/'+spectra_list_name+'_rv_data_' +timestamp + '.dat'
            rv_id = ['#Spectrum', 'RV(km/s)']
            rv_values = np.zeros(spectra_number)
            rv_data_array = np.column_stack((spec_names_nopath, rv_values))

            #generating the dataframe and adding the data
            df_rv = pd.DataFrame(rv_data_array, columns = rv_id)

            #writing to a file
            df_rv.to_csv(rv_file, index= True, sep=' ')


        #3) Velocity dispersion measurement
        if (sigma_measurement == True):
            sigma_file = result_vel_disp_dir+'/'+spectra_list_name+'_sigma_data_'+timestamp +'.dat'
            sigma_id = ['#Spectrum', 'Sigma(km/s)', 'err']
            sigma_values = np.zeros(spectra_number)
            err_values = np.zeros(spectra_number)
            sigma_data_array = np.column_stack((spec_names_nopath, sigma_values, err_values))

            #generating the dataframe and adding the data
            df_sigma = pd.DataFrame(sigma_data_array, columns = sigma_id)

            #writing to a file
            df_sigma.to_csv(sigma_file, index= True, sep=' ')


        #4) EW measurement
        if (ew_measurement == True and single_index == True):
            ew_file = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_' +timestamp + '.dat'
            ew_id = ['#Spectrum', 'ew(A)', 'err']
            ew_values = np.zeros(spectra_number)
            err_ew_values = np.zeros(spectra_number)
            ew_data_array = np.column_stack((spec_names_nopath, ew_values, err_ew_values))

            #EW mag file
            ew_file_mag = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_mag_' +timestamp + '.dat'
            ew_id_mag = ['#Spectrum', 'ew(Mag)', 'err']
            ew_values_mag = np.zeros(spectra_number)
            err_ew_values_mag = np.zeros(spectra_number)
            ew_data_array_mag = np.column_stack((spec_names_nopath, ew_values, err_ew_values))

            #SNR data
            snr_ew_file = result_ew_data_dir+'/'+spectra_list_name+'_snr_ew_data_' +timestamp + '.dat'
            snr_ew_id = ['#Spectrum', 'SNR']
            snr_ew_values = np.zeros(spectra_number)
            snr_ew_data_array = np.column_stack((spec_names_nopath, snr_ew_values))

            #generating the dataframe and adding the data
            df_ew = pd.DataFrame(ew_data_array, columns = ew_id)
            df_snr_ew = pd.DataFrame(snr_ew_data_array, columns = snr_ew_id)
            df_ew_mag = pd.DataFrame(ew_data_array_mag, columns = ew_id_mag)

            #writing to a file EW
            df_ew.to_csv(ew_file, index= True, sep=' ')
            df_snr_ew.to_csv(snr_ew_file, index= True, sep=' ')

            #writing to a file EW Mag
            df_ew_mag.to_csv(ew_file_mag, index= True, sep=' ')

        if (ew_measurement == True and have_index_file == True):
            cond33 = (os.path.isfile(index_file))
            if cond33 == False:
                sg.popup('The index file does not exist. Skipping...')
                continue

            #exploring the index file for errors
            try:
                idx_names, indices = span.read_idx(index_file)
            except ValueError:
                sg.popup('At least one index in the file is not valid')
                continue

            if len(indices[:,0]) < 6:
                sg.popup ('The length of at least one index is not correct')
                continue

            bad_idx = []
            num_indices_test = len(idx_names)
            true_cond = 0
            idx_error = 0
            for t in range(num_indices_test):
                if (indices[0,t] > indices[1,t] or indices[2,t] > indices[3,t] or indices[4,t] > indices[5,t]):
                    bad_idx.append(idx_names[t])
                    true_cond = 1
            if true_cond == 1:
                sg.popup('It seems we have a problem. Did you invert the wavelengths of these indices?', bad_idx)
                continue

            ew_file = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_' +timestamp + '.dat'
            ew_file_mag = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_mag' +timestamp + '.dat'
            snr_ew_file = result_ew_data_dir+'/'+spectra_list_name+'_snr_ew_data_' +timestamp + '.dat'
            id_array, index = span.read_idx(index_file)
            num_indices = len(id_array)

            shape = (spectra_number, num_indices)
            ew_all = np.zeros(shape)
            ew_all_mag = np.zeros(shape)
            snr_ew_all = np.zeros(shape)
            err_all = np.zeros(shape)


            spectra_id = ['#Spectrum']
            err_col_type = np.chararray(num_indices)
            err_col_type = 'e'
            err_col_names = np.char.add(id_array, err_col_type)
            #unisco i due array dei nomi delle colonne
            col_names = np.concatenate((id_array, err_col_names))
            ew_id = np.concatenate((spectra_id, col_names))
            ew_data = np.column_stack((spec_names_nopath, ew_all, err_all))
            ew_id_mag = np.concatenate((spectra_id, col_names))
            ew_data_mag = np.column_stack((spec_names_nopath, ew_all_mag, err_all))

            df_ew = pd.DataFrame(ew_data, columns = ew_id)
            df_ew.to_csv(ew_file, index= True, sep=' ')

            df_ew_mag = pd.DataFrame(ew_data_mag, columns = ew_id_mag)
            df_ew_mag.to_csv(ew_file_mag, index= True, sep=' ')

            #SNR
            snr_col_names = id_array
            snr_ew_id = np.concatenate((spectra_id, snr_col_names))
            snr_ew_data = np.column_stack((spec_names_nopath, snr_ew_all))
            df_snr_ew = pd.DataFrame(snr_ew_data, columns = snr_ew_id)
            df_snr_ew.to_csv(snr_ew_file, index= True, sep=' ')


        if (ew_measurement == True and lick_ew == True):
            cond33 = (os.path.isfile(lick_index_file))
            if cond33 == False:
                sg.popup('The index file does not exist. Skipping...')
                continue

            ##exploring the index file for errors
            #try:
                #idx_names, indices = span.read_idx(index_file)
            #except ValueError:
                #sg.popup('At least one index in the file is not valid')
                #continue

            #if len(indices[:,0]) < 6:
                #sg.popup ('The length of at least one index is not correct')
                #continue

            #bad_idx = []
            #num_indices_test = len(idx_names)
            #true_cond = 0
            #idx_error = 0
            #for t in range(num_indices_test):
                #if (indices[0,t] > indices[1,t] or indices[2,t] > indices[3,t] or indices[4,t] > indices[5,t]):
                    #bad_idx.append(idx_names[t])
                    #true_cond = 1
            #if true_cond == 1:
                #sg.popup('It seems we have a problem. Did you invert the wavelengths of these indices?', bad_idx)
                #continue

            ew_lick_file = result_ew_data_dir+'/'+spectra_list_name+'_ew_lick_data_' +timestamp + '.dat'
            ew_lick_file_mag = result_ew_data_dir+'/'+spectra_list_name+'_ew_lick_data_mag' +timestamp + '.dat'
            snr_lick_ew_file = result_ew_data_dir+'/'+spectra_list_name+'_snr_ew_lick_data_' +timestamp + '.dat'
            id_lick_array, lick_index = span.read_idx(lick_index_file)
            num_lick_indices = len(id_lick_array)

            shape = (spectra_number, num_lick_indices)
            ew_lick_all = np.zeros(shape)
            ew_lick_all_mag = np.zeros(shape)
            snr_lick_ew_all = np.zeros(shape)
            err_lick_all = np.zeros(shape)


            spectra_lick_id = ['#Spectrum']
            err_lick_col_type = np.chararray(num_lick_indices)
            err_lick_col_type = 'e'
            err_lick_col_names = np.char.add(id_lick_array, err_lick_col_type)
            #unisco i due array dei nomi delle colonne
            col_lick_names = np.concatenate((id_lick_array, err_lick_col_names))
            ew_lick_id = np.concatenate((spectra_lick_id, col_lick_names))
            ew_lick_data = np.column_stack((spec_names_nopath, ew_lick_all, err_lick_all))
            ew_lick_id_mag = np.concatenate((spectra_lick_id, col_lick_names))
            ew_lick_data_mag = np.column_stack((spec_names_nopath, ew_lick_all_mag, err_lick_all))

            df_ew_lick = pd.DataFrame(ew_lick_data, columns = ew_lick_id)
            df_ew_lick.to_csv(ew_lick_file, index= True, sep=' ')

            df_ew_lick_mag = pd.DataFrame(ew_lick_data_mag, columns = ew_lick_id_mag)
            df_ew_lick_mag.to_csv(ew_lick_file_mag, index= True, sep=' ')

            #SNR
            snr_lick_col_names = id_lick_array
            snr_lick_ew_id = np.concatenate((spectra_lick_id, snr_lick_col_names))
            snr_lick_ew_data = np.column_stack((spec_names_nopath, snr_lick_ew_all))
            df_snr_lick_ew = pd.DataFrame(snr_lick_ew_data, columns = snr_lick_ew_id)
            df_snr_lick_ew.to_csv(snr_lick_ew_file, index= True, sep=' ')


        if (ew_measurement == True and lick_ew == True and stellar_parameters_lick == True):

            ssp_param_file = result_ew_data_dir+'/'+spectra_list_name+'_ssp_param_lick_' +timestamp + '.dat'
            ssp_param_id = ['#Spectrum', 'age(Gyr)', 'err_age', 'met', 'err_met', 'alpha','err_alpha']

            age_ssp = np.zeros(spectra_number)
            age_err_ssp = np.zeros(spectra_number)
            met_ssp = np.zeros(spectra_number)
            met_err_ssp = np.zeros(spectra_number)
            alpha_ssp = np.zeros(spectra_number)
            alpha_err_ssp = np.zeros(spectra_number)

            ssp_param_array = np.column_stack((spec_names_nopath, age_ssp,age_err_ssp,met_ssp,met_err_ssp,alpha_ssp,alpha_err_ssp))

            #generating the dataframe and adding the data
            df_ssp_param = pd.DataFrame(ssp_param_array, columns = ssp_param_id)

            #writing to a file
            df_ssp_param.to_csv(ssp_param_file, index= True, sep=' ')



        #5) Line(s) fitting
        if (line_fitting == True and cat_band_fit == True):
            fit_file = result_line_fitting_dir+'/'+spectra_list_name+'_fit_data_' +timestamp + '.dat'
            fit_id = ['#Spectrum', 'ca1_wave', 'ca2_wave', 'ca3_wave', 'dw_ca1', 'dw_ca2','dw_ca3', 'ew_ca1','ew_ca2','ew_ca3']

            ca1_wave = np.zeros(spectra_number)
            ca2_wave = np.zeros(spectra_number)
            ca3_wave = np.zeros(spectra_number)
            dw_ca1 = np.zeros(spectra_number)
            dw_ca2 = np.zeros(spectra_number)
            dw_ca3 = np.zeros(spectra_number)
            ew_ca1 = np.zeros(spectra_number)
            ew_ca2 = np.zeros(spectra_number)
            ew_ca3 = np.zeros(spectra_number)

            fit_data_array = np.column_stack((spec_names_nopath, ca1_wave,ca2_wave,ca3_wave,dw_ca1,dw_ca2,dw_ca3,ew_ca1,ew_ca2,ew_ca3))

            #generating the dataframe and adding the data
            df_fit = pd.DataFrame(fit_data_array, columns = fit_id)

            #writing to a file
            df_fit.to_csv(fit_file, index= True, sep=' ')

        #5-bis) Line fitting 2
        if (line_fitting == True and cat_band_fit == False):
            fit_file = result_line_fitting_dir+'/'+spectra_list_name+'_fit_data_' +timestamp + '.dat'
            fit_id = ['#Spectrum', 'line_wave']
            fit_values = np.zeros(spectra_number)
            fit_data_array = np.column_stack((spec_names_nopath, fit_values))

            #generating the dataframe and adding the data
            df_fit = pd.DataFrame(fit_data_array, columns = fit_id)

            #writing to a file
            df_fit.to_csv(fit_file, index= True, sep=' ')


        #6) kinematics with ppxf
        if (perform_kinematics == True):
            kin_file = result_ppxf_kin_data_dir+'/'+spectra_list_name+'_kin_data_' +timestamp + '.dat'
            kin_id = ['#Spectrum', 'RV(km/s)', 'Sigma(km/s)', 'H3', 'H4', 'errRV','errSigma', 'errH3','errH4']

            rv_kin = np.zeros(spectra_number)
            sigma_kin = np.zeros(spectra_number)
            h3_kin = np.zeros(spectra_number)
            h4_kin = np.zeros(spectra_number)
            err_rv_kin = np.zeros(spectra_number)
            err_sigma_kin = np.zeros(spectra_number)
            err_h3_kin = np.zeros(spectra_number)
            err_h4_kin = np.zeros(spectra_number)

            kin_data_array = np.column_stack((spec_names_nopath, rv_kin,sigma_kin,h3_kin,h4_kin,err_rv_kin,err_sigma_kin,err_h3_kin,err_h4_kin))


            #generating the dataframe and adding the data
            df_kin = pd.DataFrame(kin_data_array, columns = kin_id)

            #writing to a file
            df_kin.to_csv(kin_file, index= True, sep=' ')


        #7) Stellar populations with ppxf
        if (stellar_pop == True):
            pop_file = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_pop_data_' +timestamp + '.dat'
            pop_id = ['#Spectrum', 'RV(km/s)', 'Sigma(km/s)', 'H3', 'H4', 'lum_age(Gyr)','lum_met(dex)', 'err_lum_age(Gyr)', 'err_lum_met(dex)', 'M/L', 'mass_age(Gyr)', 'mass_met(dex)', 'err_mass_age(Gyr)', 'err_mass_met(dex)', 'Chi2']

            rv_pop = np.zeros(spectra_number)
            sigma_pop = np.zeros(spectra_number)
            h3_pop = np.zeros(spectra_number)
            h4_pop = np.zeros(spectra_number)
            age_pop = np.zeros(spectra_number)
            met_pop = np.zeros(spectra_number)
            mass_age_pop = np.zeros(spectra_number)
            mass_met_pop = np.zeros(spectra_number)
            ml_pop = np.zeros(spectra_number)
            chi2_pop = np.zeros(spectra_number)
            err_age_pop = np.zeros(spectra_number)
            err_met_pop = np.zeros(spectra_number)
            err_mass_age_pop = np.zeros(spectra_number)
            err_mass_met_pop = np.zeros(spectra_number)

            pop_data_array = np.column_stack((spec_names_nopath, rv_pop,sigma_pop,h3_pop,h4_pop,age_pop,met_pop,ml_pop, mass_age_pop, mass_met_pop,chi2_pop, err_age_pop, err_met_pop,err_mass_age_pop,err_mass_met_pop))


            #generating the dataframe and adding the data
            df_pop = pd.DataFrame(pop_data_array, columns = pop_id)

            #writing to a file
            df_pop.to_csv(pop_file, index= True, sep=' ')

























#***********************************************************************************************
#***********************************************************************************************
# *************************** cycle for all the spectra! ***************************************
        for i in range(spectra_number):

            print (spec_names_nopath[i])

            # 1) READ THE SPECTRA
            wavelength, flux, original_step, obj_name = span.read_spec(spec_names[i], lambda_units)
            wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

            #**************** spectra pre-processing

            try:
                original_wavelength = wavelength
                original_flux = flux
            except:
                print ('Something went wrong')


        # 1) CROPPING
            if cropping_spectrum == True:
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('*** Cropping task ***')
                cropping_range = np.array([cropping_low_wave,cropping_high_wave])
                cropped_wavelength, cropped_flux = span.crop_spec(wavelength, flux, cropping_range)

                if len(cropped_wavelength)>10:
                    wavelength =  cropped_wavelength
                    flux = cropped_flux
                else:
                    print ('WARNING: The crop window is not in the spectral range. Skypping...')


                try:
                    if save_intermediate_files == True :
                        file_cropped = result_spec+'crop_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_cropped, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_cropped)
                        print('')
                except ValueError:
                    print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                    #continue

                if save_plot == True:
                    plt.plot
                    #sigma_title = str(round(sigma,1))
                    plt.title('Cropped ' + spec_names_nopath[i])
                    plt.plot(original_wavelength, original_flux, label = 'Original')
                    plt.plot(wavelength, flux, label = 'Cropped')
                    plt.xlabel('Wavelength (nm)')
                    plt.ylabel('Flux')
                    plt.legend(fontsize = 10)

                    plt.savefig(result_plot_dir + '/'+ 'cropped_' + spec_names_nopath[i] + '.eps', format='eps', dpi=300)
                    plt.close()

                #putting the NEW limit range of the spectra
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])



            # 2) DYNAMIC CLEANING
            if sigma_clipping == True and sigma_clip_have_file == False:
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running sigma clipping task...')

                clip_wavelength, clip_flux = span.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution, sigma_clip_single_value)

                #original_flux = flux
                #original_wavelength = wavelength

                wavelength = clip_wavelength
                flux = clip_flux

                #writing file
                try:
                    if (save_intermediate_files == True):
                        file_clipped = result_spec+'clip_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_clipped, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_clipped)
                        print('')
                except ValueError:
                    print ('Something went wrong with the spectrum. Tip: it is really a spectrum or a SED? Skipping...')
                    #continue

                if save_plot == True:
                    plt.plot
                    #sigma_title = str(round(sigma,1))
                    plt.title('cleaned ' + spec_names_nopath[i])
                    plt.plot(original_wavelength, original_flux, label = 'Original')
                    plt.plot(wavelength, flux, label = 'Cleaned')
                    plt.xlabel('Wavelength (nm)')
                    plt.ylabel('Flux')
                    plt.legend(fontsize = 10)

                    plt.savefig(result_plot_dir + '/'+ 'cleaned_' + spec_names_nopath[i] + '.eps', format='eps', dpi=300)
                    plt.close()

            elif (sigma_clipping == True and sigma_clip_have_file == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running sigma clipping task...')

                if i == 0:
                    cond_clip = (os.path.isfile(sigma_clip_sigma_file))

                if cond_clip == False:
                    if i == 0:
                        sg.popup('The sigma clip file does not exist. I will skip it...')
                    continue


                #check if the data in the file are ok
                if i == 0:
                    bad_file = 0
                    try:
                        sigma_clip_resolution = np.loadtxt(sigma_clip_sigma_file, usecols =[1])
                        sigma_clip_vel_value = np.loadtxt(sigma_clip_sigma_file, usecols =[2])
                    except ValueError:
                        bad_file = 1

                #if they are NOT ok
                if bad_file == 1:
                    if i == 0:
                        sg.popup ('Input sigma clip data file not valid!')
                    continue

                #check the length of the file
                if len(sigma_clip_vel_value) != spectra_number:
                    if i == 0:
                        sg.popup ('The sigma clip file does not have the same length of the spectra list file')
                    continue

                #doing the calculation only if the file is ok
                if bad_file == 0:

                    clip_wavelength, clip_flux = span.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution[i], sigma_clip_vel_value[i])

                    #original_flux = flux
                    #original_wavelength = wavelength

                    wavelength = clip_wavelength
                    flux = clip_flux

                    #writing file
                    try:
                        if (save_intermediate_files == True):
                            file_clipped = result_spec+'clip_' + spec_names_nopath[i] + '.dat'
                            np.savetxt(file_clipped, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                            print ('File saved: ', file_clipped)
                            print('')
                    except ValueError:
                        print ('Something went wrong with the spectrum. Tip: it is really a spectrum or a SED? Skipping...')
                        continue

                    if save_plot == True:
                        plt.plot
                        plt.title('cleaned ' + spec_names_nopath[i])
                        plt.plot(original_wavelength, original_flux, label = 'Original')
                        plt.plot(wavelength, flux, label = 'Cleaned')
                        plt.xlabel('Wavelength (nm)')
                        plt.ylabel('Flux')
                        plt.legend(fontsize = 10)

                        plt.savefig(result_plot_dir + '/'+ 'cleaned_' + spec_names_nopath[i] + '.eps', format='eps', dpi=300)
                        plt.close()



            # 3) WAVELET CLEANING
            if wavelet_cleaning == True:
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('*** Wavelet denoise task ***')

                denoised_flux = span.wavelet_cleaning(wavelength, flux, sigma_wavelets, wavelets_layers)
                #original_flux = flux
                flux = denoised_flux
                try:
                    if save_intermediate_files == True :
                        file_wavelet = result_spec+'wavelet_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_wavelet, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_wavelet)
                        print('')
                except ValueError:
                    print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')

                if save_plot == True:
                    plt.plot
                    plt.title('wavelet_cleaned_ ' + spec_names_nopath[i])
                    plt.plot(original_wavelength, original_flux, label = 'Original')
                    plt.plot(wavelength, flux, label = 'Cleaned')
                    plt.xlabel('Wavelength (nm)')
                    plt.ylabel('Flux')
                    plt.legend(fontsize = 10)

                    plt.savefig(result_plot_dir + '/'+ 'wavelet_cleaned_' + spec_names_nopath[i] + '.eps', format='eps', dpi=300)
                    plt.close()
                #continue



            # 4) FILTERING AND DENOISING
            if (filter_denoise == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running denoising task')

                if moving_average == True and box_moving_avg == True:
                    denoised_flux = span.mov_avg(flux, box_moving_avg_size)
                    flux = denoised_flux
                if moving_average == True and gauss_moving_avg == True:
                    denoised_flux = span.mov_avg_gauss(wavelength, flux, gauss_moving_avg_kernel)
                    flux = denoised_flux
                if low_pass_filter == True:
                    denoised_flux = span.lowpass(wavelength, flux, lowpass_cut_off, lowpass_order)
                    flux = denoised_flux
                if bandpass_filter == True:
                    denoised_flux = span.bandpass(wavelength, flux, bandpass_lower_cut_off, bandpass_upper_cut_off, bandpass_order)
                    flux = denoised_flux

                if event == 'Process selected' and save_intermediate_files == True:
                    #denoised_suffix = str(int(round(box_moving_avg_size)))
                    file_mov_avg = result_spec+'denoised_' + prev_spec_nopath + '.dat'
                    np.savetxt(file_mov_avg, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_mov_avg)
                    print('')


                if (save_intermediate_files == True):
                    #mov_avg_suffix = str(int(round(window_size)))
                    file_denoised = result_spec+'denoised_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_denoised, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_denoised)
                    print('')



            # 5) DOPPLER CORRECTION
            #dopcor, for process all
            if (dop_cor == True and dop_cor_single_shot == False):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running doppler correction task...')

                #test if file file exist
                if i == 0:
                    cond = (os.path.isfile(dop_cor_file))
                if cond == False:
                    if i == 0:
                        sg.popup('The doppler correction file does not exist. I will skip it...')
                    continue

                #check if the data in the file are ok
                if i == 0:
                    bad_file = 0
                    try:
                        dopcor_values = np.loadtxt(dop_cor_file, usecols=[1])
                    except ValueError:
                        bad_file = 1

                #if they are not ok:
                if bad_file == 1:
                    if i == 0:
                        sg.popup ('Input dopcor data file not valid!')
                    continue

                #check on the length of the file
                if len(dopcor_values) != spectra_number:
                    if i == 0:
                        sg.popup ('The dopcor file does not have the same length of the spectra list file')
                    continue

                #doing the calculation only if the file is ok
                if bad_file == 0:
                    dopcor_wave, dopcor_flux = span.dopcor(wavelength, flux, dopcor_values[i])
                    wavelength = dopcor_wave
                    flux = dopcor_flux
                    #output to see if the names and values match
                    print(spec_names_nopath[i], dopcor_values[i])

                    #writing to file
                    if (save_intermediate_files == True):
                        file_dopcor = result_spec+'dopcor_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_dopcor, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_dopcor)
                        print('')

                #putting the NEW limit range of the spectra
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

            #to calculate also with just one value
            elif(dop_cor == True and dop_cor_single_shot == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running doppler correction task...')
                dopcor_wave, dopcor_flux = span.dopcor(wavelength, flux, dop_cor_single_shot_vel)
                wavelength = dopcor_wave
                flux = dopcor_flux
                #output to see if the names and values match
                print(spec_names_nopath[i], dop_cor_single_shot_vel)

                #writing to file
                if (save_intermediate_files == True):
                    file_dopcor = result_spec+'dopcor_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_dopcor, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_dopcor)
                    print('')

                #putting the NEW limit range of the spectra
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])



            # 6) HELIOCENTRIC CORRECTION
            if (helio_corr == True and helio_single_shot == False):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running heliocentric correction task...')

                #test if file file exist
                if i == 0:
                    cond2 = (os.path.isfile(helio_file))
                if cond2 == False:
                    if i == 0:
                        sg.popup('The heliocentric file correction does not exist. I will skip it...')
                    continue

                #load the file
                #the string part
                if cond2 == True:
                    location, date = np.loadtxt(helio_file, dtype = 'str', usecols=[0,1]).T
                #the numbers
                if i == 0:
                    bad_file = 0
                    go_conditions = 0
                    try:
                        ra, dec = np.loadtxt(helio_file, usecols=[2,3]).T
                    except ValueError:
                        bad_file = 1

                if bad_file == 1:
                    if i == 0:
                        sg.popup ('Input data not valid!')
                    continue


                #Checking if the loaded data are ok. Canoot do before because otherwise the control will be performed even when I don't press the correct button
                if  i == 0:
                    coord_not_valid = 0
                    date_not_valid  = 0
                    location_not_valid = 0

                    for s in range(len(location)):
                        try:
                            datetime.datetime.strptime(date[s], '%Y-%m-%d')
                        except ValueError:
                            date_not_valid = 1
                            continue
                        try:
                            location_test = EarthLocation.of_site(location[s])
                        except Exception:
                            location_not_valid = 1
                            continue

                if (date_not_valid == 1 or location_not_valid == 1):
                    if i == 0:
                        sg.popup ('Data in the heliocentric file is not valid. Please check!')
                    continue

                #check on the length of the file
                if len(location) != spectra_number:
                    if i == 0:
                        sg.popup ('The helio file does not have the same length of the spectra file')
                    continue

                if i == 0:
                    go_conditions = bad_file+date_not_valid+location_not_valid

                if go_conditions == 0:
                    correction, new_wavelength, new_flux = span.helio_corr(wavelength, flux, date[i], location[i], ra[i], dec[i])
                    wavelength = new_wavelength
                    flux = new_flux

                    #putting the NEW limit range of the spectra
                    wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                    #output
                    print (spec_names_nopath[i], date[i], location[i], ra[i],dec[i], correction, 'km/s')
                    print ('')

                    #writing to a file
                    if (save_intermediate_files == True):
                        file_heliocorr = result_spec+'heliocorr_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_heliocorr, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_heliocorr)
                        print('')

            elif(helio_corr == True and helio_single_shot == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running heliocentric correction task...')

                correction, new_wavelength, new_flux = span.helio_corr(wavelength, flux, helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj)
                wavelength = new_wavelength
                flux = new_flux
                #output
                print (spec_names_nopath[i], helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj, correction, 'km/s')
                print ('')

                #putting the NEW limit range of the spectra
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                #writing to a file
                if (save_intermediate_files == True):
                    file_heliocorr = result_spec+'heliocorr_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_heliocorr, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_heliocorr)
                    print('')





#************************************** SPECTRA PROCESSING *************************

            # 1) REBIN
                #a) linear
            if rebinning == True and rebinning_linear == True:
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running rebin linear task...')

                rebinned_wave, rebinned_flux, npoints = span.resample(wavelength, flux, usr_step_linear)
                wavelength = rebinned_wave
                flux = rebinned_flux

                #writing file
                if (save_intermediate_files == True):
                    file_rebinned = result_spec+'rebin_lin_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_rebinned, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_rebinned)
                    print('')

                #b) log
            if (rebinning == True and rebinning_log == True):
                task_done2 = 1
                task_spec2 = 1

                if i == 0:
                    print ('Running log rebin task...')

                rebinned_wave_log, rebinned_flux_log = span.log_rebin(wavelength, flux, usr_step_log)
                wavelength = rebinned_wave_log
                flux = rebinned_flux_log

                #writing file
                if (save_intermediate_files == True):
                    file_rebinned_log = result_spec+'rebin_log_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_rebinned_log, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_rebinned_log)
                    print('')



            # 2) DEGRADE RESOLUTION
                #a) DEGRADE FROM R TO R
            if degrade == True and is_initial_res_r == True and res_degrade_to_r == True:

                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running degrade resolution task...')

                degraded_wave, degraded_flux = span.degrade(wavelength, flux, initial_res_r, final_res_r, True)
                wavelength = degraded_wave
                flux = degraded_flux

                if save_intermediate_files == True:
                    degraded_res = str(int(round(final_res_r)))
                    file_degraded = result_spec+'degraded_R' + degraded_res + '_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_degraded, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_degraded)
                    print('')


                #b) DEGRADE FROM R TO FWHM
            if degrade == True and is_initial_res_r == True and res_degrade_to_fwhm == True:
                task_done2 = 1
                task_spec2 = 1

                if i == 0:
                    print ('Running degrade resolution task...')

                degraded_wave, degraded_flux = span.degradeRtoFWHM(wavelength, flux, initial_res_r, final_res_r_to_fwhm)
                wavelength = degraded_wave
                flux = degraded_flux

                if save_intermediate_files == True:
                    degraded_res_R_to_FWHM = str(float(round(final_res_r_to_fwhm,1)))
                    file_degraded_R_to_FWHM = result_spec+'degraded_FWHM' + degraded_res_R_to_FWHM + '_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_degraded_R_to_FWHM, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_degraded_R_to_FWHM)
                    print('')


                #c) DEGRADE FROM FWHM TO FWHM
            if degrade == True and is_initial_res_fwhm == True:

                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running degrade resolution in lambda task...')

                degraded_wave, degraded_flux = span.degrade_lambda(wavelength, flux, initial_res_fwhm, final_res_fwhm)
                #update the variables. necessary because I will use always wavelength and flux for the other functions!
                wavelength = degraded_wave
                flux = degraded_flux

                if save_intermediate_files == True:
                    degraded_res_lambda = str(float(round(final_res_fwhm,1)))
                    file_degraded_lambda = result_spec+'degraded_FWHM' + degraded_res_lambda + '_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_degraded_lambda, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_degraded_lambda)
                    print('')



            # 3) NORMALISE SPECTRUM TO
            if normalize_wave == True:
                task_done2 = 1
                task_spec2 = 1
                            #check the limits
                if (norm_lambda < wave_limits[0] or norm_lambda > wave_limits[1]):
                    print('Normalisation wavelength exceeds the range of the spectrum! Skipping')
                    #continue
                else:
                    if i == 0:
                        print ('Running normalise task...')

                    step = wavelength[1]-wavelength[0]
                    epsilon_norm = step*10. #averaging on 10 steps values, rather than one value
                    norm_flux = span.norm_spec(wavelength, flux, norm_lambda, epsilon_norm, flux)
                    flux = norm_flux

                    if (save_intermediate_files == True):
                        norm_suffix = str(norm_lambda)
                        file_normalized = result_spec+'norm' + norm_suffix + '_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_normalized, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_normalized)
                        print('')



            # 4) SIGMA BROADENING
            if (sigma_broad == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running sigma broadening task...')

                broadened_flux = span.sigma_broad(wavelength, flux, sigma_value)
                flux = broadened_flux

                if (save_intermediate_files == True):
                    broad_suffix = str(int(round(sigma_value)))
                    file_broad = result_spec+'broad' + broad_suffix + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_broad, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_broad)
                    print('')



            # 5) ADD NOISE
            if (add_noise == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running add noise task...')

                noisy_flux = span.add_noise(wavelength, flux, noise)
                flux = noisy_flux

                if (save_intermediate_files == True):
                    noise_suffix = str(int(round(noise)))
                    file_noise = result_spec+'SNR' + noise_suffix +'_'+ spec_names_nopath[i] + '.dat'
                    np.savetxt(file_noise, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_noise)
                    print('')



            # 6) CONTINUUM MODELLING
            if continuum_sub == True:
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running continuum subtraction task...')

                if cont_model_filtering == True:
                    #print (cont_math_operation)
                    corrected_flux, continuum_flux = span.sub_cont(wavelength, flux, cont_math_operation)

                if cont_model_poly == True:
                    corrected_flux, continuum_flux = span.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, False)

                flux = corrected_flux

                if (save_intermediate_files == True):
                    file_cont_sub = result_spec+'cont_sub_' + spec_names_nopath[i] + '.dat'
                    file_cont = result_spec+'cont_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_cont_sub, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    np.savetxt(file_cont, np.column_stack([wavelength, continuum_flux]), header="wavelength \t flux")
                    print ('File saved: ', file_cont_sub)
                    print ('File saved: ', file_cont)
                    print('')




#******************************************* SPEC MATH ********************************************

            if do_nothing == False or use_for_spec_an == True:
                if i == 0:
                    sg.popup('Mean and sum of all the spectra require click on process selected')
                continue

            # 1) subtract normalized average
            if (subtract_normalized_avg == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running subtract normalised average task...')

                subtracted_flux = span.sub_norm_avg(wavelength, flux, lambda_units, spectra_number, spec_names)
                flux = subtracted_flux

                if (save_intermediate_files == True):
                    file_subtracted_avg = result_spec+'subtracted_average' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_subtracted_avg, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_subtracted_avg)
                    print('')


            # 2) subtract normalized single
            if (subtract_normalized_spec == True):
                task_done2 = 1
                task_spec2 = 1

                #test if file file exist
                cond000 = (os.path.isfile(spectra_to_subtract))
                if cond000 == False:
                    if i == 0:
                        sg.popup('The file to subtract does not exist. Skipping...')
                    #continue

                if cond000 == True:
                    if i == 0:
                        print ('Running subtract normalised spectrum task...')

                    subtracted_single_flux = span.sub_norm_single(wavelength, flux, spectra_to_subtract, lambda_units)
                    flux = subtracted_single_flux

                    if (save_intermediate_files == True):
                        file_subtracted_single = result_spec+'subtracted_single' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_subtracted_single, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                        print ('File saved: ', file_subtracted_single)
                        print('')


            # 3) add pedestal
            if (add_pedestal == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running add pedestal task...')

                flux = flux + constant_pedestal

                if (save_intermediate_files == True):
                    pedestal_suffix = str(int(round(constant_pedestal)))
                    file_pedestal = result_spec+'pedestal' + pedestal_suffix + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_pedestal, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_pedestal)
                    print('')


            # 4) multiply by a constant
            if (multiply == True):
                task_done2 = 1
                task_spec2 = 1
                if i == 0:
                    print ('Running add pedestal task...')

                flux = flux*multiply_constant

                if (save_intermediate_files == True):
                    multiplied_suffix = str(int(round(multiply_constant)))
                    file_multiplied = result_spec+'multiplied' + multiplied_suffix + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_multiplied, np.column_stack([wavelength, flux]), header="wavelength \t flux")
                    print ('File saved: ', file_multiplied)
                    print('')










#************************************** SPECTRAL ANALYSIS ********************************

            #1) BLACKBODY FITTING
            if (bb_fit == True):
                task_done2 = 1
                #task_analysis = 1
                #store the spectrum in temp variables
                wavelength_temp = wavelength
                flux_temp = flux

                if wave1_bb >= wave2_bb:
                    print ('Like I said, the first wavelength cannot be greater than the second!')
                    #continue

                #check the limits
                elif (wave1_bb < wave_limits[0] or wave2_bb > wave_limits[1]):
                    print ('Wavelength interval for blackbody fitting exceeds the range of the spectrum!')
                    #continue
                else:
                    if i == 0:
                        print ('Running blackbody fitting ')

                    temperature_bb, residual_bb = span.blackbody_fit(wavelength, flux, wave1_bb, wave2_bb, t_guess, False)
                    print ('Best Black body temperature: ', temperature_bb, ' K')
                    print ('')

                    df_bb.at[i, 'T(K)']= temperature_bb
                    df_bb.to_csv(bb_file, index= False, sep=' ')

                    if i == (spectra_number-1):
                        print ('File saved: ', bb_file)
                        print('')



            # 2) CROSS-CORRELATION
            if (cross_corr == True):
                task_done2 = 1
                cond11 = (os.path.isfile(template_crosscorr))
                #storing the spectrum in temp variables
                wavelength_temp = wavelength
                flux_temp = flux
                if cond11 == False:
                    if i == 0:
                        sg.popup('The template file does not exist. Skipping...')
                    #continue

                if cond11 == True:
                    if i == 0:
                        print ('Running cross-correlation task...')

                        #reading the template for the check
                        wave_temp_xcorr, flux_temp_xcorr, step_temp_xcorr, name_temp_xcorr = span.read_spec(template_crosscorr, lambda_units_template_crosscorr)
                        wave_limits_template_xcorr = np.array([wave_temp_xcorr[0], wave_temp_xcorr[len(wave_temp_xcorr)-1]])

                    #check the limits
                    if (real_low_wave_corr < wave_limits[0] or real_high_wave_corr > wave_limits[1] or real_low_wave_corr < wave_limits_template_xcorr[0] or real_high_wave_corr > wave_limits_template_xcorr[1]):
                        print('Wavelength interval for cross-correlation exceeds the range of the spectrum or the template! Skipping')
                        #continue
                    else:
                        print('Template: ', template_crosscorr)
                        rv, cc, rv_at_max, max_corr_fcn, wavelength_temp, flux_temp, wavelength_template_crosscorr, flux_template_crosscorr = span.crosscorr (wavelength_temp, flux_temp, template_crosscorr, lambda_units_template_crosscorr, wave_interval_corr, smooth_value_crosscorr, vel_interval_corr)

                        print ('Rv:', rv_at_max, 'km/s')

                        df_rv.at[i, 'RV(km/s)']= round(rv_at_max,1)
                        df_rv.to_csv(rv_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File saved: ', rv_file)
                            print('')


                        #plotting
                        if (save_plot == True):
                            rv_plot = str(round(rv_at_max,1))
                            fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (8.5,4.5))
                            fig.suptitle('Cross-correlation for ' + spec_names_nopath[i] + ' with ' + template_crosscorr)
                            ax1.plot(rv, cc)
                            ax1.plot(rv_at_max, max_corr_fcn, 'ro', label = 'RV: ' + rv_plot + 'km/s')
                            ax1.set_xlabel('RV (km/s)')
                            ax1.set_ylabel('Xcorr fcn')
                            ax1.legend(fontsize = 10)

                            ax2.plot(wavelength_temp, flux_temp, label = 'Spectrum')
                            ax2.plot(wavelength_template_crosscorr, flux_template_crosscorr, label = 'Template')
                            ax2.set_xlim(real_low_wave_corr, real_high_wave_corr)
                            ax2.set_ylim(0.4, 1.8)
                            ax2.set_xlabel('Wavelength (nm)')
                            ax2.set_ylabel('Norm flux')
                            ax2.legend(fontsize = 10)

                            plt.savefig(result_plot_dir + '/'+ 'Xcorr_' + spec_names_nopath[i] + '_' + '.eps', format='eps', dpi=100)
                            plt.close()



            # 3) VELOCITY DISPERSION
            if (sigma_measurement == True):
                task_done2 = 1
                cond22 = (os.path.isfile(template_sigma))
                if cond22 == False:
                    if i == 0:
                        sg.popup('The template file does not exist. Skipping...')
                    #continue

                if cond22 == True:
                    if i == 0:
                        print ('Running sigma measurement task. This might take a while...')
                                    #reading the template for the check
                        wave_temp_sigma, flux_temp_sigma, step_temp_sigma, name_temp_sigma = span.read_spec(template_sigma, lambda_units_template_sigma)
                        wave_limits_template_sigma = np.array([wave_temp_sigma[0], wave_temp_sigma[len(wave_temp_sigma)-1]])
                        sigma_band_problem = 0
                        if band_sigma[0] > band_sigma[1] or cont_sigma[0] > cont_sigma[1]:
                            if i == 0:
                                sg.popup('It seems we have a problem. Did you invert the wavelength range?')
                                sigma_band_problem = 1
                            #continue

                    if sigma_band_problem == 0:
                        #check the limits, for the spectrum and the template
                        if ((band_sigma[0] < wave_limits[0] or cont_sigma[0] < wave_limits[0] or band_sigma[1]> wave_limits[1] or cont_sigma[1] > wave_limits[1] or band_sigma[0] < wave_limits_template_sigma[0] or cont_sigma[0] < wave_limits_template_sigma[0] or band_sigma[1]> wave_limits_template_sigma[1] or cont_sigma[1] > wave_limits_template_sigma[1])):
                            print('Wavelength interval for the band is out the range of the spectrum! Skipping')
                            #continue
                        else:
                            print('Template: ', template_sigma)
                            sigma, error, chisqr, band_wave, band_flux, band_flux_template_fitted, sigma_instrumental = span.sigma_measurement(wavelength, flux, template_sigma, lambda_units_template_sigma, resolution_spec, resolution_template, band_sigma, cont_sigma, True)
                            print ('Sigma: ', sigma, '+/-', round(error,2), '    Chi Square: ', chisqr)

                            #writing to the file
                            df_sigma.at[i, 'Sigma(km/s)']= round(sigma,1)
                            df_sigma.at[i, 'err']= round(error,1)
                            df_sigma.to_csv(sigma_file, index= False, sep=' ')

                            if i == (spectra_number-1):
                                print ('File saved: ', sigma_file)
                                print('')


                            #Nuovo: plotting
                            if(save_plot == True):

                                sigma_title = str(round(sigma,1))
                                fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                                fig.suptitle(spec_names_nopath[i] + '  Sigma:' + sigma_title + 'km/s')
                                ax1.plot(band_wave, band_flux, label = 'Spectrum')
                                ax1.plot(band_wave, band_flux_template_fitted, label = 'Fitted template')
                                ax1.set_xlabel('Wavelength (nm)')
                                ax1.set_ylabel('Norm flux')
                                ax1.legend(fontsize = 10)

                                #plot residui
                                ax2.plot(band_wave, band_flux-band_flux_template_fitted, linewidth=0.5, label = 'Residuals')
                                ax2.hlines(y=0, xmin=min(band_wave), xmax=max(band_wave), linestyles='--', lw=2, linewidth=2, color='r')
                                ax2.set_xlabel('Wavelength (nm)')
                                ax2.set_ylabel('Residuals')
                                ax2.legend(fontsize = 10)

                                plt.savefig(result_plot_dir + '/'+ 'sigma_vel_' + spec_names_nopath[i] + '.eps', format='eps', dpi=100)
                                plt.close()



            # 4) EQUIVALENT WIDTH (EW)
                #a) If I want to measure just one index
            if (ew_measurement == True and single_index == True):
                task_done2 = 1
                if i == 0:
                    print ('Running equivalent width measurement task...')

                #checking limits
                if (np.min(index_usr) < wave_limits[0] or np.max(index_usr) > wave_limits[1]):
                    print ('The index definition wavelength exceeds the wavelength range of the spectrum. Skipping')
                    #continue

                #verify the index definition is in the correct sequence
                elif (index_usr[0] > index_usr[1] or index_usr[2] >index_usr[3] or index_usr[4] > index_usr[5]):
                    print('It seems we have a problem. Did you invert the wavelengths of the indices?')
                    #continue
                else:
                    idx, ew, err, snr_ew, ew_mag, err_mag = span.ew_measurement(wavelength, flux, index_usr, single_index, False, True, True, save_plot, spec_names_nopath[i], True)

                    print ('EW:', ew, '+/-', err)
                    print ('EW Mag', ew_mag, '+/-', err_mag)
                    print ('SNR: ', snr_ew, 'per pix')
                    print ('')

                    df_ew.at[i, 'ew(A)']= round(ew,4)
                    df_ew.at[i, 'err']= round(err,4)
                    df_ew.to_csv(ew_file, index= False, sep=' ')

                    err_mag= 0.434*abs(err/ew)
                    df_ew_mag.at[i, 'ew(Mag)']= round(ew_mag,4)
                    df_ew_mag.at[i, 'err']= round(err_mag,4)
                    df_ew_mag.to_csv(ew_file_mag, index= False, sep=' ')

                    df_snr_ew.at[i, 'SNR']= round(snr_ew,4)
                    df_snr_ew.to_csv(snr_ew_file, index= False, sep=' ')

                    if i == (spectra_number-1):
                        print ('File EW saved: ', ew_file)
                        print ('File EW in Mag saved: ', ew_file_mag)
                        print ('File SNR saved: ', snr_ew_file)
                        print('')

                #b) If I have an index list file
            if (ew_measurement == True and have_index_file == True):
                task_done2 = 1
                #the existence condition has been set before
                if i == 0:
                    print ('Running equivalent width measurement task...')

                #checking if the index file contains meaningful values
                check_condition = 0

                id_array, ew_array, err_array, snr_ew_array, ew_array_mag, err_array_mag = span.ew_measurement(wavelength, flux, index_file, single_index, False, True, True, save_plot, spec_names_nopath[i],True)

                if i == 0:
                    print ('Measuring indices:')
                    print (id_array)

                print ('Spectrum: ', spec_names_nopath[i])
                print ('EWs (A): ', ew_array)
                print ('EWs (Mag): ', ew_array_mag)
                print ('SNR: ', snr_ew_array, ' per pix')
                print('')

                #filling the file
                for k in range(num_indices):
                    df_ew.at[i,ew_id[k+len(spectra_id)]]= round(ew_array[k], 4)
                    df_ew.at[i,ew_id[k+num_indices+ len(spectra_id)]] = round(err_array[k],4)
                    df_ew.to_csv(ew_file, index= False, sep=' ')

                    df_ew_mag.at[i,ew_id_mag[k+len(spectra_id)]]= round(ew_array_mag[k], 4)
                    df_ew_mag.at[i,ew_id_mag[k+num_indices+ len(spectra_id)]] = round(err_array_mag[k],4)
                    df_ew_mag.to_csv(ew_file_mag, index= False, sep=' ')

                    df_snr_ew.at[i,snr_ew_id[k+len(spectra_id)]]= round(snr_ew_array[k], 4)
                    df_snr_ew.to_csv(snr_ew_file, index= False, sep=' ')
                if i == (spectra_number-1):
                    print ('File EW saved: ', ew_file)
                    print ('File EW in Mag saved: ', ew_file_mag)
                    print ('File SNR saved: ', snr_ew_file)
                    print('')


                #c) If I want to measure the Lick/IDS indices
            if (ew_measurement == True and lick_ew == True):
                task_done2 = 1

                if i == 0:
                    print ('Running equivalent width measurement task for Lick/IDS indices...')

                    ##TEST NEW LICK INDICES FOR FILE TO BE PASSED TO SSP MODELS
                    Hbeta = []
                    Hbetae = []
                    Mg2 = []
                    Mg2e = []
                    Mgb = []
                    Mgbe = []
                    Fe5270 = []
                    Fe5270e = []
                    Fe5335 = []
                    Fe5335e = []
                    #MgFee = []

                # 1) reading the Lick index file just once
                    lick_idx_names, lick_indices = span.read_idx(lick_index_file)
                    num_lick_indices = 19

                check_condition = 0
                lick_wavelength = wavelength
                lick_flux = flux

                blocking_cond = 0

                #checking limits of the spectra
                #wave limits of the spectrum
                lick_wave_limits = np.array([lick_wavelength[0], lick_wavelength[len(lick_wavelength)-1]])
                lick_wave_lower_limit = 420
                lick_wave_upper_limit = 630
                if ((lick_wave_limits[0] < lick_wave_lower_limit and lick_wave_limits[1]< lick_wave_lower_limit) or (lick_wave_limits[0] > lick_wave_upper_limit and lick_wave_limits[1]> lick_wave_upper_limit)):
                    print ('The window band is completely of the spectrum range')
                    blocking_cond = 1


                if blocking_cond == 0:
                    # 2) If I want to correct for the emission or doppler correction or sigma correction
                    if lick_correct_emission == True or dop_correction_lick == True or (correct_ew_sigma == True and radio_lick_sigma_auto == True):

                        #1 run ppxf to fit the emission and retrieve the emission corrected spectra
                        additive_degree_lick = -1
                        multiplicative_degree_lick = 10
                        epsilon_wavelength = 5
                        min_wavelength = np.min(wavelength)+epsilon_wavelength
                        max_wavelength = np.max(wavelength)-epsilon_wavelength

                        #since ppxf is time consuming, let's limit the wavelength interval to correct the emission
                        if max_wavelength > 650:
                            max_wavelength_lick = 650
                        else:
                            max_wavelength_lick = max_wavelength
                        if min_wavelength < 400:
                            min_wavelength_lick = 400
                        else:
                            min_wavelength_lick = min_wavelength

                        sigma_guess_lick = 100
                        #res_lick = 8.4
                        fit_components_lick = ('with_gas')
                        lick_ppxf_with_errors = False
                        lick_save_plot = False
                        regul_err_lick = 0.04

                        if lick_correct_emission == True:
                            print ('Removing the emission lines with ppxf...')
                        if dop_correction_lick == True:
                            print('Doppler correction with ppxf...')


                        # running ppxf with constant fwhm resolution and not
                        if lick_constant_fwhm == True:
                            kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, chi_square_lick, err_age_lick, err_met_lick, err_mass_age_lick, err_mass_met_lick, emission_corrected_flux = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, False, lick_ppxf_with_errors, lick_save_plot, 'none', regul_err_lick, additive_degree_lick, multiplicative_degree_lick, False, stellar_library_lick, 0)

                        #if I don't have a constant FWHM resolution:
                        if lick_constant_fwhm == False:
                            #considering a mean fwhm along the lick band. The errors for the indices used for stellar parameters are about 5%, so it's good for now.
                            mean_ref_lick_wavelength = 508
                            spec_lick_res_fwhm = mean_ref_lick_wavelength/spec_lick_res_r*10 #converting in A
                            kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, chi_square_lick, err_age_lick, err_met_lick, err_mass_age_lick, err_mass_met_lick, emission_corrected_flux = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, False, lick_ppxf_with_errors, lick_save_plot, 'none', regul_err_lick, additive_degree_lick, multiplicative_degree_lick, False, stellar_library_lick, 0)

                        #changing the spectrum to the emission corrected one
                        if lick_correct_emission == True:
                            lick_wavelength = bestfit_wave_lick/10
                            lick_flux = emission_corrected_flux
                            lick_step = lick_wavelength[1] - lick_wavelength[0]

                            #rebinning linear
                            lick_wavelength, lick_flux, npoint_resampled = span.resample(lick_wavelength, lick_flux, lick_step)


                        if dop_correction_lick == True: #CAUTION HERE: IF PPXF FINDS NO GAS COMPONENTS?

                            #rebinning linear if not done before
                            if lick_correct_emission == False:
                                lick_step = lick_wavelength[1] - lick_wavelength[0]
                                lick_wavelength, lick_flux, npoint_resampled = span.resample(lick_wavelength, lick_flux, lick_step)

                            lick_doppler_vel = (kinematics_lick[0])
                            dop_vel = lick_doppler_vel[0]
                            lick_wavelength, lick_flux = span.dopcor(lick_wavelength, lick_flux, dop_vel)

                        if radio_lick_sigma_auto == True:
                            sigma_lick_ppxf = (kinematics_lick[0])
                            sigma_to_correct_lick = sigma_lick_ppxf[1]

                    # 3) degrading the resolution, only if smaller than the lick system
                    if lick_constant_fwhm == True and spec_lick_res_fwhm < 8.4:
                        lick_degraded_wavelength, lick_degraded_flux = span.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_fwhm, lick_constant_fwhm)
                    elif lick_constant_fwhm == False and spec_lick_res_r > 600:
                        lick_degraded_wavelength, lick_degraded_flux = span.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_r, lick_constant_fwhm)
                    else:
                        print('WARNING: The resolution of the spectrum is smaller than the one needed for the Lick/IDS system. I will still calculate the Lick/IDS indices but the results might be inaccurate.')
                        lick_degraded_wavelength = lick_wavelength
                        lick_degraded_flux = lick_flux

                    # 4) Measuring the EW and doing plot
                    id_lick_array, ew_lick_array, err_lick_array, snr_lick_ew_array, ew_lick_array_mag, err_lick_array_mag = span.ew_measurement(lick_degraded_wavelength, lick_degraded_flux, lick_index_file, False, False, True, True, save_plot, spec_names_nopath[i], True)

                    if i == 0:
                        print ('Measuring Lick indices:')
                        print (id_lick_array)

                    print ('')
                    print ('Spectrum: ', spec_names_nopath[i])
                    print ('Raw EWs (A): ')
                    print (np.round(ew_lick_array, decimals = 3))
                    print ('Raw EWs (Mag): ')
                    print (np.round(ew_lick_array_mag, decimals = 3))
                    print ('SNR: ')
                    print (np.round(snr_lick_ew_array), ' per pix')
                    print('')

                    # 5) Correcting the EW for sigma
                    # a) Correcting the EWs for a single value
                    if correct_ew_sigma == True and radio_lick_sigma_single == True:
                        corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(ew_lick_array, err_lick_array, ew_lick_array_mag, sigma_lick_coeff_file, sigma_single_lick)

                        #updating the values:
                        ew_lick_array = corrected_lick_ew_array
                        err_lick_array = corrected_lick_err_array
                        ew_lick_array_mag = corrected_lick_ew_mag_array
                        err_lick_array_mag = corrected_lick_err_mag_array

                        print ('Corrected EWs for sigma:')
                        print (np.round(corrected_lick_ew_array, decimals = 3))
                        print ('Corrected uncertainties for sigma:')
                        print (np.round(corrected_lick_err_array, decimals = 3))

                    # b) Correcting the EWs for a list
                    if correct_ew_sigma == True and radio_lick_sigma_list == True:

                        # reading the sigma value file
                        if i == 0:
                            sigma_values = np.loadtxt(sigma_lick_file, usecols = [1])

                            #check if the length is the same of the spectra_number to correct
                            if len(sigma_values) != spectra_number:
                                sg.popup ('The sigma list file for Lick correction has a length different from the number of spectra you want to correct!')
                                #continue

                        if len(sigma_values) == spectra_number:
                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(ew_lick_array, err_lick_array, ew_lick_array_mag, sigma_lick_coeff_file, sigma_values[i])

                            #updating the values:
                            ew_lick_array = corrected_lick_ew_array
                            err_lick_array = corrected_lick_err_array
                            ew_lick_array_mag = corrected_lick_ew_mag_array
                            err_lick_array_mag = corrected_lick_err_mag_array

                    # c) Automatic correcting the EWs
                    if correct_ew_sigma == True and radio_lick_sigma_auto == True:
                        corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = span.corr_ew_lick(ew_lick_array, err_lick_array, ew_lick_array_mag, sigma_lick_coeff_file, sigma_to_correct_lick)

                        print ('Corrected EWs for sigma (A):')
                        print (np.round(corrected_lick_ew_array, decimals = 3))
                        print ('Corrected uncertainties for sigma')
                        print (np.round(corrected_lick_err_array, decimals = 3))
                        #print ('Corrected EWs for sigma (mag)', np.round(corrected_lick_ew_mag_array, decimals = 3))
                        #print ('Corrected mag Errors for sigma: ', np.round(corrected_lick_err_mag_array, decimals = 3))

                        #uodating the values
                        ew_lick_array = corrected_lick_ew_array
                        err_lick_array = corrected_lick_err_array
                        ew_lick_array_mag = corrected_lick_ew_mag_array
                        err_lick_array_mag = corrected_lick_err_mag_array

                    #d) If no sigma correction
                    if correct_ew_sigma == False:
                        err_lick_array_mag = 0.434*abs(err_lick_array/ew_lick_array)
                        err_lick_array_mag = np.nan_to_num(err_lick_array_mag, nan=0)

                    #filling the file
                    for k in range(num_lick_indices):
                        df_ew_lick.at[i,ew_lick_id[k+len(spectra_lick_id)]]= round(ew_lick_array[k], 4)
                        df_ew_lick.at[i,ew_lick_id[k+num_lick_indices+ len(spectra_lick_id)]] = round(err_lick_array[k],4)
                        df_ew_lick.to_csv(ew_lick_file, index= False, sep=' ')
                        df_ew_lick_mag.at[i,ew_lick_id_mag[k+len(spectra_lick_id)]]= round(ew_lick_array_mag[k], 4)
                        df_ew_lick_mag.at[i,ew_lick_id_mag[k+num_lick_indices+ len(spectra_lick_id)]] = round(err_lick_array_mag[k],4)
                        df_ew_lick_mag.to_csv(ew_lick_file_mag, index= False, sep=' ')
                        df_snr_lick_ew.at[i,snr_lick_ew_id[k+len(spectra_lick_id)]]= round(snr_lick_ew_array[k], 4)
                        df_snr_lick_ew.to_csv(snr_lick_ew_file, index= False, sep=' ')

                    #creating new indices to save in a file for SSP interpolation
                    Hbeta.append(ew_lick_array[0])
                    Hbetae.append(err_lick_array[0])
                    Mg2.append(ew_lick_array_mag[1])
                    Mg2e.append(err_lick_array_mag[1])
                    Mgb.append(ew_lick_array[2])
                    Mgbe.append(err_lick_array[2])
                    Fe5270.append(ew_lick_array[3])
                    Fe5270e.append(err_lick_array[3])
                    Fe5335.append(ew_lick_array[4])
                    Fe5335e.append(err_lick_array[4])

                    # interpolation with models
                    if stellar_parameters_lick == True:
                        if i == 0:
                            ssp_model = np.loadtxt(lick_ssp_model, delimiter=' ')

                            #assigning the names
                            age_teo, met_teo, alpha_teo, hb_teo, mg2_teo, mgb_teo, fe5270_teo, fe5335_teo, fem_teo, mgfe_teo = ssp_model.T

                        Hbeta_sp = ew_lick_array[0]
                        Hbetae_sp = err_lick_array[0]
                        Mg2_sp = ew_lick_array_mag[1]
                        Mg2e_sp= err_lick_array_mag[1]
                        Mgb_sp= ew_lick_array[2]
                        Mgbe_sp= err_lick_array[2]
                        Fe5270_sp=ew_lick_array[3]
                        Fe5270e_sp=err_lick_array[3]
                        Fe5335_sp=ew_lick_array[4]
                        Fe5335e_sp=err_lick_array[4]

                        Fem_sp = (Fe5270_sp+Fe5335_sp)/2
                        Feme_sp = np.sqrt((0.5*Fe5270e_sp)**2+(0.5*Fe5335e_sp)**2)
                        MgFe_sp = (np.sqrt(Mgb_sp*(0.72*Fe5270_sp+0.28*Fe5335_sp)))
                        MgFe_sp = np.nan_to_num(MgFe_sp, nan=0)
                        MgFee_sp = np.sqrt((((Fe5270_sp*18/25+Fe5335_sp*7/25)/(2*np.sqrt(Mgb_sp*(Fe5270_sp*18/25+Fe5335_sp*7/25))))*Mgbe_sp)**2+((Mgb_sp*18/25/(2*np.sqrt(Mgb_sp*(Fe5270_sp*18/25+Fe5335_sp*7/25))))*Fe5270e_sp)**2+((Mgb_sp*7/25/(2*np.sqrt(Mgb_sp*(Fe5270_sp*18/25+Fe5335_sp*7/25))))*Fe5335e_sp)**2)
                        MgFee_sp = np.nan_to_num(MgFee_sp, nan=0)

                        #points to interpolate
                        points_for_param = np.column_stack((Hbeta_sp, MgFe_sp, Fem_sp, Mgb_sp))

                        ## Interpolate
                        age_oss = griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), age_teo, points_for_param, method='linear')
                        met_oss = griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), met_teo, points_for_param, method='linear')
                        alpha_oss = griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), alpha_teo, points_for_param, method='linear')

                        # CALCULATING THE ERRORS WITH MONTECARLO SIMULATIONS
                        sim_number = 50

                        #define the arrays containing normal fluctuations of the EW of the indices with respect to their errors
                        Hbeta_sim_array = np.random.normal(loc=Hbeta_sp, scale=Hbetae_sp, size=sim_number)
                        MgFe_sim_array = np.random.normal(loc=MgFe_sp, scale=MgFee_sp, size=sim_number)
                        Fem_sim_array = np.random.normal(loc=Fem_sp, scale=Feme_sp, size=sim_number)
                        Mgb_sim_array = np.random.normal(loc=Mgb_sp, scale=Mgbe_sp, size=sim_number)

                        #preparing the arrays of the stellar population simulated parameters
                        age_sim = []
                        met_sim = []
                        alpha_sim = []

                        #doing the simulation
                        for g in range (sim_number):

                            #points to interpolate
                            points_for_param_sim = np.column_stack((Hbeta_sim_array[g], MgFe_sim_array[g], Fem_sim_array[g], Mgb_sim_array[g]))

                            # Interpolate
                            age_sim.append(griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), age_teo, points_for_param_sim, method='linear'))
                            met_sim.append(griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), met_teo, points_for_param_sim, method='linear'))
                            alpha_sim.append(griddata((hb_teo, mgfe_teo, fem_teo, mgb_teo), alpha_teo, points_for_param_sim, method='linear'))

                        #remove the nan
                        age_sim = [value for value in age_sim if not np.isnan(value)]
                        met_sim = [value for value in met_sim if not np.isnan(value)]
                        alpha_sim = [value for value in alpha_sim if not np.isnan(value)]

                        #finally calculating the std and associate that to the error in age, met and alpha
                        err_age = np.std(age_sim)
                        err_met = np.std(met_sim)
                        err_alpha = np.std(alpha_sim)

                        #assigning variables
                        age = age_oss[0]
                        met = met_oss[0]
                        alpha = alpha_oss[0]

                        print ('')
                        print ('Age (Gyr):', round(age,2), '+/-', round(err_age, 2))
                        print ('[Z/H] (dex):', round(met,2), '+/-', round(err_met, 2))
                        print ('Alpha (dex):', round(alpha,2), '+/-', round(err_alpha, 2))
                        print('')

                        #printing to file
                        df_ssp_param.at[i, 'age(Gyr)']= round(age,3)
                        df_ssp_param.at[i, 'err_age']= round(err_age,3)
                        df_ssp_param.at[i, 'met']= round(met,4)
                        df_ssp_param.at[i, 'err_met']= round(err_met,4)
                        df_ssp_param.at[i, 'alpha']= round(alpha,4)
                        df_ssp_param.at[i, 'err_alpha']= round(err_alpha,4)

                        #putting nans where needed
                        df_ssp_param.to_csv(ssp_param_file, na_rep='NaN', index= False, sep=' ')

                        #doing plot grid to show at the end
                        if i == 0:
                            Hbeta_plot = []
                            MgFe_plot = []
                            Fem_plot = []
                            Mgb_plot = []
                            Hbetae_plot = []
                            MgFee_plot = []
                            Feme_plot = []
                            Mgbe_plot = []
                            age_plot = []

                        Hbeta_plot.append(Hbeta_sp)
                        MgFe_plot.append(MgFe_sp)
                        Fem_plot.append(Fem_sp)
                        Mgb_plot.append(Mgb_sp)
                        Hbetae_plot.append(Hbetae_sp)
                        MgFee_plot.append(MgFee_sp)
                        Feme_plot.append(Feme_sp)
                        Mgbe_plot.append(Mgbe_sp)
                        age_plot.append(age)

                        if i == (spectra_number-1): #I build the grids
                            data = np.genfromtxt(lick_ssp_model, delimiter=' ', skip_header=True)

                            met_values = [-1.35, -0.33, 0, 0.35, 0.67]
                            age_values = [0.6, 0.8, 1, 2, 4, 10, 15]
                            alpha_values = [-0.3, 0, 0.3, 0.5]

                            #round to the closest value. Useful for the mgb-fem grid which strongly depends on age, so I need to fix that
                            #finding the mean age value:
                            age_plot = [value for value in age_plot if not np.isnan(value)]
                            age_mean = np.mean(age_plot)
                            age_closest_alpha_plot = age_values[np.abs(age_values-age_mean).argmin()]
                            print ('Mean age', age_mean)

                            plt.figure(figsize=(10, 6))

                            # age
                            plt.subplot(1, 2, 1)

                            alpha_value_grid = 0 # fixing a solar alpha enhancment for the mgfe-hbeta plot

                            for j in range(len(age_values)):
                                age_idx = np.where((data[:, 0] == age_values[j]) & (data[:, 2] == alpha_value_grid))[0]
                                plt.plot(data[age_idx, 9], data[age_idx, 3], color='black', linewidth=-1)
                                plt.text(data[age_idx[4], 9] + 0.1, data[age_idx[4], 3] + 0., f'{age_values[j]} Gyr', fontsize=10, color='darkgray')

                            # met
                            for h in range(len(met_values)):
                                met_idx = np.where((data[:, 1] == met_values[h]) & (data[:, 2] == alpha_value_grid))[0]
                                plt.plot(data[met_idx, 9], data[met_idx, 3], color='black', linewidth=1)
                                plt.text(data[met_idx[15], 9] - 0.1, data[met_idx[15], 3] - 0.25, f'{met_values[h]}', fontsize=10, color='darkgray')
                                if h == 0:
                                    plt.text(data[met_idx[15], 9] - 0.7, data[met_idx[15], 3] - 0.25, f'[Fe/H]=', fontsize=10, color='darkgray')

                            plt.xlabel("[MgFe]' (\u00c5)", fontsize=14)
                            plt.ylabel('H\u03B2 (\u00c5)', fontsize=14)
                            plt.tick_params(axis='both', which='both', direction='in', left=True, right=True, top=True, bottom=True)
                            plt.minorticks_on()
                            plt.gca().yaxis.set_minor_locator(MultipleLocator(0.2))
                            plt.gca().xaxis.set_minor_locator(MultipleLocator(0.25))
                            plt.xlim(0.4, 5.80)
                            plt.ylim(0.7, 5.3)
                            plt.xticks(fontsize=14)
                            plt.yticks(fontsize=14)

                        #plotting the values
                            plt.scatter(MgFe_plot, Hbeta_plot, color='red', s = 16)
                            plt.errorbar(MgFe_plot, Hbeta_plot, xerr=MgFee_plot, yerr=Hbetae_plot, linestyle='None', ecolor = 'black', capsize=2)

                            # alpha values, second plot
                            plt.subplot(1, 2, 2)
                            for t in range(len(alpha_values)):
                                alpha_idx = np.where((data[:, 2] == alpha_values[t]) & (data[:, 0] == age_closest_alpha_plot))[0]
                                plt.plot(data[alpha_idx, 5], data[alpha_idx, 8], color='black', linewidth=-1)
                                plt.text(data[alpha_idx[4], 5] - 0.5, data[alpha_idx[4], 8] + 0.05, f' [\u03B1/Fe]={alpha_values[t]}', fontsize=10,
                                        color='darkgray')

                            # some make-up to the plot
                            plt.minorticks_on()
                            plt.gca().yaxis.set_minor_locator(MultipleLocator(0.2))
                            plt.gca().xaxis.set_minor_locator(MultipleLocator(0.25))

                            plt.yticks(np.arange(1, 6), fontsize=14)
                            plt.xlabel('Mgb (\u00c5)', fontsize=14)
                            plt.ylabel('<Fe> (\u00c5)', fontsize=14)
                            plt.tick_params(axis='both', which='both', direction='in', left=True, right=True, top=True, bottom=True)
                            plt.xlim(0.4, 6.5)
                            plt.ylim(0.7, 5.3)
                            plt.xticks(fontsize=14)
                            plt.yticks(fontsize=14)

                            #plotting the value
                            plt.scatter(Mgb_plot, Fem_plot, color='red', s = 16)
                            plt.errorbar(Mgb_plot, Fem_plot, xerr=Mgbe_plot, yerr=Feme_plot, linestyle='None', ecolor = 'black', capsize=2)

                            plt.tight_layout()

                            if save_plot == True:
                                model_grids_file = result_plot_dir + '/'+ 'index_grids_' + spectra_list_name + '.png'
                                plt.savefig(model_grids_file, format='png', dpi=300) #I must save a png image because the eps file does not reproduce well the grids. Don't know why...
                                print ('Index-index diagrams for SSP models and data points saved in: ', model_grids_file)
                            plt.show()
                            plt.close()


                    if i == (spectra_number-1):
                        print ('File EW saved: ', ew_lick_file)
                        print ('File EW in Mag saved: ', ew_lick_file_mag)
                        print ('File SNR saved: ', snr_lick_ew_file)
                        if stellar_parameters_lick == True:
                            print ('File with the stellar parameters saved: ', ssp_param_file)

                else:
                    print('Nothing to show')



            #5) LINE(S) FITTING
                #a) CaT fitting
            if (line_fitting == True and cat_band_fit == True ):
                task_done2 = 1

                #checking limits
                if ( min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                    print ('The window band is out of the spectrum range')
                    #continue
                else:
                    #Performing the fitting of the CaT lines
                    cat_wave, cat_flux_norm, cat_fit, momentum = span.cat_fitting(wavelength,flux)

                    #finding the relative minima that will be the central CaT line wavelengths:
                    min_values_arg = argrelextrema(cat_fit, np.less)
                    min_values_arg_extracted = min_values_arg[0]

                    #if the fit fails a line:
                    try:
                        min_wave1 = round(cat_wave[min_values_arg_extracted[0]],1)
                    except IndexError:
                        min_wave1 = 0.
                    try:
                        min_wave2 = round(cat_wave[min_values_arg_extracted[1]],1)
                    except IndexError:
                        min_wave2 = 0.
                    try:
                        min_wave3 = round(cat_wave[min_values_arg_extracted[2]],1)
                    except IndexError:
                        min_wave3 = 0.
                    try:
                        min_flux1 = cat_fit[min_values_arg_extracted[0]]
                    except IndexError:
                        min_flux1 = 0.
                    try:
                        min_flux2 = cat_fit[min_values_arg_extracted[1]]
                    except IndexError:
                        min_flux2 = 0.
                    try:
                        min_flux3 = cat_fit[min_values_arg_extracted[2]]
                    except IndexError:
                        min_flux3 = 0.

                    #Differences in observed and calculated peaks
                    residual_wave1 = min_wave1-real_cat1
                    residual_wave2 = min_wave2-real_cat2
                    residual_wave3 = min_wave3-real_cat3

                    #converting the wavelength residuals in velocities
                    c = 299792.458
                    delta_rv1 = (residual_wave1/real_cat1)*c
                    delta_rv2 = (residual_wave2/real_cat2)*c
                    delta_rv3 = (residual_wave3/real_cat3)*c

                    #Assigning the sigma of the lines (in pixels)
                    sigma_cat1 = momentum[3]
                    sigma_cat2 = momentum[9]
                    sigma_cat3 = momentum[15]

                    #converting to velocities
                    sigma_cat1_vel = (sigma_cat1/min_wave1)*c
                    sigma_cat2_vel = (sigma_cat2/min_wave1)*c
                    sigma_cat3_vel = (sigma_cat3/min_wave1)*c

                    #residual spectrum
                    residual_flux = cat_flux_norm - cat_fit

                    #printing data from the fit
                    print ('Central wavelength of the fitted CaT lines (nm)')
                    print (min_wave1,min_wave2,min_wave3)
                    print ('Real central wavelength of the CaT lines (nm)')
                    print (real_cat1,real_cat2,real_cat3)
                    print ('Residuals (nm):')
                    print (residual_wave1,residual_wave2,residual_wave3)
                    print ('Residuals in km/s')
                    print (delta_rv1,delta_rv2,delta_rv3)
                    print ('Mean delta RV:')
                    print ((delta_rv1+delta_rv2+delta_rv3)/3)
                    print ('Sigma (nm)')
                    print (sigma_cat1, sigma_cat2, sigma_cat3)
                    print ('Sigma (km/s)')
                    print (sigma_cat1_vel,sigma_cat2_vel,sigma_cat3_vel)
                    print ('')


                    #EW measurement of the fitted lines
                    #ca1
                    id_array, ew_array_ca1, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(cat_wave, cat_fit, index_ca1, True, False, False, True, save_plot, spec_names_nopath[i],False)

                    #ca2
                    id_array, ew_array_ca2, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(cat_wave, cat_fit, index_ca2, True, False, False, True, save_plot, spec_names_nopath[i],False)

                    #ca3
                    id_array, ew_array_ca3, err_array, snr_ew_array,ew_array_mag, err_array_mag = span.ew_measurement(cat_wave, cat_fit, index_ca3, True, False, False, True, save_plot, spec_names_nopath[i],False)

                    #some infos
                    print ('Equivalent width from the fit (Ang):')
                    print ('Ca1  Ca2  Ca3')
                    print (round(ew_array_ca1,2), round(ew_array_ca2,2), round(ew_array_ca3,2))
                    print ('')

                    #writing values to the file
                    df_fit.at[i, 'ca1_wave']= round(min_wave1,2)
                    df_fit.at[i, 'ca2_wave']= round(min_wave2,2)
                    df_fit.at[i, 'ca3_wave']= round(min_wave3,2)
                    df_fit.at[i, 'dw_ca1']= round(residual_wave1,2)
                    df_fit.at[i, 'dw_ca2']= round(residual_wave2,2)
                    df_fit.at[i, 'dw_ca3']= round(residual_wave3,2)
                    df_fit.at[i, 'ew_ca1']= round(ew_array_ca1,2)
                    df_fit.at[i, 'ew_ca2']= round(ew_array_ca2,2)
                    df_fit.at[i, 'ew_ca3']= round(ew_array_ca3,2)

                    df_fit.to_csv(fit_file, index= False, sep=' ')

                    if i == (spectra_number-1):
                        print ('File saved: ', fit_file)
                        print('')

                    #Saving the fit plot
                    if (save_plot == True):

                        fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                        fig.suptitle('CaT lines fitting')
                        ax1.plot(cat_wave, cat_flux_norm, label = 'Spectrum')
                        ax1.plot(cat_wave, cat_fit, label = 'Fit line spec')
                        ax1.set_xlabel('Wavelength (nm)')
                        ax1.set_ylabel('Norm flux')
                        ax1.legend(fontsize = 10)

                        #plot residuals
                        ax2.plot(cat_wave, residual_flux, linewidth=0.5, label = 'Residuals')
                        ax2.hlines(y=0, xmin=min(cat_wave), xmax=max(cat_wave), linestyles='--', lw=2, linewidth=2, color='r')
                        ax2.set_xlabel('Wavelength (nm)')
                        ax2.set_ylabel('Residuals')
                        ax2.legend(fontsize = 10)

                        plt.savefig(result_plot_dir + '/'+ 'cat_fitting_' + spec_names_nopath[i] + '.eps', format='eps', dpi=100)
                        plt.close()


                # b) line fitting user line
            if (line_fitting == True and cat_band_fit == False):
                task_done2 = 1


                print ('*** Line fitting with combination of gaussian and a line for the slope ***')

                #check on the limits of the parameters
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                #checking limits
                if (min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                    print ('The window band is out of the spectrum range')
                    #continue

                else:
                    #Performing the fitting of the line
                    line_wave, line_flux_norm, line_fit, momentum = span.line_fitting (wavelength, flux, wave_interval_fit, guess_param)

                    #finding the minimum that will be the central CaT line wavelengths:
                    if emission_line == False:
                        min_value_wave_arg = np.argmin(line_fit)
                        min_wave = line_wave[min_value_wave_arg]

                    #if I have emission I calculate the maximum!
                    if emission_line == True:
                        min_value_wave_arg = np.argmax(line_fit)
                        min_wave = line_wave[min_value_wave_arg]

                    #Assigning the sigma of the lines (in pixels)
                    sigma_line = abs(momentum[3])

                    #converting to velocities
                    c = 299792.458
                    sigma_line_vel = (sigma_line/min_wave)*c

                    #residual spectrum
                    residual_flux = line_flux_norm - line_fit

                    #printing data from the fit
                    print ('Central wavelength of the fitted line (nm)')
                    print (min_wave)
                    print ('Sigma (nm)')
                    print (sigma_line)
                    print ('Sigma (km/s)')
                    print (sigma_line_vel)

                    #writing values to the file
                    df_fit.at[i, 'line_wave']= round(min_wave,2)
                    df_fit.to_csv(fit_file, index= False, sep=' ')

                    if i == (spectra_number-1):
                        print ('File saved: ', fit_file)
                        print('')


                    if  (save_plot == True):
                        #plotting the fit result
                        fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                        fig.suptitle('line fitting')
                        ax1.plot(line_wave, line_flux_norm, label = 'Spectrum')
                        ax1.plot(line_wave, line_fit, label = 'Fit line spec')
                        ax1.set_xlabel('Wavelength (nm)')
                        ax1.set_ylabel('Norm flux')
                        ax1.legend(fontsize = 10)

                        #plot residuals
                        ax2.plot(line_wave, residual_flux, linewidth=0.5, label = 'Residuals')
                        ax2.hlines(y=0, xmin=min(line_wave), xmax=max(line_wave), linestyles='--', lw=2, linewidth=2, color='r')
                        ax2.set_xlabel('Wavelength (nm)')
                        ax2.set_ylabel('Residuals')
                        ax2.legend(fontsize = 10)

                        plt.savefig(result_plot_dir + '/'+ 'line_fitting_' + spec_names_nopath[i] + '.eps', format='eps', dpi=100)
                        plt.close()



            # 6) KINEMATICS WITH PPXF
            if (perform_kinematics == True):
                task_done2 = 1

                print ('*** Kinematics with the ppxf algorithm ***')

                #wave limits of the spectrum
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                #check on the limits of the input parameters
                if wave1_kin < wave2_kin:
                    wave_limits_kin = (wave1_kin,wave2_kin)
                elif wave1_kin > wave2_kin:
                    #I suppose the wavelength range is inverted:
                    wave1_kin_tmp = wave1_kin
                    wave1_kin = wave2_kin
                    wave2_kin = wave1_kin_tmp
                    wave_limits_kin = (wave1_kin, wave2_kin)

                #checking limits
                if ( wave1_kin < wave_limits[0] or wave2_kin > wave_limits[1]):
                    print ('The window band is out of the spectrum range')
                    #continue

                else:
                    try:
                        if constant_resolution_lambda == True:
                            #fitting with ppxf
                            kinematics, error_kinematics, bestfit_flux, bestfit_wavelength = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin)

                        if constant_resolution_lambda == False:
                            #fitting with ppxf
                            kinematics, error_kinematics, bestfit_flux, bestfit_wavelength = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin)

                        #try:
                        vel = int(kinematics[0])
                        sigma = int(kinematics[1])
                        h3 = round(kinematics[2],3)
                        h4 = round(kinematics[3],3)
                        err_vel = int(error_kinematics[0])
                        err_sigma = int(error_kinematics[1])
                        err_h3 = round(error_kinematics[2],3)
                        err_h4 = round(error_kinematics[3],3)

                        df_kin.at[i, 'RV(km/s)']= vel
                        df_kin.at[i, 'Sigma(km/s)']= sigma
                        df_kin.at[i, 'H3']= h3
                        df_kin.at[i, 'H4']= h4
                        df_kin.at[i, 'errRV']= err_vel
                        df_kin.at[i, 'errSigma']= err_sigma
                        df_kin.at[i, 'errH3']= err_h3
                        df_kin.at[i, 'errH4']= err_h4

                        df_kin.to_csv(kin_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File saved: ', kin_file)
                            print('')

                        #saving the fitted spectrum
                        file_fitted_kin = result_spec+'ppxf_fit_' + spec_names_nopath[i] + '.dat'
                        np.savetxt(file_fitted_kin, np.column_stack([bestfit_wavelength, bestfit_flux]), header="ln_wave \t flux")
                        print ('Fit of the spectra saved to: ', file_fitted_kin)
                        print('')

                        if save_plot == True:
                            plt.plot(bestfit_wavelength, bestfit_flux)

                            vel_string = str(vel)
                            sigma_string = str(sigma)
                            h3_string = str(h3)
                            h4_string = str(h4)
                            plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                            plt.savefig(result_plot_dir + '/'+ 'kin_ppxf_' + spec_names_nopath[i] + '.eps',         format='eps', dpi=100)
                            plt.clf()
                            plt.close()
                        #except TypeError:
                            #print ('Template resolution greater than galaxy spectrum. Fit aborted')
                            #continue
                    except:
                        print ('Something went wrong')



            # 7) STELLAR POPULATIONS WITH PPXF
            if (stellar_pop == True):
                task_done2 = 1

                print ('*** Stellar populations with the ppxf algorithm ***')

                #wave limits of the spectrum
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                #check on the limits of the input parameters
                if wave1_pop < wave2_pop:
                    wave_limits_pop = (wave1_pop,wave2_pop)
                elif wave1_pop > wave2_pop:
                    #I suppose the wavelength range is inverted:
                    wave1_pop_tmp = wave1_pop
                    wave1_pop = wave2_pop
                    wave2_pop = wave1_pop_tmp
                    wave_limits_pop = (wave1_pop, wave2_pop)

                #checking limits
                if (wave1_pop < wave_limits[0] or wave2_pop > wave_limits[1]):
                    print ('The window band is out of the spectrum range')
                    #continue

                else:
                    #doing it
                    try:
                        kinematics, info_pop, info_pop_mass, mass_light, errors, bestfit_flux, bestfit_wave, bestfit_flux_gas, chi_square, err_age, err_met, err_mass_age, err_mass_met, emission_corrected_flux = span.ppxf_pop(wavelength, flux, wave1_pop, wave2_pop, res_pop, z_pop, sigma_guess_pop, fit_components, False, with_errors, save_plot, spec_names_nopath[i], regul_err, additive_degree, multiplicative_degree,ppxf_pop_tie_balmer, stellar_library, ppxf_pop_reddening)

                        #saving only the stellar parameters, which are stored depending on the presence of gas or not
                        try:
                            num_comp_kinematics = len(kinematics)
                            kin_stars = np.array(kinematics[0])
                            rv_pop_ppxf = kin_stars[0]
                            sigma_pop_ppxf = kin_stars[1]
                            h3_pop_ppxf = kin_stars[2]
                            h4_pop_ppxf = kin_stars[3]

                        except (ValueError, IndexError):
                            num_comp_kinematics = 0
                            kin_stars = kinematics

                            rv_pop_ppxf = kinematics[0]
                            sigma_pop_ppxf = kinematics[1]
                            h3_pop_ppxf = kinematics[2]
                            h4_pop_ppxf = kinematics[3]

                        age = (10**info_pop[0])/1e9
                        met = info_pop[1]
                        mass_age = (10**info_pop_mass[0])/1e9
                        mass_met = info_pop_mass[1]

                        df_pop.at[i, 'RV(km/s)']= round(rv_pop_ppxf,2)
                        df_pop.at[i, 'Sigma(km/s)']= round(sigma_pop_ppxf,2)
                        df_pop.at[i, 'H3']= round(h3_pop_ppxf,3)
                        df_pop.at[i, 'H4']= round(h4_pop_ppxf,3)
                        df_pop.at[i, 'lum_age(Gyr)']= round(age,1)
                        df_pop.at[i, 'lum_met(dex)']= round(met,2)
                        df_pop.at[i, 'M/L']= round(mass_light,3)
                        df_pop.at[i, 'mass_age(Gyr)']= round(mass_age,1)
                        df_pop.at[i, 'mass_met(dex)']= round(mass_met,3)
                        df_pop.at[i, 'Chi2']= round(chi_square,3)
                        df_pop.at[i, 'err_lum_age(Gyr)']= round(err_age,2)
                        df_pop.at[i, 'err_lum_met(dex)']= round(err_met,3)
                        df_pop.at[i, 'err_mass_age(Gyr)']= round(err_mass_age,2)
                        df_pop.at[i, 'err_mass_met(dex)']= round(err_mass_met,3)

                        df_pop.to_csv(pop_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File saved: ', pop_file)
                            print('')

                        #saving the spectra residuals and the stellar template
                        #in case I don't have gas
                        #pop_suffix = str(int(round(window_size)))
                        file_fit_pop = result_spec+'ppxf_fit_pop_residuals_' + spec_names_nopath[i] + '.dat'
                        file_fit_stellar_template = result_spec+'ppxf_fit_pop_stellar_template_' + spec_names_nopath[i] + '.dat'
                        file_spec_emission_corrected = result_spec+'ppxf_fit_pop_emission_corrected_' + spec_names_nopath[i] + '.dat'

                        bestfit_wave = bestfit_wave/10.
                        step = wavelength[1]-wavelength[0]

                        #resampling the fit and the gas fit to a common. linear step
                        new_bestfit_wave, new_bestfit_flux, npoint_resampled = span.resample(bestfit_wave, bestfit_flux, step)

                        #extracting the flux of the spectrum in the same wave range of the fit
                        interpfunc = interpolate.interp1d(wavelength, flux, kind = 'linear')
                        flux_window = (interpfunc(new_bestfit_wave))

                        try:
                            if bestfit_flux_gas == 0:
                                stellar_fit_flux = new_bestfit_flux

                                #saving the residual file
                                flux_residuals = flux_window - new_bestfit_flux
                                np.savetxt(file_fit_pop, np.column_stack([new_bestfit_wave, flux_residuals]), header="wavelength \t flux")

                                #saving the template without gas:
                                np.savetxt(file_fit_stellar_template, np.column_stack([new_bestfit_wave, stellar_fit_flux]), header="wavelength \t flux")

                                print ('File containing the residuals of the fit saved: ', file_fit_pop)
                                print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                                print('')

                        except ValueError:
                        #considering also the gas template

                            new_bestfit_wave_gas, new_bestfit_flux_gas, npoint_resampled_gas = span.resample(bestfit_wave, bestfit_flux_gas, step)

                            #saving the residual file
                            flux_residuals = flux_window - new_bestfit_flux
                            np.savetxt(file_fit_pop, np.column_stack([new_bestfit_wave, flux_residuals]), header="wavelength \t flux")

                            #saving the template without gas:
                            stellar_fit_flux = new_bestfit_flux-new_bestfit_flux_gas
                            np.savetxt(file_fit_stellar_template, np.column_stack([new_bestfit_wave, stellar_fit_flux]), header="wavelength \t flux")

                            #saving the emission corrected spectra
                            #rebinning linear
                            ppxf_step = wavelength[1]-wavelength[0]
                            linear_wave_ppxf, emission_corrected_flux, points_spec = span.resample(bestfit_wave, emission_corrected_flux, ppxf_step)

                            np.savetxt(file_spec_emission_corrected, np.column_stack([linear_wave_ppxf, emission_corrected_flux]), header="wavelength \t flux")

                            print ('File containing the residuals of the fit saved: ', file_fit_pop)
                            print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                            print ('File containing the emission corrected spectra (empty if no gas selected): ', file_spec_emission_corrected)
                            print('')
                    except TypeError:
                        print ('Something went wrong')

#************************************ END TASKS ***************************************************************
#**************************************************************************************************************

            #progress meter
            cancel_cond = 0
            if not sg.OneLineProgressMeter('Task progress', i+1, spectra_number, 'Processing spectra:', orientation='h',button_color=('white','red')):
                print ('***CANCELLED***')
                cancel_cond = 1
                print ('')
                break

            #Test to save only the final results, without the intermediate files
            if (save_intermediate_files == True and task_done2 == 0 and (sigma_corr_coeff == False and correct_ew == False)):
                if i == 0:
                    sg.popup('Nothing to process!')
                if not sg.OneLineProgressMeter('Task progress', i+1, spectra_number,  'single', 'Processing spectra:', orientation='h',button_color=('white','red')):
                    break

            if (save_intermediate_files == False and task_spec2 == 1):
                file_final = result_spec+'proc_' + spec_names_nopath[i] + '.dat'
                np.savetxt(file_final, np.column_stack([wavelength, flux]), header="wavelength \t flux")

                #considering also the cont sub task whics saves the continuum!
                if (continuum_sub == True):
                    file_cont = result_spec+'cont_' + spec_names_nopath[i] + '.dat'
                    np.savetxt(file_cont, np.column_stack([wavelength, continuum_flux]), header="wavelength \t flux")
                    print ('File saved: ', file_cont)

                print ('File saved: ', file_final)
                print('')
            elif (save_intermediate_files == False and task_done2 == 0 and (sigma_corr_coeff == False and correct_ew == False)):
                if i == 0:
                    sg.popup('Nothing to process!')
                #window_bar.close()
                continue

        if (task_done2 == 0 and (sigma_corr_coeff == True or correct_ew == True)):
            sg.popup('Nothing to process! If you want to sigma coeff or correct the EW use the gray bottons!')

        if (task_done2 == 0 and (sigma_corr_coeff == False or correct_ew == False)):
            sg.popup('Nothing to process!')

    if (event == 'Process all' and values['one_spec'] == True):
        sg.popup ('With one spectrum this button does not work. Use the process selected')
        continue

##################  END EVENTS ON THE SPECTRA LIST LOADED ##################

#***************** STARTING THE STANDALONE TASKS FOR SIGMA COEFF AND CORRECTION OF THE EW ****************

    if (sigma_corr_coeff == False and event == 'Compute!'):
        sg.popup ('Cannot compute until you activate the Sigma coeff determination task!')

    if (correct_ew == False and event == 'Correct!'):
        sg.popup ('Cannot correct until you activate the Correct EWs for sigma task!')


    # 8) SIGMA COEFF DETERMINATION
    if (event == 'Compute!' and sigma_corr_coeff == True):
        print ('test')
        #preparing the files to be saved
        if (sigma_corr_coeff == True and single_index_corr == True):

            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            if (np.min(index_usr_corr) < wave_limits[0] or np.max(index_usr_corr > wave_limits[1])):
                sg.popup ('The index definition wavelength exceeds the wavelength range of the spectrum')
                continue

            #verify the index definition is in the correct sequence
            if (index_usr_corr[0] > index_usr_corr[1] or index_usr_corr[2] >index_usr_corr[3] or index_usr_corr[4] > index_usr_corr[5]):
                sg.popup('It seems we have a problem. Did you invert the wavelengths of the indices?')
                continue

            coeff_file = result_sigma_coeff_dir+'/'+spectra_list_name+'_sigma_coeff_' +timestamp + '.dat'
            coeff_id = ['sigma_spline', 'err_spline']
            coeff_number = 4
            coeff_values = np.zeros(coeff_number)
            err_coeff_values = np.zeros(coeff_number)
            coeff_data_array = np.column_stack((coeff_values, err_coeff_values))

            #generating the dataframe and adding the data
            df_coeff = pd.DataFrame(coeff_data_array, columns = coeff_id)

            #writing to a file
            df_coeff.to_csv(coeff_file, index= True, sep=' ')

        elif (sigma_corr_coeff == True and single_index_corr == False):
            cond33 = (os.path.isfile(index_file_corr))
            if cond33 == False:
                sg.popup('The index file does not exist. Skipping...')
                continue

            #exploring the index file for errors
            try:
                idx_names, indices = span.read_idx(index_file_corr)
            except ValueError:
                sg.popup('At least one index in the file is not valid')
                continue

            if len(indices[:,0]) < 6:
                sg.popup ('The length of at least one index is not correct')
                continue

            coeff_file = result_sigma_coeff_dir+'/'+spectra_list_name+'_sigma_coeff_' +timestamp + '.dat'
            coeff_number = 4

            id_array, index = span.read_idx(index_file_corr)
            num_indices = len(id_array)

            shape = (coeff_number, num_indices)
            coeff_all = np.zeros(shape)
            coeff_err_all = np.zeros(shape)

            #spectra_id = ['#Spectrum']
            err_col_type = np.chararray(num_indices)
            err_col_type = 'e'
            err_col_names = np.char.add(id_array, err_col_type)
            #unisco i due array dei nomi delle colonne
            col_names = np.concatenate((id_array, err_col_names))
            coeff_id = col_names
            #corr_id = np.concatenate((spectra_id, col_names))
            coeff_data = np.column_stack((coeff_all, coeff_err_all))

            df_coeff = pd.DataFrame(coeff_data, columns = coeff_id)
            df_coeff.to_csv(coeff_file, index= True, sep=' ')


        #1) If I want to measure just one index
        if (sigma_corr_coeff == True and single_index_corr == True):
            task_done2 = 1

            cond666 = (os.path.isfile(stellar_spectra_coeff_file))
            if cond666 == False:
                sg.popup('Stellar spectra file does not exist. Skipping...')
                continue

            #check if the spectra actually exist
            #cheching if the spectra in the sample file exist
            spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])
            check_condition = 0
            sample_spec_not_exist = []
            for x in range (len(spec_names_sample)):
                cond_spec_existence = (os.path.isfile(spec_names_sample[x]))
                if cond_spec_existence == False:
                    sample_spec_not_exist.append(spec_names_sample[x])
                    check_condition = 1
            if check_condition == 1:
                sg.popup ('Warning: the following spectra do not exist! delete from the list or I will crash!', sample_spec_not_exist)
                continue

            print ('Running Sigma coefficient determination task...')

            try: # I need to do this because if I cancel the task python exit with an error, so I use the error that gives to me to stop the computation.
                idx_array, ew_coeff_array, err_coeff_array, ew_mean, ew_std, stop_cond = span.sigma_coeff (stellar_spectra_coeff_file, index_usr_corr, lambda_units_coeff, True, False, smooth_value_sample, save_plot)
            except ValueError:
                continue

            print ('Sigma correction coefficients for usr index')
            print (ew_coeff_array)
            print ('')
            print ('Error correction coefficients for usr index')
            print (err_coeff_array)

            df_coeff.iloc[:, 0]= ew_coeff_array
            df_coeff.iloc[:, 1]= err_coeff_array
            df_coeff.columns = ['sigma_spline', 'err_spline']
            df_coeff.to_csv(coeff_file, index= False, sep=' ')

            print ('File saved: ', coeff_file)
            print('')

        if (sigma_corr_coeff == True and single_index_corr == False):
            task_done2 = 1

            #reading the index file
            try:
                id_array, index = span.read_idx(index_file_corr)
                num_indices = len(id_array)
            except Exception:
                sg.popup ('The index file does not exist!')
                continue

            cond666 = (os.path.isfile(stellar_spectra_coeff_file))
            if cond666 == False:
                sg.popup('Stellar spectra file does not exist. Skipping...')
                continue

            #check if the spectra actually exist
            #cheching if the spectra in the sample file exist
            spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])

            check_condition = 0
            sample_spec_not_exist = []
            for x in range (len(spec_names_sample)):
                cond_spec_existence = (os.path.isfile(spec_names_sample[x]))
                if cond_spec_existence == False:
                    sample_spec_not_exist.append(spec_names_sample[x])
                    check_condition = 1
            if check_condition == 1:
                sg.popup ('Warning: the following spectra do not exist! delete from the list or I will crash!', sample_spec_not_exist)
                continue

            #the existence condition has been set before (line 847 more or less)
            print ('Running Sigma coefficient determination task...')

            try:
                idx_array, ew_coeff_array, err_coeff_array, ew_mean, ew_std, stop_cond = span.sigma_coeff (stellar_spectra_coeff_file, index_file_corr, lambda_units_coeff, False, False, smooth_value_sample, save_plot)
            except ValueError:
                continue


            for k in range(num_indices):
                ew_coeff_array_new = ew_coeff_array[:,k]
                err_coeff_array_new = err_coeff_array[:,k]

                #new instead of .at or .iloc, 2023/11/07
                df_coeff[coeff_id[k]]= ew_coeff_array_new
                df_coeff[coeff_id[k+num_indices]] = err_coeff_array_new
                df_coeff.to_csv(coeff_file, index= False, sep=' ')

            print ('File saved: ', coeff_file)
            print('')

            print ('Indices')
            print (idx_array)
            print ('')
            print ('Sigma correction coefficients')
            print (ew_coeff_array)
            print ('')
            print ('Error correction coefficients')
            print (err_coeff_array)



    #9) CORRECT EWS FOR SIGMA
    if (event == 'Correct!'):
        if correct_ew == True:
            task_done2 = 1

            cond77 = (os.path.isfile(sigma_coeff_file))
            if cond77 == False:
                sg.popup('Sigma coefficient file does not exist. Skipping...')
                continue

            cond66 = (os.path.isfile(ew_list_file))
            if cond66 == False:
                sg.popup('EW file does not exist. Skipping...')
                continue

            cond88 = (os.path.isfile(sigma_vel_file))
            if cond88 == False:
                sg.popup('Sigma velocities file does not exist. Skipping...')
                continue

            print ('Running correct EWs task...')

            try:
                all_idx_np, new_ew_data = span.corr_ew(ew_list_file, sigma_coeff_file, sigma_vel_file)
            except ValueError:
                sg.popup ('Cannot compare apples with oranges! The EW file and the correction coefficients file do not have the same indices. ')
                continue


            #creating and saving here the file since is one shot only
            results_ew = result_ew_data_dir+'/'+spectra_list_name+'_sigma_corr_ew_data_' + timestamp + '.dat'
            df = pd.DataFrame(new_ew_data, columns = all_idx_np)
            df.to_csv(results_ew, index= False, sep=' ')
            print('EWs corrected saved to ', results_ew)
            sg.popup ('Succeed!')

#*********************************** END TASKS ******************************************


    # CREATING LICK IDS FILE FOR SSP
    if (ew_measurement == True and lick_ew == True and event == 'Process all' and cancel_cond == 0):

        #converting lists to numpy array
        Hbeta = np.array(Hbeta)
        Hbetae = np.array(Hbetae)
        Mg2=np.array(Mg2)
        Mg2e=np.array(Mg2e)
        Mgb=np.array(Mgb)
        Mgbe=np.array(Mgbe)
        Fe5270=np.array(Fe5270)
        Fe5270e=np.array(Fe5270e)
        Fe5335=np.array(Fe5335)
        Fe5335e=np.array(Fe5335e)

        #creating composite indices and uncertainties and getting rid of (eventual) NaNs
        Fem = (Fe5270+Fe5335)/2
        Feme = np.sqrt(Fe5270e**2+Fe5335e**2)*2
        MgFe = (np.sqrt(Mgb*(0.72*Fe5270+0.28*Fe5335)))
        MgFe = np.nan_to_num(MgFe, nan=0)
        MgFee = np.sqrt((((Fe5270*18/25+Fe5335*7/25)/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Mgbe)**2+((Mgb*18/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5270e)**2+((Mgb*7/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5335e)**2)
        MgFee = np.nan_to_num(MgFee, nan=0)


        #saving the file
        data = {
            '#Spectra': spec_names_nopath,
            'Hbeta': np.round(Hbeta,3),
            'Hbetae': np.round(Hbetae,3),
            'Mg2': np.round(Mg2,3),
            'Mg2e': np.round(Mg2e,3),
            'Mgb': np.round(Mgb,3),
            'Mgbe': np.round(Mgbe,3),
            'Fe5270': np.round(Fe5270,3),
            'Fe5270e': np.round(Fe5270e,3),
            'Fe5335': np.round(Fe5335,3),
            'Fe5335e': np.round(Fe5335e,3),
            'Fem': np.round(Fem,3),
            'Feme': np.round(Feme,3),
            'MgFe': np.round(MgFe,3),
            'MgFee': np.round(MgFee,3)
                }
        try:
            df = pd.DataFrame(data)
            file_path = result_ew_data_dir+'/'+spectra_list_name + '_lick_for_SSP_'+ timestamp + '_.dat'
            df.to_csv(file_path, sep=' ', index=False)
            print ('File with the Lick/IDS indices used for stellar parameters saved: ', file_path)
        except ValueError:
            print ('Nothing to save')


#************************************** END PROGRAM ROUTINES **********************************************




#************************************** SAVE AND LOAD PARAMETER VALUES *********************************************
    if event == 'Save parameters...':

        # Onep a window to select the path to save the file
        filename = sg.popup_get_file('Save file as...', save_as=True, default_extension=".json", file_types=(("JSON Files", "*.json"),))

        #saving the file
        if filename:
            try:
                save_settings(filename, keys, events, values)
                print('User settings saved')
                sg.popup_ok(f'Configuration file saved:\n{filename}')
            except json.JSONDecodeError:
                sg.popup_error('Content not valid for JSON.')


    if event == 'Load parameters...':
        filename = sg.popup_get_file('Select the file to load...', file_types=(("JSON Files", "*.json"),))

        try:
            keys, events, loaded_values = load_settings(filename)
            values.update(loaded_values)
            window['spec_list'].update(value=values.get('spec_list', ''))
            window['wave_units_nm'].update(value=values.get('wave_units_nm', True))
            window['wave_units_a'].update(value=values.get('wave_units_a', False))
            window['wave_units_mu'].update(value=values.get('wave_units_mu', False))
            window['show_hdr'].update(value=values.get('show_hdr', False))
            window['show_step'].update(value=values.get('show_step', False))
            window['show_res'].update(value=values.get('show_res', False))
            window['lambda_res_left'].update(value=values.get('lambda_res_left', ''))
            window['lambda_res_right'].update(value=values.get('lambda_res_right', ''))
            window['convert_spec'].update(value=values.get('convert_spec', False))
            window['convert_to_txt'].update(value=values.get('convert_to_txt', False))
            window['convert_to_fits'].update(value=values.get('convert_to_fits', False))
            window['compare_spec'].update(value=values.get('compare_spec', False))
            window['spec_to_compare'].update(value=values.get('spec_to_compare', ''))
            window['convert_flux'].update(value=values.get('convert_flux', False))
            window['convert_to_fnu'].update(value=values.get('convert_to_fnu', False))
            window['convert_to_fl'].update(value=values.get('convert_to_fl', False))
            window['show_snr'].update(value=values.get('show_snr', False))
            window['wave_snr'].update(value=values.get('wave_snr', ''))
            window['delta_wave_snr'].update(value=values.get('delta_wave_snr', ''))
            window['cropping'].update(value=values.get('cropping',False))
            window['cropping_low_wave'].update(value=values.get('cropping_low_wave',''))
            window['cropping_high_wave'].update(value=values.get('cropping_high_wave',''))
            window['sigma_clip'].update(value=values.get('sigma_clip', False))
            clip_factor = values['clip_factor']
            sigma_clip_resolution = values['res_spec_for_sigma_clip']
            sigma_clip_single_vel = values['single_vel_clip']
            sigma_clip_vel_value = values['clip_to_vel']
            sigma_clip_have_file = values['file_for_clip']
            sigma_clip_sigma_file = values['sigma_clip_file']
            window['wavelet_cleaning'].update(value=values.get('wavelet_cleaning', False))
            window['sigma_wavelets'].update(value=values.get('sigma_wavelets',''))
            window['wavelets_layers'].update(value=values.get('wavelets_layers',''))
            window['dopcor'].update(value=values.get('dopcor', False))
            dop_cor_single_shot_vel = values['dopcor_value']
            dop_cor_have_file =  values['file_for_dopcor']
            dop_cor_file =  values['dopcor_file']
            dop_cor_single_shot =  values['dopcor_single_value']
            window['helio_corr'].update(value=values.get('helio_corr', False))
            helio_have_file = values['file_for_helio']
            helio_file = values['helio_file']
            helio_single_shot = values['helio_single_value']
            helio_single_shot_location = values['helio_location']
            helio_single_shot_date = values['helio_date']
            ra_obj = values['helio_ra']
            dec_obj = values['helio_dec']
            window['rebin'].update(value=values['rebin'],)
            window['rebin_pix_lin'].update(value=values['rebin_pix_lin'],)
            window['rebin_step_pix'].update(value=values['rebin_step_pix'],)
            window['rebin_sigma_lin'].update(value=values['rebin_sigma_lin'],)
            window['rebin_step_sigma'].update(value=values['rebin_step_sigma'],)
            window['degrade_resolution'].update(value=values['degrade_resolution'],)
            is_initial_res_r = values['is_initial_res_r']
            initial_res_r = values['degrade_from_r']
            res_degrade_to_r = values['res_degrade_to_r']
            final_res_r = values['degrade_to_r']
            res_degrade_to_fwhm = values['res_degrade_to_fwhm']
            final_res_r_to_fwhm = values['final_res_r_to_fwhm']
            is_initial_res_fwhm = values['is_initial_res_fwhm']
            initial_res_fwhm = values['degrade_from_l']
            final_res_fwhm  = values['degrade_to_l']
            window['norm_spec'].update(value=values['norm_spec'],)
            window['norm_wave'].update(value=values['norm_wave'],)
            window['cont_sub'].update(value=values['cont_sub'],)

            cont_model_filtering = values['cont_model_filtering']
            cont_model_poly = values['cont_model_poly']
            cont_math_operation = values['markers_cont_operations']
            cont_want_to_maks = values['cont_want_to_maks']
            cont_mask_ranges_str = values['cont_mask_ranges']
            cont_poly_degree = values['cont_poly_degree']

            window['broadening_spec'].update(value=values['broadening_spec'],)
            window['sigma_to_add'].update(value=values['sigma_to_add'],)
            window['add_noise'].update(value=values['add_noise'],)
            window['noise_to_add'].update(value=values['noise_to_add'],)

            window['filter_denoise'].update(value=values['filter_denoise'],)
            moving_average = values['moving_average']
            box_moving_avg = values['box_moving_avg']
            box_moving_avg_size = values['box_moving_avg_size']
            gauss_moving_avg = values['gauss_moving_avg']
            gauss_moving_avg_kernel = values['gauss_moving_avg_kernel']
            low_pass_filter = values['low_pass_filter']
            lowpass_cut_off = values['lowpass_cut_off']
            lowpass_order = values['lowpass_order']
            bandpass_filter = values['bandpass_filter']
            bandpass_lower_cut_off = values['bandpass_lower_cut_off']
            bandpass_upper_cut_off = values['bandpass_upper_cut_off']
            bandpass_order = values['bandpass_order']

            window['avg_all'].update(value=values['avg_all'],)
            window['norm_avg_all'].update(value=values['norm_avg_all'],)
            window['none'].update(value=values['none'],)
            window['sum_all'].update(value=values['sum_all'],)
            window['norm_sum_all'].update(value=values['norm_sum_all'],)
            window['use_for_spec_an'].update(value=values['use_for_spec_an'],)
            window['subtract_norm_avg'].update(value=values['subtract_norm_avg'],)
            window['subtract_norm_spec'].update(value=values['subtract_norm_spec'],)
            window['spec_to_sobtract'].update(value=values['spec_to_sobtract'],)
            window['add_pedestal'].update(value=values['add_pedestal'],)
            window['pedestal_to_add'].update(value=values['pedestal_to_add'],)
            window['multiply'].update(value=values['multiply'],)
            window['multiply_factor'].update(value=values['multiply_factor'],)
            window['bb_fitting'].update(value=values['bb_fitting'],)
            window['xcorr'].update(value=values['xcorr'],)
            window['sigma_measurement'].update(value=values['sigma_measurement'],)
            window['ew_measurement'].update(value=values['ew_measurement'],)
            window['line_fitting'].update(value=values['line_fitting'],)
            window['ppxf_kin'].update(value=values['ppxf_kin'],)
            window['ppxf_pop'].update(value=values['ppxf_pop'],)
            window['sigma_coeff'].update(value=values['sigma_coeff'],)
            window['sigma_corr'].update(value=values['sigma_corr'],)
            window['save_intermediate_files'].update(value=values['save_intermediate_files'],)
            window['save_plots'].update(value=values['save_plots'],)
            wave1_bb=values['left_wave_bb']
            wave2_bb=values['right_wave_bb']
            t_guess=values['t_guess_bb']
            template_crosscorr=values['xcorr_template']
            lambda_units_template_crosscorr_nm=values['xcorr_template_wave_nm']
            lambda_units_template_crosscorr_a=values['xcorr_template_wave_a']
            lambda_units_template_crosscorr_mu=values['xcorr_template_wave_mu']
            smooth_template_crosscorr=values['xcorr_smooth_template']
            smooth_value_crosscorr=values['xcorr_smooth_template_value']
            limit_range_corr=values['xcorr_wave_range']
            low_wave_corr=values['xcorr_left_lambda']
            high_wave_corr=values['xcorr_right_lambda']
            vel_range_corr=values['xcorr_vel_range']
            low_vel_corr=values['xcorr_low_vel']
            high_vel_corr=values['xcorr_high_vel']
            template_sigma=values['sigma_template']
            lambda_units_template_sigma_nm=values['lambda_units_template_sigma_nm']
            lambda_units_template_sigma_a=values['lambda_units_template_sigma_a']
            lambda_units_template_sigma_mu=values['lambda_units_template_sigma_mu']
            band_cat=values['band_cat']
            band_halpha=values['band_halpha']
            band_nad=values['band_nad']
            band_h=values['band_h']
            band_k=values['band_k']
            resolution_spec=values['resolution_spec']
            resolution_template=values['resolution_template']
            band_custom=values['band_custom']
            low_wave_sigma=values['low_wave_sigma']
            high_wave_sigma=values['high_wave_sigma']
            low_wave_cont=values['low_wave_cont']
            high_wave_cont=values['high_wave_cont']
            have_index_file=values['ew_idx_file']
            index_file=values['idx_file']
            single_index=values['single_index']
            idx_left_blue=values['left_wave_blue_cont']
            idx_right_blue=values['right_wave_blue_cont']
            idx_left_red=values['left_wave_red_cont']
            idx_right_red=values['right_wave_red_cont']
            idx_left_line=values['left_line']
            idx_right_line=values['right_line']
            lick_ew=values['ew_lick']
            lick_constant_fwhm=values['lick_constant_fwhm']
            spec_lick_res_fwhm=values['spec_lick_res_fwhm']
            lick_constant_r=values['lick_constant_r']
            spec_lick_res_r=values['spec_lick_res_r']
            lick_correct_emission=values['lick_correct_emission']
            z_guess_lick_emission=values['z_guess_lick_emission']
            dop_correction_lick=values['dop_correction_lick']
            correct_ew_sigma=values['correct_ew_sigma']
            radio_lick_sigma_auto=values['radio_lick_sigma_auto']
            radio_lick_sigma_single=values['radio_lick_sigma_single']
            sigma_single_lick=values['sigma_single_lick']
            radio_lick_sigma_list=values['radio_lick_sigma_list']
            sigma_lick_file=values['sigma_lick_file']
            stellar_parameters_lick=values['stellar_parameters_lick']
            cat_band_fit=values['cat_fit']
            usr_fit_line=values['line_fit_single']
            emission_line=values['emission_line']
            low_wave_fit=values['left_wave_fitting']
            high_wave_fit=values['right_wave_fitting']
            y0=values['y0']
            x0=values['x0']
            a=values['a']
            sigma=values['sigma']
            m=values['m']
            c=values['c']
            wave1_kin=values['left_wave_ppxf_kin']
            wave2_kin=values['right_wave_ppxf_kin']
            stellar_library_kin = values['stellar_library_kin']
            constant_resolution_lambda=values['constant_resolution_lambda']
            resolution_kin=values['ppxf_resolution']
            constant_resolution_r=values['constant_resolution_r']
            resolution_kin_r=values['ppxf_resolution_r']
            sigma_guess_kin=values['sigma_guess_kin']
            redshift_guess_kin=values['redshift_guess_kin']
            additive_degree_kin=values['additive_degree_kin']
            wave1_pop=values['left_wave_ppxf_pop']
            wave2_pop=values['right_wave_ppxf_pop']
            res_pop=values['resolution_ppxf_pop']
            sigma_guess_pop=values['sigma_guess_pop']
            z_pop=values['ppxf_z_pop']
            pop_with_gas=values['gas_pop']
            ppxf_pop_tie_balmer=values['ppxf_pop_tie_balmer']
            ppxf_pop_reddening=values['ppxf_pop_reddening']
            pop_without_gas=values['no_gas_pop']
            regul_err=values['regul_err']
            additive_degree=values['additive_degree']
            multiplicative_degree=values['multiplicative_degree']
            stellar_library = values['stellar_library']
            with_errors=values['ppxf_err_pop']
            have_index_file_corr=values['ew_corr_idx_file']
            index_file_corr=values['idx_corr_file']
            single_index_corr=values['ew_corr_single_idx']
            stellar_spectra_coeff_file=values['stellar_spectra_coeff_file']
            stellar_spectra_coeff_file=values['sigma_coeff_sample_list']
            lambda_units_coeff_nm=values['sigma_coeff_sample_list_wave_nm']
            lambda_units_coeff_a=values['sigma_coeff_sample_list_wave_a']
            lambda_units_coeff_mu=values['sigma_coeff_sample_list_wave_mu']
            smooth_stellar_sample=values['sigma_coeff_sample_smooth']
            smooth_value_sample=values['sigma_coeff_sample_smooth_sigma']
            sigma_vel_file=values['sigma_file']
            ew_list_file=values['ew_file_to_correct']
            sigma_coeff_file=values['coeff_sigma_file']

            sg.Popup('User settings loaded')
            print('User settings loaded')
        except:
            sg.Popup('Problem loading parameters. Please, verify the settings file')
            print ('Problem loading parameters. Please, verify the settings file')
            continue

    keys.append(event)
    events.append(event)



    if event == 'Restore default parameters':
        keys, events, loaded_values = load_settings('default_settings.json')
        values.update(loaded_values)
        window['spec_list'].update(value=values.get('spec_list', ''))
        window['one_spec'].update(value=values.get('one_spec', False))
        window['wave_units_nm'].update(value=values.get('wave_units_nm', True))
        window['wave_units_a'].update(value=values.get('wave_units_a', False))
        window['wave_units_mu'].update(value=values.get('wave_units_mu', False))
        window['show_hdr'].update(value=values.get('show_hdr', False))
        window['show_step'].update(value=values.get('show_step', False))
        window['show_res'].update(value=values.get('show_res', False))
        window['lambda_res_left'].update(value=values.get('lambda_res_left', ''))
        window['lambda_res_right'].update(value=values.get('lambda_res_right', ''))
        window['convert_spec'].update(value=values.get('convert_spec', False))
        window['convert_to_txt'].update(value=values.get('convert_to_txt', False))
        window['convert_to_fits'].update(value=values.get('convert_to_fits', False))
        window['compare_spec'].update(value=values.get('compare_spec', False))
        window['spec_to_compare'].update(value=values.get('spec_to_compare', ''))
        window['convert_flux'].update(value=values.get('convert_flux', False))
        window['convert_to_fnu'].update(value=values.get('convert_to_fnu', False))
        window['convert_to_fl'].update(value=values.get('convert_to_fl', False))
        window['show_snr'].update(value=values.get('show_snr', False))
        window['wave_snr'].update(value=values.get('wave_snr', ''))
        window['delta_wave_snr'].update(value=values.get('delta_wave_snr', ''))
        window['cropping'].update(value=values.get('cropping',False))
        window['cropping_low_wave'].update(value=values.get('cropping_low_wave',''))
        window['cropping_high_wave'].update(value=values.get('cropping_high_wave',''))

        window['sigma_clip'].update(value=values.get('sigma_clip', False))
        clip_factor = values['clip_factor']
        sigma_clip_resolution = values['res_spec_for_sigma_clip']
        sigma_clip_single_vel = values['single_vel_clip']
        sigma_clip_vel_value = values['clip_to_vel']
        sigma_clip_have_file = values['file_for_clip']
        sigma_clip_sigma_file = values['sigma_clip_file']
        window['wavelet_cleaning'].update(value=values.get('wavelet_cleaning', False))
        window['sigma_wavelets'].update(value=values.get('sigma_wavelets',''))
        window['wavelets_layers'].update(value=values.get('wavelets_layers',''))
        window['dopcor'].update(value=values.get('dopcor', False))
        dop_cor_single_shot_vel = values['dopcor_value']
        dop_cor_have_file =  values['file_for_dopcor']
        dop_cor_file =  values['dopcor_file']
        dop_cor_single_shot =  values['dopcor_single_value']
        window['helio_corr'].update(value=values.get('helio_corr', False))
        helio_have_file = values['file_for_helio']
        helio_file = values['helio_file']
        helio_single_shot = values['helio_single_value']
        helio_single_shot_location = values['helio_location']
        helio_single_shot_date = values['helio_date']
        ra_obj = values['helio_ra']
        dec_obj = values['helio_dec']
        window['rebin'].update(value=values['rebin'],)
        window['rebin_pix_lin'].update(value=values['rebin_pix_lin'],)
        window['rebin_step_pix'].update(value=values['rebin_step_pix'],)
        window['rebin_sigma_lin'].update(value=values['rebin_sigma_lin'],)
        window['rebin_step_sigma'].update(value=values['rebin_step_sigma'],)
        window['degrade_resolution'].update(value=values['degrade_resolution'],)
        is_initial_res_r = values['is_initial_res_r']
        initial_res_r = values['degrade_from_r']
        res_degrade_to_r = values['res_degrade_to_r']
        final_res_r = values['degrade_to_r']
        res_degrade_to_fwhm = values['res_degrade_to_fwhm']
        final_res_r_to_fwhm = values['final_res_r_to_fwhm']
        is_initial_res_fwhm = values['is_initial_res_fwhm']
        initial_res_fwhm = values['degrade_from_l']
        final_res_fwhm  = values['degrade_to_l']
        window['norm_spec'].update(value=values['norm_spec'],)
        window['norm_wave'].update(value=values['norm_wave'],)
        window['cont_sub'].update(value=values['cont_sub'],)
        cont_model_filtering = values['cont_model_filtering']
        cont_model_poly = values['cont_model_poly']
        cont_math_operation = values['markers_cont_operations']
        cont_want_to_maks = values['cont_want_to_maks']
        cont_mask_ranges_str = values['cont_mask_ranges']
        cont_poly_degree = values['cont_poly_degree']

        window['broadening_spec'].update(value=values['broadening_spec'],)
        window['sigma_to_add'].update(value=values['sigma_to_add'],)
        window['add_noise'].update(value=values['add_noise'],)
        window['noise_to_add'].update(value=values['noise_to_add'],)

        window['filter_denoise'].update(value=values['filter_denoise'],)
        moving_average = values['moving_average']
        box_moving_avg = values['box_moving_avg']
        box_moving_avg_size = values['box_moving_avg_size']
        gauss_moving_avg = values['gauss_moving_avg']
        gauss_moving_avg_kernel = values['gauss_moving_avg_kernel']
        low_pass_filter = values['low_pass_filter']
        lowpass_cut_off = values['lowpass_cut_off']
        lowpass_order = values['lowpass_order']
        bandpass_filter = values['bandpass_filter']
        bandpass_lower_cut_off = values['bandpass_lower_cut_off']
        bandpass_upper_cut_off = values['bandpass_upper_cut_off']
        bandpass_order = values['bandpass_order']

        window['avg_all'].update(value=values['avg_all'],)
        window['norm_avg_all'].update(value=values['norm_avg_all'],)
        window['none'].update(value=values['none'],)
        window['sum_all'].update(value=values['sum_all'],)
        window['norm_sum_all'].update(value=values['norm_sum_all'],)
        window['use_for_spec_an'].update(value=values['use_for_spec_an'],)
        window['subtract_norm_avg'].update(value=values['subtract_norm_avg'],)
        window['subtract_norm_spec'].update(value=values['subtract_norm_spec'],)
        window['spec_to_sobtract'].update(value=values['spec_to_sobtract'],)
        window['add_pedestal'].update(value=values['add_pedestal'],)
        window['pedestal_to_add'].update(value=values['pedestal_to_add'],)
        window['multiply'].update(value=values['multiply'],)
        window['multiply_factor'].update(value=values['multiply_factor'],)
        window['bb_fitting'].update(value=values['bb_fitting'],)
        window['xcorr'].update(value=values['xcorr'],)
        window['sigma_measurement'].update(value=values['sigma_measurement'],)
        window['ew_measurement'].update(value=values['ew_measurement'],)
        window['line_fitting'].update(value=values['line_fitting'],)
        window['ppxf_kin'].update(value=values['ppxf_kin'],)
        window['ppxf_pop'].update(value=values['ppxf_pop'],)
        window['sigma_coeff'].update(value=values['sigma_coeff'],)
        window['sigma_corr'].update(value=values['sigma_corr'],)
        window['save_intermediate_files'].update(value=values['save_intermediate_files'],)
        window['save_plots'].update(value=values['save_plots'],)
        wave1_bb=values['left_wave_bb']
        wave2_bb=values['right_wave_bb']
        t_guess=values['t_guess_bb']
        template_crosscorr=values['xcorr_template']
        lambda_units_template_crosscorr_nm=values['xcorr_template_wave_nm']
        lambda_units_template_crosscorr_a=values['xcorr_template_wave_a']
        lambda_units_template_crosscorr_mu=values['xcorr_template_wave_mu']
        smooth_template_crosscorr=values['xcorr_smooth_template']
        smooth_value_crosscorr=values['xcorr_smooth_template_value']
        limit_range_corr=values['xcorr_wave_range']
        low_wave_corr=values['xcorr_left_lambda']
        high_wave_corr=values['xcorr_right_lambda']
        vel_range_corr=values['xcorr_vel_range']
        low_vel_corr=values['xcorr_low_vel']
        high_vel_corr=values['xcorr_high_vel']
        template_sigma=values['sigma_template']
        lambda_units_template_sigma_nm=values['lambda_units_template_sigma_nm']
        lambda_units_template_sigma_a=values['lambda_units_template_sigma_a']
        lambda_units_template_sigma_mu=values['lambda_units_template_sigma_mu']
        band_cat=values['band_cat']
        band_halpha=values['band_halpha']
        band_nad=values['band_nad']
        band_h=values['band_h']
        band_k=values['band_k']
        resolution_spec=values['resolution_spec']
        resolution_template=values['resolution_template']
        band_custom=values['band_custom']
        low_wave_sigma=values['low_wave_sigma']
        high_wave_sigma=values['high_wave_sigma']
        low_wave_cont=values['low_wave_cont']
        high_wave_cont=values['high_wave_cont']
        have_index_file=values['ew_idx_file']
        index_file=values['idx_file']
        single_index=values['single_index']
        idx_left_blue=values['left_wave_blue_cont']
        idx_right_blue=values['right_wave_blue_cont']
        idx_left_red=values['left_wave_red_cont']
        idx_right_red=values['right_wave_red_cont']
        idx_left_line=values['left_line']
        idx_right_line=values['right_line']
        lick_ew=values['ew_lick']
        lick_constant_fwhm=values['lick_constant_fwhm']
        spec_lick_res_fwhm=values['spec_lick_res_fwhm']
        lick_constant_r=values['lick_constant_r']
        spec_lick_res_r=values['spec_lick_res_r']
        lick_correct_emission=values['lick_correct_emission']
        z_guess_lick_emission=values['z_guess_lick_emission']
        dop_correction_lick=values['dop_correction_lick']
        correct_ew_sigma=values['correct_ew_sigma']
        radio_lick_sigma_auto=values['radio_lick_sigma_auto']
        radio_lick_sigma_single=values['radio_lick_sigma_single']
        sigma_single_lick=values['sigma_single_lick']
        radio_lick_sigma_list=values['radio_lick_sigma_list']
        sigma_lick_file=values['sigma_lick_file']
        stellar_parameters_lick=values['stellar_parameters_lick']
        cat_band_fit=values['cat_fit']
        usr_fit_line=values['line_fit_single']
        emission_line=values['emission_line']
        low_wave_fit=values['left_wave_fitting']
        high_wave_fit=values['right_wave_fitting']
        y0=values['y0']
        x0=values['x0']
        a=values['a']
        sigma=values['sigma']
        m=values['m']
        c=values['c']
        wave1_kin=values['left_wave_ppxf_kin']
        wave2_kin=values['right_wave_ppxf_kin']
        stellar_library_kin = values['stellar_library_kin']
        constant_resolution_lambda=values['constant_resolution_lambda']
        resolution_kin=values['ppxf_resolution']
        constant_resolution_r=values['constant_resolution_r']
        resolution_kin_r=values['ppxf_resolution_r']
        sigma_guess_kin=values['sigma_guess_kin']
        redshift_guess_kin=values['redshift_guess_kin']
        additive_degree_kin=values['additive_degree_kin']
        wave1_pop=values['left_wave_ppxf_pop']
        wave2_pop=values['right_wave_ppxf_pop']
        res_pop=values['resolution_ppxf_pop']
        sigma_guess_pop=values['sigma_guess_pop']
        z_pop=values['ppxf_z_pop']
        pop_with_gas=values['gas_pop']
        ppxf_pop_tie_balmer=values['ppxf_pop_tie_balmer']
        ppxf_pop_reddening=values['ppxf_pop_reddening']
        pop_without_gas=values['no_gas_pop']
        regul_err=values['regul_err']
        additive_degree=values['additive_degree']
        multiplicative_degree=values['multiplicative_degree']
        stellar_library = values['stellar_library']
        with_errors=values['ppxf_err_pop']
        have_index_file_corr=values['ew_corr_idx_file']
        index_file_corr=values['idx_corr_file']
        single_index_corr=values['ew_corr_single_idx']
        stellar_spectra_coeff_file=values['stellar_spectra_coeff_file']
        stellar_spectra_coeff_file=values['sigma_coeff_sample_list']
        lambda_units_coeff_nm=values['sigma_coeff_sample_list_wave_nm']
        lambda_units_coeff_a=values['sigma_coeff_sample_list_wave_a']
        lambda_units_coeff_mu=values['sigma_coeff_sample_list_wave_mu']
        smooth_stellar_sample=values['sigma_coeff_sample_smooth']
        smooth_value_sample=values['sigma_coeff_sample_smooth_sigma']
        sigma_vel_file=values['sigma_file']
        ew_list_file=values['ew_file_to_correct']
        sigma_coeff_file=values['coeff_sigma_file']

        print('Default settings restored')
    keys.append(event)
    events.append(event)
########################### AT LAST: END OF THE PROGRAM! ####################################
window.close()
